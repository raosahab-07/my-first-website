{"version":3,"sources":["../../../../../client/node_modules/next/dist/shared/lib/router/utils/querystring.js","../../../../../client/node_modules/next/dist/shared/lib/router/utils/format-url.js","../../../../../client/node_modules/next/dist/shared/lib/utils.js","../../../../../client/node_modules/next/dist/shared/lib/router/utils/parse-path.js","../../../../../client/node_modules/next/src/shared/lib/router/utils/add-path-prefix.ts","../../../../../client/node_modules/next/dist/shared/lib/router/utils/remove-trailing-slash.js","../../../../../client/node_modules/next/dist/client/normalize-trailing-slash.js","../../../../../client/node_modules/next/src/client/add-base-path.ts","../../../../../client/node_modules/next/dist/client/components/segment-cache/types.js","../../../../../client/node_modules/next/src/client/components/segment-cache/cache-key.ts","../../../../../client/node_modules/next/src/shared/lib/app-router-types.ts","../../../../../client/node_modules/next/dist/client/components/match-segments.js","../../../../../client/node_modules/next/src/client/components/app-router-headers.ts","../../../../../client/node_modules/next/dist/client/components/router-reducer/router-reducer-types.js","../../../../../client/node_modules/next/dist/shared/lib/is-thenable.js","../../../../../client/node_modules/next/dist/client/components/use-action-queue.js","../../../../../client/node_modules/next/src/client/app-call-server.ts","../../../../../client/node_modules/next/src/client/app-find-source-map-url.ts","../../../../../client/node_modules/next/dist/shared/lib/segment-cache/segment-value-encoding.js","../../../../../client/node_modules/next/dist/client/route-params.js","../../../../../client/node_modules/next/src/client/components/router-reducer/create-href-from-url.ts","../../../../../client/node_modules/next/dist/client/flight-data-helpers.js","../../../../../client/node_modules/next/src/client/app-build-id.ts","../../../../../client/node_modules/next/dist/shared/lib/hash.js","../../../../../client/node_modules/next/src/shared/lib/router/utils/cache-busting-search-param.ts","../../../../../client/node_modules/next/dist/client/components/router-reducer/set-cache-busting-search-param.js","../../../../../client/node_modules/next/dist/client/components/router-reducer/fetch-server-response.js","../../../../../client/node_modules/next/dist/client/components/segment-cache/lru.js","../../../../../client/node_modules/next/src/client/components/segment-cache/cache-map.ts","../../../../../client/node_modules/next/dist/client/components/segment-cache/vary-path.js","../../../../../client/node_modules/next/dist/shared/lib/page-path/ensure-leading-slash.js","../../../../../client/node_modules/next/src/shared/lib/router/utils/app-paths.ts","../../../../../client/node_modules/next/dist/shared/lib/router/utils/interception-routes.js","../../../../../client/node_modules/next/src/client/components/router-reducer/compute-changed-path.ts","../../../../../client/node_modules/next/dist/client/components/router-reducer/handle-mutable.js","../../../../../client/node_modules/next/src/client/components/router-reducer/create-router-cache-key.ts","../../../../../client/node_modules/next/dist/client/components/router-reducer/is-navigating-to-new-root-layout.js","../../../../../client/node_modules/next/dist/client/components/router-reducer/ppr-navigations.js","../../../../../client/node_modules/next/dist/client/components/segment-cache/navigation.js","../../../../../client/node_modules/next/dist/client/components/router-reducer/reducers/navigate-reducer.js","../../../../../client/node_modules/next/dist/shared/lib/promise-with-resolvers.js","../../../../../client/node_modules/next/src/client/components/segment-cache/cache.ts","../../../../../client/node_modules/next/dist/client/components/segment-cache/scheduler.js","../../../../../client/node_modules/next/dist/client/components/links.js","../../../../../client/node_modules/next/dist/shared/lib/router/utils/path-has-prefix.js","../../../../../client/node_modules/next/dist/client/has-base-path.js","../../../../../client/node_modules/next/dist/shared/lib/router/utils/is-local-url.js","../../../../../client/node_modules/next/dist/shared/lib/utils/error-once.js","../../../../../client/node_modules/next/dist/client/app-dir/link.js","../../../../../client/src/components/admin/sidebar.tsx","../../../../../client/src/app/admin/layout.tsx","../../../../../client/node_modules/lucide-react/src/icons/chevron-left.ts","../../../../../client/node_modules/lucide-react/src/icons/chevron-right.ts","../../../../../client/node_modules/lucide-react/src/icons/chart-column.ts","../../../../../client/node_modules/lucide-react/src/icons/layout-dashboard.ts","../../../../../client/node_modules/lucide-react/src/icons/log-out.ts","../../../../../client/node_modules/lucide-react/src/icons/command.ts","../../../../../client/node_modules/lucide-react/src/icons/message-square.ts"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    assign: null,\n    searchParamsToUrlQuery: null,\n    urlQueryToSearchParams: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    assign: function() {\n        return assign;\n    },\n    searchParamsToUrlQuery: function() {\n        return searchParamsToUrlQuery;\n    },\n    urlQueryToSearchParams: function() {\n        return urlQueryToSearchParams;\n    }\n});\nfunction searchParamsToUrlQuery(searchParams) {\n    const query = {};\n    for (const [key, value] of searchParams.entries()){\n        const existing = query[key];\n        if (typeof existing === 'undefined') {\n            query[key] = value;\n        } else if (Array.isArray(existing)) {\n            existing.push(value);\n        } else {\n            query[key] = [\n                existing,\n                value\n            ];\n        }\n    }\n    return query;\n}\nfunction stringifyUrlQueryParam(param) {\n    if (typeof param === 'string') {\n        return param;\n    }\n    if (typeof param === 'number' && !isNaN(param) || typeof param === 'boolean') {\n        return String(param);\n    } else {\n        return '';\n    }\n}\nfunction urlQueryToSearchParams(query) {\n    const searchParams = new URLSearchParams();\n    for (const [key, value] of Object.entries(query)){\n        if (Array.isArray(value)) {\n            for (const item of value){\n                searchParams.append(key, stringifyUrlQueryParam(item));\n            }\n        } else {\n            searchParams.set(key, stringifyUrlQueryParam(value));\n        }\n    }\n    return searchParams;\n}\nfunction assign(target, ...searchParamsList) {\n    for (const searchParams of searchParamsList){\n        for (const key of searchParams.keys()){\n            target.delete(key);\n        }\n        for (const [key, value] of searchParams.entries()){\n            target.append(key, value);\n        }\n    }\n    return target;\n}\n\n//# sourceMappingURL=querystring.js.map","// Format function modified from nodejs\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    formatUrl: null,\n    formatWithValidation: null,\n    urlObjectKeys: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    formatUrl: function() {\n        return formatUrl;\n    },\n    formatWithValidation: function() {\n        return formatWithValidation;\n    },\n    urlObjectKeys: function() {\n        return urlObjectKeys;\n    }\n});\nconst _interop_require_wildcard = require(\"@swc/helpers/_/_interop_require_wildcard\");\nconst _querystring = /*#__PURE__*/ _interop_require_wildcard._(require(\"./querystring\"));\nconst slashedProtocols = /https?|ftp|gopher|file/;\nfunction formatUrl(urlObj) {\n    let { auth, hostname } = urlObj;\n    let protocol = urlObj.protocol || '';\n    let pathname = urlObj.pathname || '';\n    let hash = urlObj.hash || '';\n    let query = urlObj.query || '';\n    let host = false;\n    auth = auth ? encodeURIComponent(auth).replace(/%3A/i, ':') + '@' : '';\n    if (urlObj.host) {\n        host = auth + urlObj.host;\n    } else if (hostname) {\n        host = auth + (~hostname.indexOf(':') ? `[${hostname}]` : hostname);\n        if (urlObj.port) {\n            host += ':' + urlObj.port;\n        }\n    }\n    if (query && typeof query === 'object') {\n        query = String(_querystring.urlQueryToSearchParams(query));\n    }\n    let search = urlObj.search || query && `?${query}` || '';\n    if (protocol && !protocol.endsWith(':')) protocol += ':';\n    if (urlObj.slashes || (!protocol || slashedProtocols.test(protocol)) && host !== false) {\n        host = '//' + (host || '');\n        if (pathname && pathname[0] !== '/') pathname = '/' + pathname;\n    } else if (!host) {\n        host = '';\n    }\n    if (hash && hash[0] !== '#') hash = '#' + hash;\n    if (search && search[0] !== '?') search = '?' + search;\n    pathname = pathname.replace(/[?#]/g, encodeURIComponent);\n    search = search.replace('#', '%23');\n    return `${protocol}${host}${pathname}${search}${hash}`;\n}\nconst urlObjectKeys = [\n    'auth',\n    'hash',\n    'host',\n    'hostname',\n    'href',\n    'path',\n    'pathname',\n    'port',\n    'protocol',\n    'query',\n    'search',\n    'slashes'\n];\nfunction formatWithValidation(url) {\n    if (process.env.NODE_ENV === 'development') {\n        if (url !== null && typeof url === 'object') {\n            Object.keys(url).forEach((key)=>{\n                if (!urlObjectKeys.includes(key)) {\n                    console.warn(`Unknown key passed via urlObject into url.format: ${key}`);\n                }\n            });\n        }\n    }\n    return formatUrl(url);\n}\n\n//# sourceMappingURL=format-url.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    DecodeError: null,\n    MiddlewareNotFoundError: null,\n    MissingStaticPage: null,\n    NormalizeError: null,\n    PageNotFoundError: null,\n    SP: null,\n    ST: null,\n    WEB_VITALS: null,\n    execOnce: null,\n    getDisplayName: null,\n    getLocationOrigin: null,\n    getURL: null,\n    isAbsoluteUrl: null,\n    isResSent: null,\n    loadGetInitialProps: null,\n    normalizeRepeatedSlashes: null,\n    stringifyError: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    DecodeError: function() {\n        return DecodeError;\n    },\n    MiddlewareNotFoundError: function() {\n        return MiddlewareNotFoundError;\n    },\n    MissingStaticPage: function() {\n        return MissingStaticPage;\n    },\n    NormalizeError: function() {\n        return NormalizeError;\n    },\n    PageNotFoundError: function() {\n        return PageNotFoundError;\n    },\n    SP: function() {\n        return SP;\n    },\n    ST: function() {\n        return ST;\n    },\n    WEB_VITALS: function() {\n        return WEB_VITALS;\n    },\n    execOnce: function() {\n        return execOnce;\n    },\n    getDisplayName: function() {\n        return getDisplayName;\n    },\n    getLocationOrigin: function() {\n        return getLocationOrigin;\n    },\n    getURL: function() {\n        return getURL;\n    },\n    isAbsoluteUrl: function() {\n        return isAbsoluteUrl;\n    },\n    isResSent: function() {\n        return isResSent;\n    },\n    loadGetInitialProps: function() {\n        return loadGetInitialProps;\n    },\n    normalizeRepeatedSlashes: function() {\n        return normalizeRepeatedSlashes;\n    },\n    stringifyError: function() {\n        return stringifyError;\n    }\n});\nconst WEB_VITALS = [\n    'CLS',\n    'FCP',\n    'FID',\n    'INP',\n    'LCP',\n    'TTFB'\n];\nfunction execOnce(fn) {\n    let used = false;\n    let result;\n    return (...args)=>{\n        if (!used) {\n            used = true;\n            result = fn(...args);\n        }\n        return result;\n    };\n}\n// Scheme: https://tools.ietf.org/html/rfc3986#section-3.1\n// Absolute URL: https://tools.ietf.org/html/rfc3986#section-4.3\nconst ABSOLUTE_URL_REGEX = /^[a-zA-Z][a-zA-Z\\d+\\-.]*?:/;\nconst isAbsoluteUrl = (url)=>ABSOLUTE_URL_REGEX.test(url);\nfunction getLocationOrigin() {\n    const { protocol, hostname, port } = window.location;\n    return `${protocol}//${hostname}${port ? ':' + port : ''}`;\n}\nfunction getURL() {\n    const { href } = window.location;\n    const origin = getLocationOrigin();\n    return href.substring(origin.length);\n}\nfunction getDisplayName(Component) {\n    return typeof Component === 'string' ? Component : Component.displayName || Component.name || 'Unknown';\n}\nfunction isResSent(res) {\n    return res.finished || res.headersSent;\n}\nfunction normalizeRepeatedSlashes(url) {\n    const urlParts = url.split('?');\n    const urlNoQuery = urlParts[0];\n    return urlNoQuery// first we replace any non-encoded backslashes with forward\n    // then normalize repeated forward slashes\n    .replace(/\\\\/g, '/').replace(/\\/\\/+/g, '/') + (urlParts[1] ? `?${urlParts.slice(1).join('?')}` : '');\n}\nasync function loadGetInitialProps(App, ctx) {\n    if (process.env.NODE_ENV !== 'production') {\n        if (App.prototype?.getInitialProps) {\n            const message = `\"${getDisplayName(App)}.getInitialProps()\" is defined as an instance method - visit https://nextjs.org/docs/messages/get-initial-props-as-an-instance-method for more information.`;\n            throw Object.defineProperty(new Error(message), \"__NEXT_ERROR_CODE\", {\n                value: \"E394\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n    }\n    // when called from _app `ctx` is nested in `ctx`\n    const res = ctx.res || ctx.ctx && ctx.ctx.res;\n    if (!App.getInitialProps) {\n        if (ctx.ctx && ctx.Component) {\n            // @ts-ignore pageProps default\n            return {\n                pageProps: await loadGetInitialProps(ctx.Component, ctx.ctx)\n            };\n        }\n        return {};\n    }\n    const props = await App.getInitialProps(ctx);\n    if (res && isResSent(res)) {\n        return props;\n    }\n    if (!props) {\n        const message = `\"${getDisplayName(App)}.getInitialProps()\" should resolve to an object. But found \"${props}\" instead.`;\n        throw Object.defineProperty(new Error(message), \"__NEXT_ERROR_CODE\", {\n            value: \"E394\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    if (process.env.NODE_ENV !== 'production') {\n        if (Object.keys(props).length === 0 && !ctx.ctx) {\n            console.warn(`${getDisplayName(App)} returned an empty object from \\`getInitialProps\\`. This de-optimizes and prevents automatic static optimization. https://nextjs.org/docs/messages/empty-object-getInitialProps`);\n        }\n    }\n    return props;\n}\nconst SP = typeof performance !== 'undefined';\nconst ST = SP && [\n    'mark',\n    'measure',\n    'getEntriesByName'\n].every((method)=>typeof performance[method] === 'function');\nclass DecodeError extends Error {\n}\nclass NormalizeError extends Error {\n}\nclass PageNotFoundError extends Error {\n    constructor(page){\n        super();\n        this.code = 'ENOENT';\n        this.name = 'PageNotFoundError';\n        this.message = `Cannot find module for page: ${page}`;\n    }\n}\nclass MissingStaticPage extends Error {\n    constructor(page, message){\n        super();\n        this.message = `Failed to load static file for page: ${page} ${message}`;\n    }\n}\nclass MiddlewareNotFoundError extends Error {\n    constructor(){\n        super();\n        this.code = 'ENOENT';\n        this.message = `Cannot find the middleware module`;\n    }\n}\nfunction stringifyError(error) {\n    return JSON.stringify({\n        message: error.message,\n        stack: error.stack\n    });\n}\n\n//# sourceMappingURL=utils.js.map","/**\n * Given a path this function will find the pathname, query and hash and return\n * them. This is useful to parse full paths on the client side.\n * @param path A path to parse e.g. /foo/bar?id=1#hash\n */ \"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"parsePath\", {\n    enumerable: true,\n    get: function() {\n        return parsePath;\n    }\n});\nfunction parsePath(path) {\n    const hashIndex = path.indexOf('#');\n    const queryIndex = path.indexOf('?');\n    const hasQuery = queryIndex > -1 && (hashIndex < 0 || queryIndex < hashIndex);\n    if (hasQuery || hashIndex > -1) {\n        return {\n            pathname: path.substring(0, hasQuery ? queryIndex : hashIndex),\n            query: hasQuery ? path.substring(queryIndex, hashIndex > -1 ? hashIndex : undefined) : '',\n            hash: hashIndex > -1 ? path.slice(hashIndex) : ''\n        };\n    }\n    return {\n        pathname: path,\n        query: '',\n        hash: ''\n    };\n}\n\n//# sourceMappingURL=parse-path.js.map","import { parsePath } from './parse-path'\n\n/**\n * Adds the provided prefix to the given path. It first ensures that the path\n * is indeed starting with a slash.\n */\nexport function addPathPrefix(path: string, prefix?: string) {\n  if (!path.startsWith('/') || !prefix) {\n    return path\n  }\n\n  const { pathname, query, hash } = parsePath(path)\n  return `${prefix}${pathname}${query}${hash}`\n}\n","/**\n * Removes the trailing slash for a given route or page path. Preserves the\n * root page. Examples:\n *   - `/foo/bar/` -> `/foo/bar`\n *   - `/foo/bar` -> `/foo/bar`\n *   - `/` -> `/`\n */ \"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"removeTrailingSlash\", {\n    enumerable: true,\n    get: function() {\n        return removeTrailingSlash;\n    }\n});\nfunction removeTrailingSlash(route) {\n    return route.replace(/\\/$/, '') || '/';\n}\n\n//# sourceMappingURL=remove-trailing-slash.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"normalizePathTrailingSlash\", {\n    enumerable: true,\n    get: function() {\n        return normalizePathTrailingSlash;\n    }\n});\nconst _removetrailingslash = require(\"../shared/lib/router/utils/remove-trailing-slash\");\nconst _parsepath = require(\"../shared/lib/router/utils/parse-path\");\nconst normalizePathTrailingSlash = (path)=>{\n    if (!path.startsWith('/') || process.env.__NEXT_MANUAL_TRAILING_SLASH) {\n        return path;\n    }\n    const { pathname, query, hash } = (0, _parsepath.parsePath)(path);\n    if (process.env.__NEXT_TRAILING_SLASH) {\n        if (/\\.[^/]+\\/?$/.test(pathname)) {\n            return `${(0, _removetrailingslash.removeTrailingSlash)(pathname)}${query}${hash}`;\n        } else if (pathname.endsWith('/')) {\n            return `${pathname}${query}${hash}`;\n        } else {\n            return `${pathname}/${query}${hash}`;\n        }\n    }\n    return `${(0, _removetrailingslash.removeTrailingSlash)(pathname)}${query}${hash}`;\n};\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=normalize-trailing-slash.js.map","import { addPathPrefix } from '../shared/lib/router/utils/add-path-prefix'\nimport { normalizePathTrailingSlash } from './normalize-trailing-slash'\n\nconst basePath = (process.env.__NEXT_ROUTER_BASEPATH as string) || ''\n\nexport function addBasePath(path: string, required?: boolean): string {\n  return normalizePathTrailingSlash(\n    process.env.__NEXT_MANUAL_CLIENT_BASE_PATH && !required\n      ? path\n      : addPathPrefix(path, basePath)\n  )\n}\n","/**\n * Shared types and constants for the Segment Cache.\n */ \"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    FetchStrategy: null,\n    NavigationResultTag: null,\n    PrefetchPriority: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    FetchStrategy: function() {\n        return FetchStrategy;\n    },\n    NavigationResultTag: function() {\n        return NavigationResultTag;\n    },\n    PrefetchPriority: function() {\n        return PrefetchPriority;\n    }\n});\nvar NavigationResultTag = /*#__PURE__*/ function(NavigationResultTag) {\n    NavigationResultTag[NavigationResultTag[\"MPA\"] = 0] = \"MPA\";\n    NavigationResultTag[NavigationResultTag[\"Success\"] = 1] = \"Success\";\n    NavigationResultTag[NavigationResultTag[\"NoOp\"] = 2] = \"NoOp\";\n    NavigationResultTag[NavigationResultTag[\"Async\"] = 3] = \"Async\";\n    return NavigationResultTag;\n}({});\nvar PrefetchPriority = /*#__PURE__*/ function(PrefetchPriority) {\n    /**\n   * Assigned to the most recently hovered/touched link. Special network\n   * bandwidth is reserved for this task only. There's only ever one Intent-\n   * priority task at a time; when a new Intent task is scheduled, the previous\n   * one is bumped down to Default.\n   */ PrefetchPriority[PrefetchPriority[\"Intent\"] = 2] = \"Intent\";\n    /**\n   * The default priority for prefetch tasks.\n   */ PrefetchPriority[PrefetchPriority[\"Default\"] = 1] = \"Default\";\n    /**\n   * Assigned to tasks when they spawn non-blocking background work, like\n   * revalidating a partially cached entry to see if more data is available.\n   */ PrefetchPriority[PrefetchPriority[\"Background\"] = 0] = \"Background\";\n    return PrefetchPriority;\n}({});\nvar FetchStrategy = /*#__PURE__*/ function(FetchStrategy) {\n    // Deliberately ordered so we can easily compare two segments\n    // and determine if one segment is \"more specific\" than another\n    // (i.e. if it's likely that it contains more data)\n    FetchStrategy[FetchStrategy[\"LoadingBoundary\"] = 0] = \"LoadingBoundary\";\n    FetchStrategy[FetchStrategy[\"PPR\"] = 1] = \"PPR\";\n    FetchStrategy[FetchStrategy[\"PPRRuntime\"] = 2] = \"PPRRuntime\";\n    FetchStrategy[FetchStrategy[\"Full\"] = 3] = \"Full\";\n    return FetchStrategy;\n}({});\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=types.js.map","// TypeScript trick to simulate opaque types, like in Flow.\ntype Opaque<K, T> = T & { __brand: K }\n\n// Only functions in this module should be allowed to create CacheKeys.\nexport type NormalizedPathname = Opaque<'NormalizedPathname', string>\nexport type NormalizedSearch = Opaque<'NormalizedSearch', string>\nexport type NormalizedNextUrl = Opaque<'NormalizedNextUrl', string>\n\nexport type RouteCacheKey = Opaque<\n  'RouteCacheKey',\n  {\n    pathname: NormalizedPathname\n    search: NormalizedSearch\n    nextUrl: NormalizedNextUrl | null\n\n    // TODO: Eventually the dynamic params will be added here, too.\n  }\n>\n\nexport function createCacheKey(\n  originalHref: string,\n  nextUrl: string | null\n): RouteCacheKey {\n  const originalUrl = new URL(originalHref)\n  const cacheKey = {\n    pathname: originalUrl.pathname as NormalizedPathname,\n    search: originalUrl.search as NormalizedSearch,\n    nextUrl: nextUrl as NormalizedNextUrl | null,\n  } as RouteCacheKey\n  return cacheKey\n}\n","/**\n * App Router types - Client-safe types for the Next.js App Router\n *\n * This file contains type definitions that can be safely imported\n * by both client-side and server-side code without circular dependencies.\n */\n\nimport type React from 'react'\n\nexport type LoadingModuleData =\n  | [React.JSX.Element, React.ReactNode, React.ReactNode]\n  | null\n\n/** viewport metadata node */\nexport type HeadData = React.ReactNode\n\nexport type ChildSegmentMap = Map<string, CacheNode>\n\n/**\n * Cache node used in app-router / layout-router.\n */\n\nexport type CacheNode = {\n  /**\n   * When rsc is not null, it represents the RSC data for the\n   * corresponding segment.\n   *\n   * `null` is a valid React Node but because segment data is always a\n   * <LayoutRouter> component, we can use `null` to represent empty. When it is\n   * null, it represents missing data, and rendering should suspend.\n   */\n  rsc: React.ReactNode\n\n  /**\n   * Represents a static version of the segment that can be shown immediately,\n   * and may or may not contain dynamic holes. It's prefetched before a\n   * navigation occurs.\n   *\n   * During rendering, we will choose whether to render `rsc` or `prefetchRsc`\n   * with `useDeferredValue`. As with the `rsc` field, a value of `null` means\n   * no value was provided. In this case, the LayoutRouter will go straight to\n   * rendering the `rsc` value; if that one is also missing, it will suspend and\n   * trigger a lazy fetch.\n   */\n  prefetchRsc: React.ReactNode\n\n  prefetchHead: HeadData | null\n\n  head: HeadData\n\n  loading: LoadingModuleData | Promise<LoadingModuleData>\n\n  parallelRoutes: Map<string, ChildSegmentMap>\n\n  /**\n   * The timestamp of the navigation that last updated the CacheNode's data. If\n   * a CacheNode is reused from a previous navigation, this value is not\n   * updated. Used to track the staleness of the data.\n   */\n  navigatedAt: number\n}\n\nexport type DynamicParamTypes =\n  | 'catchall'\n  | 'catchall-intercepted-(..)(..)'\n  | 'catchall-intercepted-(.)'\n  | 'catchall-intercepted-(..)'\n  | 'catchall-intercepted-(...)'\n  | 'optional-catchall'\n  | 'dynamic'\n  | 'dynamic-intercepted-(..)(..)'\n  | 'dynamic-intercepted-(.)'\n  | 'dynamic-intercepted-(..)'\n  | 'dynamic-intercepted-(...)'\n\nexport type DynamicParamTypesShort =\n  | 'c'\n  | 'ci(..)(..)'\n  | 'ci(.)'\n  | 'ci(..)'\n  | 'ci(...)'\n  | 'oc'\n  | 'd'\n  | 'di(..)(..)'\n  | 'di(.)'\n  | 'di(..)'\n  | 'di(...)'\n\nexport type Segment =\n  | string\n  | [\n      // Param name\n      paramName: string,\n      // Param cache key (almost the same as the value, but arrays are\n      // concatenated into strings)\n      // TODO: We should change this to just be the value. Currently we convert\n      // it back to a value when passing to useParams. It only needs to be\n      // a string when converted to a a cache key, but that doesn't mean we\n      // need to store it as that representation.\n      paramCacheKey: string,\n      // Dynamic param type\n      dynamicParamType: DynamicParamTypesShort,\n    ]\n\n/**\n * Router state\n */\nexport type FlightRouterState = [\n  segment: Segment,\n  parallelRoutes: { [parallelRouterKey: string]: FlightRouterState },\n  url?: string | null,\n  /**\n   * \"refresh\" and \"refetch\", despite being similarly named, have different\n   * semantics:\n   * - \"refetch\" is used during a request to inform the server where rendering\n   *   should start from.\n   *\n   * - \"refresh\" is used by the client to mark that a segment should re-fetch the\n   *   data from the server for the current segment. It uses the \"url\" property\n   *   above to determine where to fetch from.\n   *\n   * - \"inside-shared-layout\" is used during a prefetch request to inform the\n   *   server that even if the segment matches, it should be treated as if it's\n   *   within the \"new\" part of a navigation — inside the shared layout. If\n   *   the segment doesn't match, then it has no effect, since it would be\n   *   treated as new regardless. If it does match, though, the server does not\n   *   need to render it, because the client already has it.\n   *\n   * - \"metadata-only\" instructs the server to skip rendering the segments and\n   *   only send the head data.\n   *\n   *   A bit confusing, but that's because it has only one extremely narrow use\n   *   case — during a non-PPR prefetch, the server uses it to find the first\n   *   loading boundary beneath a shared layout.\n   *\n   *   TODO: We should rethink the protocol for dynamic requests. It might not\n   *   make sense for the client to send a FlightRouterState, since this type is\n   *   overloaded with concerns.\n   */\n  refresh?:\n    | 'refetch'\n    | 'refresh'\n    | 'inside-shared-layout'\n    | 'metadata-only'\n    | null,\n  isRootLayout?: boolean,\n  /**\n   * Only present when responding to a tree prefetch request. Indicates whether\n   * there is a loading boundary somewhere in the tree. The client cache uses\n   * this to determine if it can skip the data prefetch request.\n   */\n  hasLoadingBoundary?: HasLoadingBoundary,\n]\n\nexport const enum HasLoadingBoundary {\n  // There is a loading boundary in this particular segment\n  SegmentHasLoadingBoundary = 1,\n  // There is a loading boundary somewhere in the subtree (but not in\n  // this segment)\n  SubtreeHasLoadingBoundary = 2,\n  // There is no loading boundary in this segment or any of its descendants\n  SubtreeHasNoLoadingBoundary = 3,\n}\n\n/**\n * Individual Flight response path\n */\nexport type FlightSegmentPath =\n  // Uses `any` as repeating pattern can't be typed.\n  | any[]\n  // Looks somewhat like this\n  | [\n      segment: Segment,\n      parallelRouterKey: string,\n      segment: Segment,\n      parallelRouterKey: string,\n      segment: Segment,\n      parallelRouterKey: string,\n    ]\n\n/**\n * Represents a tree of segments and the Flight data (i.e. React nodes) that\n * correspond to each one. The tree is isomorphic to the FlightRouterState;\n * however in the future we want to be able to fetch arbitrary partial segments\n * without having to fetch all its children. So this response format will\n * likely change.\n */\nexport type CacheNodeSeedData = [\n  node: React.ReactNode | null,\n  parallelRoutes: {\n    [parallelRouterKey: string]: CacheNodeSeedData | null\n  },\n  loading: LoadingModuleData | Promise<LoadingModuleData>,\n  isPartial: boolean,\n  /** TODO: this doesn't feel like it belongs here, because it's only used during build, in `collectSegmentData` */\n  hasRuntimePrefetch: boolean,\n]\n\nexport type FlightDataSegment = [\n  /* segment of the rendered slice: */ Segment,\n  /* treePatch */ FlightRouterState,\n  /* cacheNodeSeedData */ CacheNodeSeedData | null, // Can be null during prefetch if there's no loading component\n  /* head: viewport */ HeadData,\n  /* isHeadPartial */ boolean,\n]\n\nexport type FlightDataPath =\n  // Uses `any` as repeating pattern can't be typed.\n  | any[]\n  // Looks somewhat like this\n  | [\n      // Holds full path to the segment.\n      ...FlightSegmentPath[],\n      ...FlightDataSegment,\n    ]\n\n/**\n * The Flight response data\n */\nexport type FlightData = Array<FlightDataPath> | string\n\nexport type ActionResult = Promise<any>\n\nexport type InitialRSCPayload = {\n  /** buildId */\n  b: string\n  /** initialCanonicalUrlParts */\n  c: string[]\n  /** initialRenderedSearch */\n  q: string\n  /** couldBeIntercepted */\n  i: boolean\n  /** initialFlightData */\n  f: FlightDataPath[]\n  /** missingSlots */\n  m: Set<string> | undefined\n  /** GlobalError */\n  G: [React.ComponentType<any>, React.ReactNode | undefined]\n  /** prerendered */\n  S: boolean\n}\n\n// Response from `createFromFetch` for normal rendering\nexport type NavigationFlightResponse = {\n  /** buildId */\n  b: string\n  /** flightData */\n  f: FlightData\n  /** prerendered */\n  S: boolean\n  /** renderedSearch */\n  q: string\n  /** couldBeIntercepted */\n  i: boolean\n  /** runtimePrefetch - [isPartial, staleTime]. Only present in runtime prefetch responses. */\n  rp?: [boolean, number]\n}\n\n// Response from `createFromFetch` for server actions. Action's flight data can be null\nexport type ActionFlightResponse = {\n  /** actionResult */\n  a: ActionResult\n  /** buildId */\n  b: string\n  /** flightData */\n  f: FlightData\n  /** renderedSearch */\n  q: string\n  /** couldBeIntercepted */\n  i: boolean\n}\n\nexport type RSCPayload =\n  | InitialRSCPayload\n  | NavigationFlightResponse\n  | ActionFlightResponse\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"matchSegment\", {\n    enumerable: true,\n    get: function() {\n        return matchSegment;\n    }\n});\nconst matchSegment = (existingSegment, segment)=>{\n    // segment is either Array or string\n    if (typeof existingSegment === 'string') {\n        if (typeof segment === 'string') {\n            // Common case: segment is just a string\n            return existingSegment === segment;\n        }\n        return false;\n    }\n    if (typeof segment === 'string') {\n        return false;\n    }\n    return existingSegment[0] === segment[0] && existingSegment[1] === segment[1];\n};\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=match-segments.js.map","export const RSC_HEADER = 'rsc' as const\nexport const ACTION_HEADER = 'next-action' as const\n// TODO: Instead of sending the full router state, we only need to send the\n// segment path. Saves bytes. Then we could also use this field for segment\n// prefetches, which also need to specify a particular segment.\nexport const NEXT_ROUTER_STATE_TREE_HEADER = 'next-router-state-tree' as const\nexport const NEXT_ROUTER_PREFETCH_HEADER = 'next-router-prefetch' as const\n// This contains the path to the segment being prefetched.\n// TODO: If we change next-router-state-tree to be a segment path, we can use\n// that instead. Then next-router-prefetch and next-router-segment-prefetch can\n// be merged into a single enum.\nexport const NEXT_ROUTER_SEGMENT_PREFETCH_HEADER =\n  'next-router-segment-prefetch' as const\nexport const NEXT_HMR_REFRESH_HEADER = 'next-hmr-refresh' as const\nexport const NEXT_HMR_REFRESH_HASH_COOKIE = '__next_hmr_refresh_hash__' as const\nexport const NEXT_URL = 'next-url' as const\nexport const RSC_CONTENT_TYPE_HEADER = 'text/x-component' as const\n\nexport const FLIGHT_HEADERS = [\n  RSC_HEADER,\n  NEXT_ROUTER_STATE_TREE_HEADER,\n  NEXT_ROUTER_PREFETCH_HEADER,\n  NEXT_HMR_REFRESH_HEADER,\n  NEXT_ROUTER_SEGMENT_PREFETCH_HEADER,\n] as const\n\nexport const NEXT_RSC_UNION_QUERY = '_rsc' as const\n\nexport const NEXT_ROUTER_STALE_TIME_HEADER = 'x-nextjs-stale-time' as const\nexport const NEXT_DID_POSTPONE_HEADER = 'x-nextjs-postponed' as const\nexport const NEXT_REWRITTEN_PATH_HEADER = 'x-nextjs-rewritten-path' as const\nexport const NEXT_REWRITTEN_QUERY_HEADER = 'x-nextjs-rewritten-query' as const\nexport const NEXT_IS_PRERENDER_HEADER = 'x-nextjs-prerender' as const\nexport const NEXT_ACTION_NOT_FOUND_HEADER = 'x-nextjs-action-not-found' as const\nexport const NEXT_REQUEST_ID_HEADER = 'x-nextjs-request-id' as const\nexport const NEXT_HTML_REQUEST_ID_HEADER = 'x-nextjs-html-request-id' as const\n\n// TODO: Should this include nextjs in the name, like the others?\nexport const NEXT_ACTION_REVALIDATED_HEADER = 'x-action-revalidated' as const\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    ACTION_HMR_REFRESH: null,\n    ACTION_NAVIGATE: null,\n    ACTION_REFRESH: null,\n    ACTION_RESTORE: null,\n    ACTION_SERVER_ACTION: null,\n    ACTION_SERVER_PATCH: null,\n    PrefetchKind: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    ACTION_HMR_REFRESH: function() {\n        return ACTION_HMR_REFRESH;\n    },\n    ACTION_NAVIGATE: function() {\n        return ACTION_NAVIGATE;\n    },\n    ACTION_REFRESH: function() {\n        return ACTION_REFRESH;\n    },\n    ACTION_RESTORE: function() {\n        return ACTION_RESTORE;\n    },\n    ACTION_SERVER_ACTION: function() {\n        return ACTION_SERVER_ACTION;\n    },\n    ACTION_SERVER_PATCH: function() {\n        return ACTION_SERVER_PATCH;\n    },\n    PrefetchKind: function() {\n        return PrefetchKind;\n    }\n});\nconst ACTION_REFRESH = 'refresh';\nconst ACTION_NAVIGATE = 'navigate';\nconst ACTION_RESTORE = 'restore';\nconst ACTION_SERVER_PATCH = 'server-patch';\nconst ACTION_HMR_REFRESH = 'hmr-refresh';\nconst ACTION_SERVER_ACTION = 'server-action';\nvar PrefetchKind = /*#__PURE__*/ function(PrefetchKind) {\n    PrefetchKind[\"AUTO\"] = \"auto\";\n    PrefetchKind[\"FULL\"] = \"full\";\n    return PrefetchKind;\n}({});\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=router-reducer-types.js.map","/**\n * Check to see if a value is Thenable.\n *\n * @param promise the maybe-thenable value\n * @returns true if the value is thenable\n */ \"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"isThenable\", {\n    enumerable: true,\n    get: function() {\n        return isThenable;\n    }\n});\nfunction isThenable(promise) {\n    return promise !== null && typeof promise === 'object' && 'then' in promise && typeof promise.then === 'function';\n}\n\n//# sourceMappingURL=is-thenable.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    dispatchAppRouterAction: null,\n    useActionQueue: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    dispatchAppRouterAction: function() {\n        return dispatchAppRouterAction;\n    },\n    useActionQueue: function() {\n        return useActionQueue;\n    }\n});\nconst _interop_require_wildcard = require(\"@swc/helpers/_/_interop_require_wildcard\");\nconst _react = /*#__PURE__*/ _interop_require_wildcard._(require(\"react\"));\nconst _isthenable = require(\"../../shared/lib/is-thenable\");\n// The app router state lives outside of React, so we can import the dispatch\n// method directly wherever we need it, rather than passing it around via props\n// or context.\nlet dispatch = null;\nfunction dispatchAppRouterAction(action) {\n    if (dispatch === null) {\n        throw Object.defineProperty(new Error('Internal Next.js error: Router action dispatched before initialization.'), \"__NEXT_ERROR_CODE\", {\n            value: \"E668\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    dispatch(action);\n}\nconst __DEV__ = process.env.NODE_ENV !== 'production';\nconst promisesWithDebugInfo = __DEV__ ? new WeakMap() : null;\nfunction useActionQueue(actionQueue) {\n    const [state, setState] = _react.default.useState(actionQueue.state);\n    // Because of a known issue that requires to decode Flight streams inside the\n    // render phase, we have to be a bit clever and assign the dispatch method to\n    // a module-level variable upon initialization. The useState hook in this\n    // module only exists to synchronize state that lives outside of React.\n    // Ideally, what we'd do instead is pass the state as a prop to root.render;\n    // this is conceptually how we're modeling the app router state, despite the\n    // weird implementation details.\n    if (process.env.NODE_ENV !== 'production') {\n        const { useAppDevRenderingIndicator } = require('../../next-devtools/userspace/use-app-dev-rendering-indicator');\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        const appDevRenderingIndicator = useAppDevRenderingIndicator();\n        dispatch = (action)=>{\n            appDevRenderingIndicator(()=>{\n                actionQueue.dispatch(action, setState);\n            });\n        };\n    } else {\n        dispatch = (action)=>actionQueue.dispatch(action, setState);\n    }\n    // When navigating to a non-prefetched route, then App Router state will be\n    // blocked until the server responds. We need to transfer the `_debugInfo`\n    // from the underlying Flight response onto the top-level promise that is\n    // passed to React (via `use`) so that the latency is accurately represented\n    // in the React DevTools.\n    const stateWithDebugInfo = (0, _react.useMemo)(()=>{\n        if (!__DEV__) {\n            return state;\n        }\n        if ((0, _isthenable.isThenable)(state)) {\n            // useMemo can't be used to cache a Promise since the memoized value is thrown\n            // away when we suspend. So we use a WeakMap to cache the Promise with debug info.\n            let promiseWithDebugInfo = promisesWithDebugInfo.get(state);\n            if (promiseWithDebugInfo === undefined) {\n                const debugInfo = [];\n                promiseWithDebugInfo = Promise.resolve(state).then((asyncState)=>{\n                    if (asyncState.debugInfo !== null) {\n                        debugInfo.push(...asyncState.debugInfo);\n                    }\n                    return asyncState;\n                });\n                promiseWithDebugInfo._debugInfo = debugInfo;\n                promisesWithDebugInfo.set(state, promiseWithDebugInfo);\n            }\n            return promiseWithDebugInfo;\n        }\n        return state;\n    }, [\n        state\n    ]);\n    return (0, _isthenable.isThenable)(stateWithDebugInfo) ? (0, _react.use)(stateWithDebugInfo) : stateWithDebugInfo;\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=use-action-queue.js.map","import { startTransition } from 'react'\nimport { ACTION_SERVER_ACTION } from './components/router-reducer/router-reducer-types'\nimport { dispatchAppRouterAction } from './components/use-action-queue'\n\nexport async function callServer(actionId: string, actionArgs: any[]) {\n  return new Promise((resolve, reject) => {\n    startTransition(() => {\n      dispatchAppRouterAction({\n        type: ACTION_SERVER_ACTION,\n        actionId,\n        actionArgs,\n        resolve,\n        reject,\n      })\n    })\n  })\n}\n","const basePath = process.env.__NEXT_ROUTER_BASEPATH || ''\nconst pathname = `${basePath}/__nextjs_source-map`\n\nexport const findSourceMapURL =\n  process.env.NODE_ENV === 'development'\n    ? function findSourceMapURL(filename: string): string | null {\n        if (filename === '') {\n          return null\n        }\n\n        if (\n          filename.startsWith(document.location.origin) &&\n          filename.includes('/_next/static')\n        ) {\n          // This is a request for a client chunk. This can only happen when\n          // using Turbopack. In this case, since we control how those source\n          // maps are generated, we can safely assume that the sourceMappingURL\n          // is relative to the filename, with an added `.map` extension. The\n          // browser can just request this file, and it gets served through the\n          // normal dev server, without the need to route this through\n          // the `/__nextjs_source-map` dev middleware.\n          return `${filename}.map`\n        }\n\n        const url = new URL(pathname, document.location.origin)\n        url.searchParams.set('filename', filename)\n\n        return url.href\n      }\n    : undefined\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    HEAD_REQUEST_KEY: null,\n    ROOT_SEGMENT_REQUEST_KEY: null,\n    appendSegmentRequestKeyPart: null,\n    convertSegmentPathToStaticExportFilename: null,\n    createSegmentRequestKeyPart: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    HEAD_REQUEST_KEY: function() {\n        return HEAD_REQUEST_KEY;\n    },\n    ROOT_SEGMENT_REQUEST_KEY: function() {\n        return ROOT_SEGMENT_REQUEST_KEY;\n    },\n    appendSegmentRequestKeyPart: function() {\n        return appendSegmentRequestKeyPart;\n    },\n    convertSegmentPathToStaticExportFilename: function() {\n        return convertSegmentPathToStaticExportFilename;\n    },\n    createSegmentRequestKeyPart: function() {\n        return createSegmentRequestKeyPart;\n    }\n});\nconst _segment = require(\"../segment\");\nconst ROOT_SEGMENT_REQUEST_KEY = '';\nconst HEAD_REQUEST_KEY = '/_head';\nfunction createSegmentRequestKeyPart(segment) {\n    if (typeof segment === 'string') {\n        if (segment.startsWith(_segment.PAGE_SEGMENT_KEY)) {\n            // The Flight Router State type sometimes includes the search params in\n            // the page segment. However, the Segment Cache tracks this as a separate\n            // key. So, we strip the search params here, and then add them back when\n            // the cache entry is turned back into a FlightRouterState. This is an\n            // unfortunate consequence of the FlightRouteState being used both as a\n            // transport type and as a cache key; we'll address this once more of the\n            // Segment Cache implementation has settled.\n            // TODO: We should hoist the search params out of the FlightRouterState\n            // type entirely, This is our plan for dynamic route params, too.\n            return _segment.PAGE_SEGMENT_KEY;\n        }\n        const safeName = // TODO: FlightRouterState encodes Not Found routes as \"/_not-found\".\n        // But params typically don't include the leading slash. We should use\n        // a different encoding to avoid this special case.\n        segment === '/_not-found' ? '_not-found' : encodeToFilesystemAndURLSafeString(segment);\n        // Since this is not a dynamic segment, it's fully encoded. It does not\n        // need to be \"hydrated\" with a param value.\n        return safeName;\n    }\n    const name = segment[0];\n    const paramType = segment[2];\n    const safeName = encodeToFilesystemAndURLSafeString(name);\n    const encodedName = '$' + paramType + '$' + safeName;\n    return encodedName;\n}\nfunction appendSegmentRequestKeyPart(parentRequestKey, parallelRouteKey, childRequestKeyPart) {\n    // Aside from being filesystem safe, segment keys are also designed so that\n    // each segment and parallel route creates its own subdirectory. Roughly in\n    // the same shape as the source app directory. This is mostly just for easier\n    // debugging (you can open up the build folder and navigate the output); if\n    // we wanted to do we could just use a flat structure.\n    // Omit the parallel route key for children, since this is the most\n    // common case. Saves some bytes (and it's what the app directory does).\n    const slotKey = parallelRouteKey === 'children' ? childRequestKeyPart : `@${encodeToFilesystemAndURLSafeString(parallelRouteKey)}/${childRequestKeyPart}`;\n    return parentRequestKey + '/' + slotKey;\n}\n// Define a regex pattern to match the most common characters found in a route\n// param. It excludes anything that might not be cross-platform filesystem\n// compatible, like |. It does not need to be precise because the fallback is to\n// just base64url-encode the whole parameter, which is fine; we just don't do it\n// by default for compactness, and for easier debugging.\nconst simpleParamValueRegex = /^[a-zA-Z0-9\\-_@]+$/;\nfunction encodeToFilesystemAndURLSafeString(value) {\n    if (simpleParamValueRegex.test(value)) {\n        return value;\n    }\n    // If there are any unsafe characters, base64url-encode the entire value.\n    // We also add a ! prefix so it doesn't collide with the simple case.\n    const base64url = btoa(value).replace(/\\+/g, '-') // Replace '+' with '-'\n    .replace(/\\//g, '_') // Replace '/' with '_'\n    .replace(/=+$/, '') // Remove trailing '='\n    ;\n    return '!' + base64url;\n}\nfunction convertSegmentPathToStaticExportFilename(segmentPath) {\n    return `__next${segmentPath.replace(/\\//g, '.')}.txt`;\n}\n\n//# sourceMappingURL=segment-value-encoding.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    doesStaticSegmentAppearInURL: null,\n    getCacheKeyForDynamicParam: null,\n    getParamValueFromCacheKey: null,\n    getRenderedPathname: null,\n    getRenderedSearch: null,\n    parseDynamicParamFromURLPart: null,\n    urlSearchParamsToParsedUrlQuery: null,\n    urlToUrlWithoutFlightMarker: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    doesStaticSegmentAppearInURL: function() {\n        return doesStaticSegmentAppearInURL;\n    },\n    getCacheKeyForDynamicParam: function() {\n        return getCacheKeyForDynamicParam;\n    },\n    getParamValueFromCacheKey: function() {\n        return getParamValueFromCacheKey;\n    },\n    getRenderedPathname: function() {\n        return getRenderedPathname;\n    },\n    getRenderedSearch: function() {\n        return getRenderedSearch;\n    },\n    parseDynamicParamFromURLPart: function() {\n        return parseDynamicParamFromURLPart;\n    },\n    urlSearchParamsToParsedUrlQuery: function() {\n        return urlSearchParamsToParsedUrlQuery;\n    },\n    urlToUrlWithoutFlightMarker: function() {\n        return urlToUrlWithoutFlightMarker;\n    }\n});\nconst _segment = require(\"../shared/lib/segment\");\nconst _segmentvalueencoding = require(\"../shared/lib/segment-cache/segment-value-encoding\");\nconst _approuterheaders = require(\"./components/app-router-headers\");\nfunction getRenderedSearch(response) {\n    // If the server performed a rewrite, the search params used to render the\n    // page will be different from the params in the request URL. In this case,\n    // the response will include a header that gives the rewritten search query.\n    const rewrittenQuery = response.headers.get(_approuterheaders.NEXT_REWRITTEN_QUERY_HEADER);\n    if (rewrittenQuery !== null) {\n        return rewrittenQuery === '' ? '' : '?' + rewrittenQuery;\n    }\n    // If the header is not present, there was no rewrite, so we use the search\n    // query of the response URL.\n    return urlToUrlWithoutFlightMarker(new URL(response.url)).search;\n}\nfunction getRenderedPathname(response) {\n    // If the server performed a rewrite, the pathname used to render the\n    // page will be different from the pathname in the request URL. In this case,\n    // the response will include a header that gives the rewritten pathname.\n    const rewrittenPath = response.headers.get(_approuterheaders.NEXT_REWRITTEN_PATH_HEADER);\n    return rewrittenPath ?? urlToUrlWithoutFlightMarker(new URL(response.url)).pathname;\n}\nfunction parseDynamicParamFromURLPart(paramType, pathnameParts, partIndex) {\n    // This needs to match the behavior in get-dynamic-param.ts.\n    switch(paramType){\n        // Catchalls\n        case 'c':\n            {\n                // Catchalls receive all the remaining URL parts. If there are no\n                // remaining pathname parts, return an empty array.\n                return partIndex < pathnameParts.length ? pathnameParts.slice(partIndex).map((s)=>encodeURIComponent(s)) : [];\n            }\n        // Catchall intercepted\n        case 'ci(..)(..)':\n        case 'ci(.)':\n        case 'ci(..)':\n        case 'ci(...)':\n            {\n                const prefix = paramType.length - 2;\n                return partIndex < pathnameParts.length ? pathnameParts.slice(partIndex).map((s, i)=>{\n                    if (i === 0) {\n                        return encodeURIComponent(s.slice(prefix));\n                    }\n                    return encodeURIComponent(s);\n                }) : [];\n            }\n        // Optional catchalls\n        case 'oc':\n            {\n                // Optional catchalls receive all the remaining URL parts, unless this is\n                // the end of the pathname, in which case they return null.\n                return partIndex < pathnameParts.length ? pathnameParts.slice(partIndex).map((s)=>encodeURIComponent(s)) : null;\n            }\n        // Dynamic\n        case 'd':\n            {\n                if (partIndex >= pathnameParts.length) {\n                    // The route tree expected there to be more parts in the URL than there\n                    // actually are. This could happen if the x-nextjs-rewritten-path header\n                    // is incorrectly set, or potentially due to bug in Next.js. TODO:\n                    // Should this be a hard error? During a prefetch, we can just abort.\n                    // During a client navigation, we could trigger a hard refresh. But if\n                    // it happens during initial render, we don't really have any\n                    // recovery options.\n                    return '';\n                }\n                return encodeURIComponent(pathnameParts[partIndex]);\n            }\n        // Dynamic intercepted\n        case 'di(..)(..)':\n        case 'di(.)':\n        case 'di(..)':\n        case 'di(...)':\n            {\n                const prefix = paramType.length - 2;\n                if (partIndex >= pathnameParts.length) {\n                    // The route tree expected there to be more parts in the URL than there\n                    // actually are. This could happen if the x-nextjs-rewritten-path header\n                    // is incorrectly set, or potentially due to bug in Next.js. TODO:\n                    // Should this be a hard error? During a prefetch, we can just abort.\n                    // During a client navigation, we could trigger a hard refresh. But if\n                    // it happens during initial render, we don't really have any\n                    // recovery options.\n                    return '';\n                }\n                return encodeURIComponent(pathnameParts[partIndex].slice(prefix));\n            }\n        default:\n            paramType;\n            return '';\n    }\n}\nfunction doesStaticSegmentAppearInURL(segment) {\n    // This is not a parameterized segment; however, we need to determine\n    // whether or not this segment appears in the URL. For example, this route\n    // groups do not appear in the URL, so they should be skipped. Any other\n    // special cases must be handled here.\n    // TODO: Consider encoding this directly into the router tree instead of\n    // inferring it on the client based on the segment type. Something like\n    // a `doesAppearInURL` flag in FlightRouterState.\n    if (segment === _segmentvalueencoding.ROOT_SEGMENT_REQUEST_KEY || // For some reason, the loader tree sometimes includes extra __PAGE__\n    // \"layouts\" when part of a parallel route. But it's not a leaf node.\n    // Otherwise, we wouldn't need this special case because pages are\n    // always leaf nodes.\n    // TODO: Investigate why the loader produces these fake page segments.\n    segment.startsWith(_segment.PAGE_SEGMENT_KEY) || // Route groups.\n    segment[0] === '(' && segment.endsWith(')') || segment === _segment.DEFAULT_SEGMENT_KEY || segment === '/_not-found') {\n        return false;\n    } else {\n        // All other segment types appear in the URL\n        return true;\n    }\n}\nfunction getCacheKeyForDynamicParam(paramValue, renderedSearch) {\n    // This needs to match the logic in get-dynamic-param.ts, until we're able to\n    // unify the various implementations so that these are always computed on\n    // the client.\n    if (typeof paramValue === 'string') {\n        // TODO: Refactor or remove this helper function to accept a string rather\n        // than the whole segment type. Also we can probably just append the\n        // search string instead of turning it into JSON.\n        const pageSegmentWithSearchParams = (0, _segment.addSearchParamsIfPageSegment)(paramValue, Object.fromEntries(new URLSearchParams(renderedSearch)));\n        return pageSegmentWithSearchParams;\n    } else if (paramValue === null) {\n        return '';\n    } else {\n        return paramValue.join('/');\n    }\n}\nfunction urlToUrlWithoutFlightMarker(url) {\n    const urlWithoutFlightParameters = new URL(url);\n    urlWithoutFlightParameters.searchParams.delete(_approuterheaders.NEXT_RSC_UNION_QUERY);\n    if (process.env.NODE_ENV === 'production') {\n        if (process.env.__NEXT_CONFIG_OUTPUT === 'export' && urlWithoutFlightParameters.pathname.endsWith('.txt')) {\n            const { pathname } = urlWithoutFlightParameters;\n            const length = pathname.endsWith('/index.txt') ? 10 : 4;\n            // Slice off `/index.txt` or `.txt` from the end of the pathname\n            urlWithoutFlightParameters.pathname = pathname.slice(0, -length);\n        }\n    }\n    return urlWithoutFlightParameters;\n}\nfunction getParamValueFromCacheKey(paramCacheKey, paramType) {\n    // Turn the cache key string sent by the server (as part of FlightRouterState)\n    // into a value that can be passed to `useParams` and client components.\n    const isCatchAll = paramType === 'c' || paramType === 'oc';\n    if (isCatchAll) {\n        // Catch-all param keys are a concatenation of the path segments.\n        // See equivalent logic in `getSelectedParams`.\n        // TODO: We should just pass the array directly, rather than concatenate\n        // it to a string and then split it back to an array. It needs to be an\n        // array in some places, like when passing a key React, but we can convert\n        // it at runtime in those places.\n        return paramCacheKey.split('/');\n    }\n    return paramCacheKey;\n}\nfunction urlSearchParamsToParsedUrlQuery(searchParams) {\n    // Converts a URLSearchParams object to the same type used by the server when\n    // creating search params props, i.e. the type returned by Node's\n    // \"querystring\" module.\n    const result = {};\n    for (const [key, value] of searchParams.entries()){\n        if (result[key] === undefined) {\n            result[key] = value;\n        } else if (Array.isArray(result[key])) {\n            result[key].push(value);\n        } else {\n            result[key] = [\n                result[key],\n                value\n            ];\n        }\n    }\n    return result;\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=route-params.js.map","export function createHrefFromUrl(\n  url: Pick<URL, 'pathname' | 'search' | 'hash'>,\n  includeHash: boolean = true\n): string {\n  return url.pathname + url.search + (includeHash ? url.hash : '')\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    createInitialRSCPayloadFromFallbackPrerender: null,\n    getFlightDataPartsFromPath: null,\n    getNextFlightSegmentPath: null,\n    normalizeFlightData: null,\n    prepareFlightRouterStateForRequest: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    createInitialRSCPayloadFromFallbackPrerender: function() {\n        return createInitialRSCPayloadFromFallbackPrerender;\n    },\n    getFlightDataPartsFromPath: function() {\n        return getFlightDataPartsFromPath;\n    },\n    getNextFlightSegmentPath: function() {\n        return getNextFlightSegmentPath;\n    },\n    normalizeFlightData: function() {\n        return normalizeFlightData;\n    },\n    prepareFlightRouterStateForRequest: function() {\n        return prepareFlightRouterStateForRequest;\n    }\n});\nconst _segment = require(\"../shared/lib/segment\");\nconst _routeparams = require(\"./route-params\");\nconst _createhreffromurl = require(\"./components/router-reducer/create-href-from-url\");\nfunction getFlightDataPartsFromPath(flightDataPath) {\n    // Pick the last 4 items from the `FlightDataPath` to get the [tree, seedData, viewport, isHeadPartial].\n    const flightDataPathLength = 4;\n    // tree, seedData, and head are *always* the last three items in the `FlightDataPath`.\n    const [tree, seedData, head, isHeadPartial] = flightDataPath.slice(-flightDataPathLength);\n    // The `FlightSegmentPath` is everything except the last three items. For a root render, it won't be present.\n    const segmentPath = flightDataPath.slice(0, -flightDataPathLength);\n    return {\n        // TODO: Unify these two segment path helpers. We are inconsistently pushing an empty segment (\"\")\n        // to the start of the segment path in some places which makes it hard to use solely the segment path.\n        // Look for \"// TODO-APP: remove ''\" in the codebase.\n        pathToSegment: segmentPath.slice(0, -1),\n        segmentPath,\n        // if the `FlightDataPath` corresponds with the root, there'll be no segment path,\n        // in which case we default to ''.\n        segment: segmentPath[segmentPath.length - 1] ?? '',\n        tree,\n        seedData,\n        head,\n        isHeadPartial,\n        isRootRender: flightDataPath.length === flightDataPathLength\n    };\n}\nfunction createInitialRSCPayloadFromFallbackPrerender(response, fallbackInitialRSCPayload) {\n    // This is a static fallback page. In order to hydrate the page, we need to\n    // parse the client params from the URL, but to account for the possibility\n    // that the page was rewritten, we need to check the response headers\n    // for x-nextjs-rewritten-path or x-nextjs-rewritten-query headers. Since\n    // we can't access the headers of the initial document response, the client\n    // performs a fetch request to the current location. Since it's possible that\n    // the fetch request will be dynamically rewritten to a different path than\n    // the initial document, this fetch request delivers _all_ the hydration data\n    // for the page; it was not inlined into the document, like it normally\n    // would be.\n    //\n    // TODO: Consider treating the case where fetch is rewritten to a different\n    // path from the document as a special deopt case. We should optimistically\n    // assume this won't happen, inline the data into the document, and perform\n    // a minimal request (like a HEAD or range request) to verify that the\n    // response matches. Tricky to get right because we need to account for\n    // all the different deployment environments we support, like output:\n    // \"export\" mode, where we currently don't assume that custom response\n    // headers are present.\n    // Patch the Flight data sent by the server with the correct params parsed\n    // from the URL + response object.\n    const renderedPathname = (0, _routeparams.getRenderedPathname)(response);\n    const renderedSearch = (0, _routeparams.getRenderedSearch)(response);\n    const canonicalUrl = (0, _createhreffromurl.createHrefFromUrl)(new URL(location.href));\n    const originalFlightDataPath = fallbackInitialRSCPayload.f[0];\n    const originalFlightRouterState = originalFlightDataPath[0];\n    return {\n        b: fallbackInitialRSCPayload.b,\n        c: canonicalUrl.split('/'),\n        q: renderedSearch,\n        i: fallbackInitialRSCPayload.i,\n        f: [\n            [\n                fillInFallbackFlightRouterState(originalFlightRouterState, renderedPathname, renderedSearch),\n                originalFlightDataPath[1],\n                originalFlightDataPath[2],\n                originalFlightDataPath[2]\n            ]\n        ],\n        m: fallbackInitialRSCPayload.m,\n        G: fallbackInitialRSCPayload.G,\n        S: fallbackInitialRSCPayload.S\n    };\n}\nfunction fillInFallbackFlightRouterState(flightRouterState, renderedPathname, renderedSearch) {\n    const pathnameParts = renderedPathname.split('/').filter((p)=>p !== '');\n    const index = 0;\n    return fillInFallbackFlightRouterStateImpl(flightRouterState, renderedSearch, pathnameParts, index);\n}\nfunction fillInFallbackFlightRouterStateImpl(flightRouterState, renderedSearch, pathnameParts, pathnamePartsIndex) {\n    const originalSegment = flightRouterState[0];\n    let newSegment;\n    let doesAppearInURL;\n    if (typeof originalSegment === 'string') {\n        newSegment = originalSegment;\n        doesAppearInURL = (0, _routeparams.doesStaticSegmentAppearInURL)(originalSegment);\n    } else {\n        const paramName = originalSegment[0];\n        const paramType = originalSegment[2];\n        const paramValue = (0, _routeparams.parseDynamicParamFromURLPart)(paramType, pathnameParts, pathnamePartsIndex);\n        const cacheKey = (0, _routeparams.getCacheKeyForDynamicParam)(paramValue, renderedSearch);\n        newSegment = [\n            paramName,\n            cacheKey,\n            paramType\n        ];\n        doesAppearInURL = true;\n    }\n    // Only increment the index if the segment appears in the URL. If it's a\n    // \"virtual\" segment, like a route group, it remains the same.\n    const childPathnamePartsIndex = doesAppearInURL ? pathnamePartsIndex + 1 : pathnamePartsIndex;\n    const children = flightRouterState[1];\n    const newChildren = {};\n    for(let key in children){\n        const childFlightRouterState = children[key];\n        newChildren[key] = fillInFallbackFlightRouterStateImpl(childFlightRouterState, renderedSearch, pathnameParts, childPathnamePartsIndex);\n    }\n    const newState = [\n        newSegment,\n        newChildren,\n        null,\n        flightRouterState[3],\n        flightRouterState[4]\n    ];\n    return newState;\n}\nfunction getNextFlightSegmentPath(flightSegmentPath) {\n    // Since `FlightSegmentPath` is a repeated tuple of `Segment` and `ParallelRouteKey`, we slice off two items\n    // to get the next segment path.\n    return flightSegmentPath.slice(2);\n}\nfunction normalizeFlightData(flightData) {\n    // FlightData can be a string when the server didn't respond with a proper flight response,\n    // or when a redirect happens, to signal to the client that it needs to perform an MPA navigation.\n    if (typeof flightData === 'string') {\n        return flightData;\n    }\n    return flightData.map((flightDataPath)=>getFlightDataPartsFromPath(flightDataPath));\n}\nfunction prepareFlightRouterStateForRequest(flightRouterState, isHmrRefresh) {\n    // HMR requests need the complete, unmodified state for proper functionality\n    if (isHmrRefresh) {\n        return encodeURIComponent(JSON.stringify(flightRouterState));\n    }\n    return encodeURIComponent(JSON.stringify(stripClientOnlyDataFromFlightRouterState(flightRouterState)));\n}\n/**\n * Recursively strips client-only data from FlightRouterState while preserving\n * server-needed information for proper rendering decisions.\n */ function stripClientOnlyDataFromFlightRouterState(flightRouterState) {\n    const [segment, parallelRoutes, _url, refreshMarker, isRootLayout, hasLoadingBoundary] = flightRouterState;\n    // __PAGE__ segments are always fetched from the server, so there's\n    // no need to send them up\n    const cleanedSegment = stripSearchParamsFromPageSegment(segment);\n    // Recursively process parallel routes\n    const cleanedParallelRoutes = {};\n    for (const [key, childState] of Object.entries(parallelRoutes)){\n        cleanedParallelRoutes[key] = stripClientOnlyDataFromFlightRouterState(childState);\n    }\n    const result = [\n        cleanedSegment,\n        cleanedParallelRoutes,\n        null,\n        shouldPreserveRefreshMarker(refreshMarker) ? refreshMarker : null\n    ];\n    // Append optional fields if present\n    if (isRootLayout !== undefined) {\n        result[4] = isRootLayout;\n    }\n    if (hasLoadingBoundary !== undefined) {\n        result[5] = hasLoadingBoundary;\n    }\n    return result;\n}\n/**\n * Strips search parameters from __PAGE__ segments to prevent sensitive\n * client-side data from being sent to the server.\n */ function stripSearchParamsFromPageSegment(segment) {\n    if (typeof segment === 'string' && segment.startsWith(_segment.PAGE_SEGMENT_KEY + '?')) {\n        return _segment.PAGE_SEGMENT_KEY;\n    }\n    return segment;\n}\n/**\n * Determines whether the refresh marker should be sent to the server\n * Client-only markers like 'refresh' are stripped, while server-needed markers\n * like 'refetch' and 'inside-shared-layout' are preserved.\n */ function shouldPreserveRefreshMarker(refreshMarker) {\n    return Boolean(refreshMarker && refreshMarker !== 'refresh');\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=flight-data-helpers.js.map","// This gets assigned as a side-effect during app initialization. Because it\n// represents the build used to create the JS bundle, it should never change\n// after being set, so we store it in a global variable.\n//\n// When performing RSC requests, if the incoming data has a different build ID,\n// we perform an MPA navigation/refresh to load the updated build and ensure\n// that the client and server in sync.\n\n// Starts as an empty string. In practice, because setAppBuildId is called\n// during initialization before hydration starts, this will always get\n// reassigned to the actual build ID before it's ever needed by a navigation.\n// If for some reasons it didn't, due to a bug or race condition, then on\n// navigation the build comparision would fail and trigger an MPA navigation.\nlet globalBuildId: string = ''\n\nexport function setAppBuildId(buildId: string) {\n  globalBuildId = buildId\n}\n\nexport function getAppBuildId(): string {\n  return globalBuildId\n}\n","// http://www.cse.yorku.ca/~oz/hash.html\n// More specifically, 32-bit hash via djbxor\n// (ref: https://gist.github.com/eplawless/52813b1d8ad9af510d85?permalink_comment_id=3367765#gistcomment-3367765)\n// This is due to number type differences between rust for turbopack to js number types,\n// where rust does not have easy way to repreesnt js's 53-bit float number type for the matching\n// overflow behavior. This is more `correct` in terms of having canonical hash across different runtime / implementation\n// as can gaurantee determinstic output from 32bit hash.\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    djb2Hash: null,\n    hexHash: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    djb2Hash: function() {\n        return djb2Hash;\n    },\n    hexHash: function() {\n        return hexHash;\n    }\n});\nfunction djb2Hash(str) {\n    let hash = 5381;\n    for(let i = 0; i < str.length; i++){\n        const char = str.charCodeAt(i);\n        hash = (hash << 5) + hash + char & 0xffffffff;\n    }\n    return hash >>> 0;\n}\nfunction hexHash(str) {\n    return djb2Hash(str).toString(36).slice(0, 5);\n}\n\n//# sourceMappingURL=hash.js.map","import { hexHash } from '../../hash'\n\nexport function computeCacheBustingSearchParam(\n  prefetchHeader: '1' | '2' | '0' | undefined,\n  segmentPrefetchHeader: string | string[] | undefined,\n  stateTreeHeader: string | string[] | undefined,\n  nextUrlHeader: string | string[] | undefined\n): string {\n  if (\n    (prefetchHeader === undefined || prefetchHeader === '0') &&\n    segmentPrefetchHeader === undefined &&\n    stateTreeHeader === undefined &&\n    nextUrlHeader === undefined\n  ) {\n    return ''\n  }\n  return hexHash(\n    [\n      prefetchHeader || '0',\n      segmentPrefetchHeader || '0',\n      stateTreeHeader || '0',\n      nextUrlHeader || '0',\n    ].join(',')\n  )\n}\n","'use client';\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    setCacheBustingSearchParam: null,\n    setCacheBustingSearchParamWithHash: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    setCacheBustingSearchParam: function() {\n        return setCacheBustingSearchParam;\n    },\n    setCacheBustingSearchParamWithHash: function() {\n        return setCacheBustingSearchParamWithHash;\n    }\n});\nconst _cachebustingsearchparam = require(\"../../../shared/lib/router/utils/cache-busting-search-param\");\nconst _approuterheaders = require(\"../app-router-headers\");\nconst setCacheBustingSearchParam = (url, headers)=>{\n    const uniqueCacheKey = (0, _cachebustingsearchparam.computeCacheBustingSearchParam)(headers[_approuterheaders.NEXT_ROUTER_PREFETCH_HEADER], headers[_approuterheaders.NEXT_ROUTER_SEGMENT_PREFETCH_HEADER], headers[_approuterheaders.NEXT_ROUTER_STATE_TREE_HEADER], headers[_approuterheaders.NEXT_URL]);\n    setCacheBustingSearchParamWithHash(url, uniqueCacheKey);\n};\nconst setCacheBustingSearchParamWithHash = (url, hash)=>{\n    /**\n   * Note that we intentionally do not use `url.searchParams.set` here:\n   *\n   * const url = new URL('https://example.com/search?q=custom%20spacing');\n   * url.searchParams.set('_rsc', 'abc123');\n   * console.log(url.toString()); // Outputs: https://example.com/search?q=custom+spacing&_rsc=abc123\n   *                                                                             ^ <--- this is causing confusion\n   * This is in fact intended based on https://url.spec.whatwg.org/#interface-urlsearchparams, but\n   * we want to preserve the %20 as %20 if that's what the user passed in, hence the custom\n   * logic below.\n   */ const existingSearch = url.search;\n    const rawQuery = existingSearch.startsWith('?') ? existingSearch.slice(1) : existingSearch;\n    // Always remove any existing cache busting param and add a fresh one to ensure\n    // we have the correct value based on current request headers\n    const pairs = rawQuery.split('&').filter((pair)=>pair && !pair.startsWith(`${_approuterheaders.NEXT_RSC_UNION_QUERY}=`));\n    if (hash.length > 0) {\n        pairs.push(`${_approuterheaders.NEXT_RSC_UNION_QUERY}=${hash}`);\n    } else {\n        pairs.push(`${_approuterheaders.NEXT_RSC_UNION_QUERY}`);\n    }\n    url.search = pairs.length ? `?${pairs.join('&')}` : '';\n};\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=set-cache-busting-search-param.js.map","'use client';\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    createFetch: null,\n    createFromNextReadableStream: null,\n    fetchServerResponse: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    createFetch: function() {\n        return createFetch;\n    },\n    createFromNextReadableStream: function() {\n        return createFromNextReadableStream;\n    },\n    fetchServerResponse: function() {\n        return fetchServerResponse;\n    }\n});\nconst _client = require(\"react-server-dom-webpack/client\");\nconst _approuterheaders = require(\"../app-router-headers\");\nconst _appcallserver = require(\"../../app-call-server\");\nconst _appfindsourcemapurl = require(\"../../app-find-source-map-url\");\nconst _flightdatahelpers = require(\"../../flight-data-helpers\");\nconst _appbuildid = require(\"../../app-build-id\");\nconst _setcachebustingsearchparam = require(\"./set-cache-busting-search-param\");\nconst _routeparams = require(\"../../route-params\");\nconst _deploymentid = require(\"../../../shared/lib/deployment-id\");\nconst createFromReadableStream = _client.createFromReadableStream;\nconst createFromFetch = _client.createFromFetch;\nlet createDebugChannel;\nif (process.env.NODE_ENV !== 'production' && process.env.__NEXT_REACT_DEBUG_CHANNEL) {\n    createDebugChannel = require('../../dev/debug-channel').createDebugChannel;\n}\nfunction doMpaNavigation(url) {\n    return (0, _routeparams.urlToUrlWithoutFlightMarker)(new URL(url, location.origin)).toString();\n}\nlet isPageUnloading = false;\nif (typeof window !== 'undefined') {\n    // Track when the page is unloading, e.g. due to reloading the page or\n    // performing hard navigations. This allows us to suppress error logging when\n    // the browser cancels in-flight requests during page unload.\n    window.addEventListener('pagehide', ()=>{\n        isPageUnloading = true;\n    });\n    // Reset the flag on pageshow, e.g. when navigating back and the JavaScript\n    // execution context is restored by the browser.\n    window.addEventListener('pageshow', ()=>{\n        isPageUnloading = false;\n    });\n}\nasync function fetchServerResponse(url, options) {\n    const { flightRouterState, nextUrl } = options;\n    const headers = {\n        // Enable flight response\n        [_approuterheaders.RSC_HEADER]: '1',\n        // Provide the current router state\n        [_approuterheaders.NEXT_ROUTER_STATE_TREE_HEADER]: (0, _flightdatahelpers.prepareFlightRouterStateForRequest)(flightRouterState, options.isHmrRefresh)\n    };\n    if (process.env.NODE_ENV === 'development' && options.isHmrRefresh) {\n        headers[_approuterheaders.NEXT_HMR_REFRESH_HEADER] = '1';\n    }\n    if (nextUrl) {\n        headers[_approuterheaders.NEXT_URL] = nextUrl;\n    }\n    // In static export mode, we need to modify the URL to request the .txt file,\n    // but we should preserve the original URL for the canonical URL and error handling.\n    const originalUrl = url;\n    try {\n        if (process.env.NODE_ENV === 'production') {\n            if (process.env.__NEXT_CONFIG_OUTPUT === 'export') {\n                // In \"output: export\" mode, we can't rely on headers to distinguish\n                // between HTML and RSC requests. Instead, we append an extra prefix\n                // to the request.\n                url = new URL(url);\n                if (url.pathname.endsWith('/')) {\n                    url.pathname += 'index.txt';\n                } else {\n                    url.pathname += '.txt';\n                }\n            }\n        }\n        // Typically, during a navigation, we decode the response using Flight's\n        // `createFromFetch` API, which accepts a `fetch` promise.\n        // TODO: Remove this check once the old PPR flag is removed\n        const isLegacyPPR = process.env.__NEXT_PPR && !process.env.__NEXT_CACHE_COMPONENTS;\n        const shouldImmediatelyDecode = !isLegacyPPR;\n        const res = await createFetch(url, headers, 'auto', shouldImmediatelyDecode);\n        const responseUrl = (0, _routeparams.urlToUrlWithoutFlightMarker)(new URL(res.url));\n        const canonicalUrl = res.redirected ? responseUrl : originalUrl;\n        const contentType = res.headers.get('content-type') || '';\n        const interception = !!res.headers.get('vary')?.includes(_approuterheaders.NEXT_URL);\n        const postponed = !!res.headers.get(_approuterheaders.NEXT_DID_POSTPONE_HEADER);\n        const staleTimeHeaderSeconds = res.headers.get(_approuterheaders.NEXT_ROUTER_STALE_TIME_HEADER);\n        const staleTime = staleTimeHeaderSeconds !== null ? parseInt(staleTimeHeaderSeconds, 10) * 1000 : -1;\n        let isFlightResponse = contentType.startsWith(_approuterheaders.RSC_CONTENT_TYPE_HEADER);\n        if (process.env.NODE_ENV === 'production') {\n            if (process.env.__NEXT_CONFIG_OUTPUT === 'export') {\n                if (!isFlightResponse) {\n                    isFlightResponse = contentType.startsWith('text/plain');\n                }\n            }\n        }\n        // If fetch returns something different than flight response handle it like a mpa navigation\n        // If the fetch was not 200, we also handle it like a mpa navigation\n        if (!isFlightResponse || !res.ok || !res.body) {\n            // in case the original URL came with a hash, preserve it before redirecting to the new URL\n            if (url.hash) {\n                responseUrl.hash = url.hash;\n            }\n            return doMpaNavigation(responseUrl.toString());\n        }\n        // We may navigate to a page that requires a different Webpack runtime.\n        // In prod, every page will have the same Webpack runtime.\n        // In dev, the Webpack runtime is minimal for each page.\n        // We need to ensure the Webpack runtime is updated before executing client-side JS of the new page.\n        // TODO: This needs to happen in the Flight Client.\n        // Or Webpack needs to include the runtime update in the Flight response as\n        // a blocking script.\n        if (process.env.NODE_ENV !== 'production' && !process.env.TURBOPACK) {\n            await require('../../dev/hot-reloader/app/hot-reloader-app').waitForWebpackRuntimeHotUpdate();\n        }\n        let flightResponsePromise = res.flightResponse;\n        if (flightResponsePromise === null) {\n            // Typically, `createFetch` would have already started decoding the\n            // Flight response. If it hasn't, though, we need to decode it now.\n            // TODO: This should only be reachable if legacy PPR is enabled (i.e. PPR\n            // without Cache Components). Remove this branch once legacy PPR\n            // is deleted.\n            const flightStream = postponed ? createUnclosingPrefetchStream(res.body) : res.body;\n            flightResponsePromise = createFromNextReadableStream(flightStream, headers);\n        }\n        const flightResponse = await flightResponsePromise;\n        if ((0, _appbuildid.getAppBuildId)() !== flightResponse.b) {\n            return doMpaNavigation(res.url);\n        }\n        const normalizedFlightData = (0, _flightdatahelpers.normalizeFlightData)(flightResponse.f);\n        if (typeof normalizedFlightData === 'string') {\n            return doMpaNavigation(normalizedFlightData);\n        }\n        return {\n            flightData: normalizedFlightData,\n            canonicalUrl: canonicalUrl,\n            renderedSearch: (0, _routeparams.getRenderedSearch)(res),\n            couldBeIntercepted: interception,\n            prerendered: flightResponse.S,\n            postponed,\n            staleTime,\n            debugInfo: flightResponsePromise._debugInfo ?? null\n        };\n    } catch (err) {\n        if (!isPageUnloading) {\n            console.error(`Failed to fetch RSC payload for ${originalUrl}. Falling back to browser navigation.`, err);\n        }\n        // If fetch fails handle it like a mpa navigation\n        // TODO-APP: Add a test for the case where a CORS request fails, e.g. external url redirect coming from the response.\n        // See https://github.com/vercel/next.js/issues/43605#issuecomment-1451617521 for a reproduction.\n        return originalUrl.toString();\n    }\n}\nasync function createFetch(url, headers, fetchPriority, shouldImmediatelyDecode, signal) {\n    // TODO: In output: \"export\" mode, the headers do nothing. Omit them (and the\n    // cache busting search param) from the request so they're\n    // maximally cacheable.\n    if (process.env.__NEXT_TEST_MODE && fetchPriority !== null) {\n        headers['Next-Test-Fetch-Priority'] = fetchPriority;\n    }\n    const deploymentId = (0, _deploymentid.getDeploymentId)();\n    if (deploymentId) {\n        headers['x-deployment-id'] = deploymentId;\n    }\n    if (process.env.NODE_ENV !== 'production') {\n        if (self.__next_r) {\n            headers[_approuterheaders.NEXT_HTML_REQUEST_ID_HEADER] = self.__next_r;\n        }\n        // Create a new request ID for the server action request. The server uses\n        // this to tag debug information sent via WebSocket to the client, which\n        // then routes those chunks to the debug channel associated with this ID.\n        headers[_approuterheaders.NEXT_REQUEST_ID_HEADER] = crypto.getRandomValues(new Uint32Array(1))[0].toString(16);\n    }\n    const fetchOptions = {\n        // Backwards compat for older browsers. `same-origin` is the default in modern browsers.\n        credentials: 'same-origin',\n        headers,\n        priority: fetchPriority || undefined,\n        signal\n    };\n    // `fetchUrl` is slightly different from `url` because we add a cache-busting\n    // search param to it. This should not leak outside of this function, so we\n    // track them separately.\n    let fetchUrl = new URL(url);\n    (0, _setcachebustingsearchparam.setCacheBustingSearchParam)(fetchUrl, headers);\n    let fetchPromise = fetch(fetchUrl, fetchOptions);\n    // Immediately pass the fetch promise to the Flight client so that the debug\n    // info includes the latency from the client to the server. The internal timer\n    // in React starts as soon as `createFromFetch` is called.\n    //\n    // The only case where we don't do this is during a prefetch, because we have\n    // to do some extra processing of the response stream (see\n    // `createUnclosingPrefetchStream`). But this is fine, because a top-level\n    // prefetch response never blocks a navigation; if it hasn't already been\n    // written into the cache by the time the navigation happens, the router will\n    // go straight to a dynamic request.\n    let flightResponsePromise = shouldImmediatelyDecode ? createFromNextFetch(fetchPromise, headers) : null;\n    let browserResponse = await fetchPromise;\n    // If the server responds with a redirect (e.g. 307), and the redirected\n    // location does not contain the cache busting search param set in the\n    // original request, the response is likely invalid — when following the\n    // redirect, the browser forwards the request headers, but since the cache\n    // busting search param is missing, the server will reject the request due to\n    // a mismatch.\n    //\n    // Ideally, we would be able to intercept the redirect response and perform it\n    // manually, instead of letting the browser automatically follow it, but this\n    // is not allowed by the fetch API.\n    //\n    // So instead, we must \"replay\" the redirect by fetching the new location\n    // again, but this time we'll append the cache busting search param to prevent\n    // a mismatch.\n    //\n    // TODO: We can optimize Next.js's built-in middleware APIs by returning a\n    // custom status code, to prevent the browser from automatically following it.\n    //\n    // This does not affect Server Action-based redirects; those are encoded\n    // differently, as part of the Flight body. It only affects redirects that\n    // occur in a middleware or a third-party proxy.\n    let redirected = browserResponse.redirected;\n    if (process.env.__NEXT_CLIENT_VALIDATE_RSC_REQUEST_HEADERS) {\n        // This is to prevent a redirect loop. Same limit used by Chrome.\n        const MAX_REDIRECTS = 20;\n        for(let n = 0; n < MAX_REDIRECTS; n++){\n            if (!browserResponse.redirected) {\n                break;\n            }\n            const responseUrl = new URL(browserResponse.url, fetchUrl);\n            if (responseUrl.origin !== fetchUrl.origin) {\n                break;\n            }\n            if (responseUrl.searchParams.get(_approuterheaders.NEXT_RSC_UNION_QUERY) === fetchUrl.searchParams.get(_approuterheaders.NEXT_RSC_UNION_QUERY)) {\n                break;\n            }\n            // The RSC request was redirected. Assume the response is invalid.\n            //\n            // Append the cache busting search param to the redirected URL and\n            // fetch again.\n            // TODO: We should abort the previous request.\n            fetchUrl = new URL(responseUrl);\n            (0, _setcachebustingsearchparam.setCacheBustingSearchParam)(fetchUrl, headers);\n            fetchPromise = fetch(fetchUrl, fetchOptions);\n            flightResponsePromise = shouldImmediatelyDecode ? createFromNextFetch(fetchPromise, headers) : null;\n            browserResponse = await fetchPromise;\n            // We just performed a manual redirect, so this is now true.\n            redirected = true;\n        }\n    }\n    // Remove the cache busting search param from the response URL, to prevent it\n    // from leaking outside of this function.\n    const responseUrl = new URL(browserResponse.url, fetchUrl);\n    responseUrl.searchParams.delete(_approuterheaders.NEXT_RSC_UNION_QUERY);\n    const rscResponse = {\n        url: responseUrl.href,\n        // This is true if any redirects occurred, either automatically by the\n        // browser, or manually by us. So it's different from\n        // `browserResponse.redirected`, which only tells us whether the browser\n        // followed a redirect, and only for the last response in the chain.\n        redirected,\n        // These can be copied from the last browser response we received. We\n        // intentionally only expose the subset of fields that are actually used\n        // elsewhere in the codebase.\n        ok: browserResponse.ok,\n        headers: browserResponse.headers,\n        body: browserResponse.body,\n        status: browserResponse.status,\n        // This is the exact promise returned by `createFromFetch`. It contains\n        // debug information that we need to transfer to any derived promises that\n        // are later rendered by React.\n        flightResponse: flightResponsePromise\n    };\n    return rscResponse;\n}\nfunction createFromNextReadableStream(flightStream, requestHeaders) {\n    return createFromReadableStream(flightStream, {\n        callServer: _appcallserver.callServer,\n        findSourceMapURL: _appfindsourcemapurl.findSourceMapURL,\n        debugChannel: createDebugChannel && createDebugChannel(requestHeaders)\n    });\n}\nfunction createFromNextFetch(promiseForResponse, requestHeaders) {\n    return createFromFetch(promiseForResponse, {\n        callServer: _appcallserver.callServer,\n        findSourceMapURL: _appfindsourcemapurl.findSourceMapURL,\n        debugChannel: createDebugChannel && createDebugChannel(requestHeaders)\n    });\n}\nfunction createUnclosingPrefetchStream(originalFlightStream) {\n    // When PPR is enabled, prefetch streams may contain references that never\n    // resolve, because that's how we encode dynamic data access. In the decoded\n    // object returned by the Flight client, these are reified into hanging\n    // promises that suspend during render, which is effectively what we want.\n    // The UI resolves when it switches to the dynamic data stream\n    // (via useDeferredValue(dynamic, static)).\n    //\n    // However, the Flight implementation currently errors if the server closes\n    // the response before all the references are resolved. As a cheat to work\n    // around this, we wrap the original stream in a new stream that never closes,\n    // and therefore doesn't error.\n    const reader = originalFlightStream.getReader();\n    return new ReadableStream({\n        async pull (controller) {\n            while(true){\n                const { done, value } = await reader.read();\n                if (!done) {\n                    // Pass to the target stream and keep consuming the Flight response\n                    // from the server.\n                    controller.enqueue(value);\n                    continue;\n                }\n                // The server stream has closed. Exit, but intentionally do not close\n                // the target stream.\n                return;\n            }\n        }\n    });\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=fetch-server-response.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    deleteFromLru: null,\n    lruPut: null,\n    updateLruSize: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    deleteFromLru: function() {\n        return deleteFromLru;\n    },\n    lruPut: function() {\n        return lruPut;\n    },\n    updateLruSize: function() {\n        return updateLruSize;\n    }\n});\nconst _cachemap = require(\"./cache-map\");\n// We use an LRU for memory management. We must update this whenever we add or\n// remove a new cache entry, or when an entry changes size.\nlet head = null;\nlet didScheduleCleanup = false;\nlet lruSize = 0;\n// TODO: I chose the max size somewhat arbitrarily. Consider setting this based\n// on navigator.deviceMemory, or some other heuristic. We should make this\n// customizable via the Next.js config, too.\nconst maxLruSize = 50 * 1024 * 1024 // 50 MB\n;\nfunction lruPut(node) {\n    if (head === node) {\n        // Already at the head\n        return;\n    }\n    const prev = node.prev;\n    const next = node.next;\n    if (next === null || prev === null) {\n        // This is an insertion\n        lruSize += node.size;\n        // Whenever we add an entry, we need to check if we've exceeded the\n        // max size. We don't evict entries immediately; they're evicted later in\n        // an asynchronous task.\n        ensureCleanupIsScheduled();\n    } else {\n        // This is a move. Remove from its current position.\n        prev.next = next;\n        next.prev = prev;\n    }\n    // Move to the front of the list\n    if (head === null) {\n        // This is the first entry\n        node.prev = node;\n        node.next = node;\n    } else {\n        // Add to the front of the list\n        const tail = head.prev;\n        node.prev = tail;\n        // In practice, this is never null, but that isn't encoded in the type\n        if (tail !== null) {\n            tail.next = node;\n        }\n        node.next = head;\n        head.prev = node;\n    }\n    head = node;\n}\nfunction updateLruSize(node, newNodeSize) {\n    // This is a separate function from `put` so that we can resize the entry\n    // regardless of whether it's currently being tracked by the LRU.\n    const prevNodeSize = node.size;\n    node.size = newNodeSize;\n    if (node.next === null) {\n        // This entry is not currently being tracked by the LRU.\n        return;\n    }\n    // Update the total LRU size\n    lruSize = lruSize - prevNodeSize + newNodeSize;\n    ensureCleanupIsScheduled();\n}\nfunction deleteFromLru(deleted) {\n    const next = deleted.next;\n    const prev = deleted.prev;\n    if (next !== null && prev !== null) {\n        lruSize -= deleted.size;\n        deleted.next = null;\n        deleted.prev = null;\n        // Remove from the list\n        if (head === deleted) {\n            // Update the head\n            if (next === head) {\n                // This was the last entry\n                head = null;\n            } else {\n                head = next;\n                prev.next = next;\n                next.prev = prev;\n            }\n        } else {\n            prev.next = next;\n            next.prev = prev;\n        }\n    } else {\n    // Already deleted\n    }\n}\nfunction ensureCleanupIsScheduled() {\n    if (didScheduleCleanup || lruSize <= maxLruSize) {\n        return;\n    }\n    didScheduleCleanup = true;\n    requestCleanupCallback(cleanup);\n}\nfunction cleanup() {\n    didScheduleCleanup = false;\n    // Evict entries until we're at 90% capacity. We can assume this won't\n    // infinite loop because even if `maxLruSize` were 0, eventually\n    // `deleteFromLru` sets `head` to `null` when we run out entries.\n    const ninetyPercentMax = maxLruSize * 0.9;\n    while(lruSize > ninetyPercentMax && head !== null){\n        const tail = head.prev;\n        // In practice, this is never null, but that isn't encoded in the type\n        if (tail !== null) {\n            // Delete the entry from the map. In turn, this will remove it from\n            // the LRU.\n            (0, _cachemap.deleteMapEntry)(tail);\n        }\n    }\n}\nconst requestCleanupCallback = typeof requestIdleCallback === 'function' ? requestIdleCallback : (cb)=>setTimeout(cb, 0);\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=lru.js.map","import type { VaryPath } from './vary-path'\nimport { lruPut, updateLruSize, deleteFromLru } from './lru'\n\n/**\n * A specialized data type for storing multi-key cache entries.\n *\n * The basic structure is a map whose keys are tuples, called the keypath.\n * When querying the cache, keypaths are compared per-element.\n *\n * Example:\n *   set(map, ['https://localhost', 'foo/bar/baz'], 'yay');\n *   get(map, ['https://localhost', 'foo/bar/baz']) -> 'yay'\n *\n * NOTE: Array syntax is used in these examples for illustration purposes, but\n * in reality the paths are lists.\n * \n * The parts of the keypath represent the different inputs that contribute\n * to the entry value. To illustrate, if you were to use this data type to store\n * HTTP responses, the keypath would include the URL and everything listed by\n * the Vary header.\n * \n * See vary-path.ts for more details.\n *\n * The order of elements in a keypath must be consistent between lookups to\n * be considered the same, but besides that, the order of the keys is not\n * semantically meaningful.\n *\n * Keypaths may include a special kind of key called Fallback. When an entry is\n * stored with Fallback as part of its keypath, it means that the entry does not\n * vary by that key. When querying the cache, if an exact match is not found for\n * a keypath, the cache will check for a Fallback match instead. Each element of\n * the keypath may have a Fallback, so retrieval is an O(n ^ 2) operation, but\n * it's expected that keypaths are relatively short.\n *\n * Example:\n *   set(cacheMap, ['store', 'product', 1], PRODUCT_PAGE_1);\n *   set(cacheMap, ['store', 'product', Fallback], GENERIC_PRODUCT_PAGE);\n *\n *   // Exact match\n *   get(cacheMap, ['store', 'product', 1]) -> PRODUCT_PAGE_1\n *\n *   // Fallback match\n *   get(cacheMap, ['store', 'product', 2]) -> GENERIC_PRODUCT_PAGE\n *\n * Because we have the Fallback mechanism, we can impose a constraint that\n * regular JS maps do not have: a value cannot be stored at multiple keypaths\n * simultaneously. These cases should be expressed with Fallback keys instead.\n *\n * Additionally, because values only exist at a single keypath at a time, we\n * can optimize successive lookups by caching the internal map entry on the\n * value itself, using the `ref` field. This is especially useful because it\n * lets us skip the O(n ^ 2) lookup that occurs when Fallback entries\n * are present.\n *\n\n * How to decide if stuff belongs in here, or in cache.ts?\n * -------------------------------------------------------\n * \n * Anything to do with retrival, lifetimes, or eviction needs to go in this\n * module because it affects the fallback algorithm. For example, when\n * performing a lookup, if an entry is stale, it needs to be treated as\n * semantically equivalent to if the entry was not present at all.\n * \n * If there's logic that's not related to the fallback algorithm, though, we\n * should prefer to put it in cache.ts.\n */\n\n// The protocol that values must implement. In practice, the only two types that\n// we ever actually deal with in this module are RouteCacheEntry and\n// SegmentCacheEntry; this is just to keep track of the coupling so we don't\n// leak concerns between the modules unnecessarily.\nexport interface MapValue {\n  ref: UnknownMapEntry | null\n  size: number\n  staleAt: number\n  version: number\n}\n\n/**\n * Represents a node in the cache map and LRU.\n * MapEntry<V> structurally satisfies this interface for any V extends MapValue.\n *\n * The LRU can contain entries of different value types\n * (e.g., both RouteCacheEntry and SegmentCacheEntry). This interface captures\n * the common structure needed for cache map and LRU operations without\n * requiring knowledge of the specific value type.\n */\nexport interface MapEntry<V extends MapValue> {\n  // Cache map structure fields\n  parent: MapEntry<V> | null\n  key: unknown\n  map: Map<unknown, MapEntry<V>> | null\n  value: V | null\n\n  // LRU linked list fields\n  prev: MapEntry<V> | null\n  next: MapEntry<V> | null\n  size: number\n}\n\n/**\n * A looser type for MapEntry\n * This allows the LRU to work with entries of different\n * value types while still providing type safety.\n *\n * The `map` field lets Map<unknown, MapEntry<V>> be assignable to this\n * type since we're only reading from the map, not inserting into it.\n */\nexport type UnknownMapEntry = {\n  parent: UnknownMapEntry | null\n  key: unknown\n  map: Pick<Map<unknown, UnknownMapEntry>, 'get' | 'delete' | 'size'> | null\n  value: MapValue | null\n\n  prev: UnknownMapEntry | null\n  next: UnknownMapEntry | null\n  size: number\n}\n\n// The CacheMap type is just the root entry of the map.\nexport type CacheMap<V extends MapValue> = MapEntry<V>\n\nexport type FallbackType = { __brand: 'Fallback' }\nexport const Fallback = {} as FallbackType\n\n// This is a special internal key that is used for \"revalidation\" entries. It's\n// an implementation detail that shouldn't leak outside of this module.\nconst Revalidation = {}\n\nexport function createCacheMap<V extends MapValue>(): CacheMap<V> {\n  const cacheMap: MapEntry<V> = {\n    parent: null,\n    key: null,\n    value: null,\n    map: null,\n\n    // LRU-related fields\n    prev: null,\n    next: null,\n    size: 0,\n  }\n  return cacheMap\n}\n\nfunction getOrInitialize<V extends MapValue>(\n  cacheMap: CacheMap<V>,\n  keys: VaryPath,\n  isRevalidation: boolean\n): MapEntry<V> {\n  // Go through each level of keys until we find the entry that matches, or\n  // create a new entry if one doesn't exist.\n  //\n  // This function will only return entries that match the keypath _exactly_.\n  // Unlike getWithFallback, it will not access fallback entries unless it's\n  // explicitly part of the keypath.\n  let entry = cacheMap\n  let remainingKeys: VaryPath | null = keys\n  let key: unknown | null = null\n  while (true) {\n    const previousKey = key\n    if (remainingKeys !== null) {\n      key = remainingKeys.value\n      remainingKeys = remainingKeys.parent\n    } else if (isRevalidation && previousKey !== Revalidation) {\n      // During a revalidation, we append an internal \"Revalidation\" key to\n      // the end of the keypath. The \"normal\" entry is its parent.\n\n      // However, if the parent entry is currently empty, we don't need to store\n      // this as a revalidation entry. Just insert the revalidation into the\n      // normal slot.\n      if (entry.value === null) {\n        return entry\n      }\n\n      // Otheriwse, create a child entry.\n      key = Revalidation\n    } else {\n      // There are no more keys. This is the terminal entry.\n      break\n    }\n\n    let map = entry.map\n    if (map !== null) {\n      const existingEntry = map.get(key)\n      if (existingEntry !== undefined) {\n        // Found a match. Keep going.\n        entry = existingEntry\n        continue\n      }\n    } else {\n      map = new Map()\n      entry.map = map\n    }\n    // No entry exists yet at this level. Create a new one.\n    const newEntry: MapEntry<V> = {\n      parent: entry,\n      key,\n      value: null,\n      map: null,\n\n      // LRU-related fields\n      prev: null,\n      next: null,\n      size: 0,\n    }\n    map.set(key, newEntry)\n    entry = newEntry\n  }\n\n  return entry\n}\n\nexport function getFromCacheMap<V extends MapValue>(\n  now: number,\n  currentCacheVersion: number,\n  rootEntry: CacheMap<V>,\n  keys: VaryPath,\n  isRevalidation: boolean\n): V | null {\n  const entry = getEntryWithFallbackImpl(\n    now,\n    currentCacheVersion,\n    rootEntry,\n    keys,\n    isRevalidation,\n    0\n  )\n  if (entry === null || entry.value === null) {\n    return null\n  }\n  // This is an LRU access. Move the entry to the front of the list.\n  lruPut(entry)\n  return entry.value\n}\n\nexport function isValueExpired(\n  now: number,\n  currentCacheVersion: number,\n  value: MapValue\n): boolean {\n  return value.staleAt <= now || value.version < currentCacheVersion\n}\n\nfunction lazilyEvictIfNeeded<V extends MapValue>(\n  now: number,\n  currentCacheVersion: number,\n  entry: MapEntry<V>\n) {\n  // We have a matching entry, but before we can return it, we need to check if\n  // it's still fresh. Otherwise it should be treated the same as a cache miss.\n\n  if (entry.value === null) {\n    // This entry has no value, so there's nothing to evict.\n    return entry\n  }\n\n  const value = entry.value\n  if (isValueExpired(now, currentCacheVersion, value)) {\n    // The value expired. Lazily evict it from the cache, and return null. This\n    // is conceptually the same as a cache miss.\n    deleteMapEntry(entry)\n    return null\n  }\n\n  // The matched entry has not expired. Return it.\n  return entry\n}\n\nfunction getEntryWithFallbackImpl<V extends MapValue>(\n  now: number,\n  currentCacheVersion: number,\n  entry: MapEntry<V>,\n  keys: VaryPath | null,\n  isRevalidation: boolean,\n  previousKey: unknown | null\n): MapEntry<V> | null {\n  // This is similar to getExactEntry, but if an exact match is not found for\n  // a key, it will return the fallback entry instead. This is recursive at\n  // every level, e.g. an entry with keypath [a, Fallback, c, Fallback] is\n  // valid match for [a, b, c, d].\n  //\n  // It will return the most specific match available.\n  let key\n  let remainingKeys: VaryPath | null\n  if (keys !== null) {\n    key = keys.value\n    remainingKeys = keys.parent\n  } else if (isRevalidation && previousKey !== Revalidation) {\n    // During a revalidation, we append an internal \"Revalidation\" key to\n    // the end of the keypath.\n    key = Revalidation\n    remainingKeys = null\n  } else {\n    // There are no more keys. This is the terminal entry.\n\n    // TODO: When performing a lookup during a navigation, as opposed to a\n    // prefetch, we may want to skip entries that are Pending if there's also\n    // a Fulfilled fallback entry. Tricky to say, though, since if it's\n    // already pending, it's likely to stream in soon. Maybe we could do this\n    // just on slow connections and offline mode.\n\n    return lazilyEvictIfNeeded(now, currentCacheVersion, entry)\n  }\n  const map = entry.map\n  if (map !== null) {\n    const existingEntry = map.get(key)\n    if (existingEntry !== undefined) {\n      // Found an exact match for this key. Keep searching.\n      const result = getEntryWithFallbackImpl(\n        now,\n        currentCacheVersion,\n        existingEntry,\n        remainingKeys,\n        isRevalidation,\n        key\n      )\n      if (result !== null) {\n        return result\n      }\n    }\n    // No match found for this key. Check if there's a fallback.\n    const fallbackEntry = map.get(Fallback)\n    if (fallbackEntry !== undefined) {\n      // Found a fallback for this key. Keep searching.\n      return getEntryWithFallbackImpl(\n        now,\n        currentCacheVersion,\n        fallbackEntry,\n        remainingKeys,\n        isRevalidation,\n        key\n      )\n    }\n  }\n  return null\n}\n\nexport function setInCacheMap<V extends MapValue>(\n  cacheMap: CacheMap<V>,\n  keys: VaryPath,\n  value: V,\n  isRevalidation: boolean\n): void {\n  // Add a value to the map at the given keypath. If the value is already\n  // part of the map, it's removed from its previous keypath. (NOTE: This is\n  // unlike a regular JS map, but the behavior is intentional.)\n  const entry = getOrInitialize(cacheMap, keys, isRevalidation)\n  setMapEntryValue(entry, value)\n\n  // This is an LRU access. Move the entry to the front of the list.\n  lruPut(entry)\n  updateLruSize(entry, value.size)\n}\n\nfunction setMapEntryValue(entry: UnknownMapEntry, value: MapValue): void {\n  if (entry.value !== null) {\n    // There's already a value at the given keypath. Disconnect the old value\n    // from the map. We're not calling `deleteMapEntry` here because the\n    // entry itself is still in the map. We just want to overwrite its value.\n    dropRef(entry.value)\n    entry.value = null\n  }\n\n  // This value may already be in the map at a different keypath.\n  // Grab a reference before we overwrite it.\n  const oldEntry = value.ref\n\n  entry.value = value\n  value.ref = entry\n\n  updateLruSize(entry, value.size)\n\n  if (oldEntry !== null && oldEntry !== entry && oldEntry.value === value) {\n    // This value is already in the map at a different keypath in the map.\n    // Values only exist at a single keypath at a time. Remove it from the\n    // previous keypath.\n    //\n    // Note that only the internal map entry is garbage collected; we don't\n    // call `dropRef` here because it's still in the map, just\n    // at a new keypath (the one we just set, above).\n    deleteMapEntry(oldEntry)\n  }\n}\n\nexport function deleteFromCacheMap(value: MapValue): void {\n  const entry = value.ref\n  if (entry === null) {\n    // This value is not a member of any map.\n    return\n  }\n\n  dropRef(value)\n  deleteMapEntry(entry)\n}\n\nfunction dropRef(value: MapValue): void {\n  // Drop the value from the map by setting its `ref` backpointer to\n  // null. This is a separate operation from `deleteMapEntry` because when\n  // re-keying a value we need to be able to delete the old, internal map\n  // entry without garbage collecting the value itself.\n  value.ref = null\n}\n\nexport function deleteMapEntry(entry: UnknownMapEntry): void {\n  // Delete the entry from the cache.\n  entry.value = null\n\n  deleteFromLru(entry)\n\n  // Check if we can garbage collect the entry.\n  const map = entry.map\n  if (map === null) {\n    // Since this entry has no value, and also no child entries, we can\n    // garbage collect it. Remove it from its parent, and keep garbage\n    // collecting the parents until we reach a non-empty entry.\n    let parent = entry.parent\n    let key = entry.key\n    while (parent !== null) {\n      const parentMap = parent.map\n      if (parentMap !== null) {\n        parentMap.delete(key)\n        if (parentMap.size === 0) {\n          // We just removed the last entry in the parent map.\n          parent.map = null\n          if (parent.value === null) {\n            // The parent node has no child entries, nor does it have a value\n            // on itself. It can be garbage collected. Keep going.\n            key = parent.key\n            parent = parent.parent\n            continue\n          }\n        }\n      }\n      // The parent is not empty. Stop garbage collecting.\n      break\n    }\n  } else {\n    // Check if there's a revalidating entry. If so, promote it to a\n    // \"normal\" entry, since the normal one was just deleted.\n    const revalidatingEntry = map.get(Revalidation)\n    if (revalidatingEntry !== undefined && revalidatingEntry.value !== null) {\n      setMapEntryValue(entry, revalidatingEntry.value)\n    }\n  }\n}\n\nexport function setSizeInCacheMap<V extends MapValue>(\n  value: V,\n  size: number\n): void {\n  const entry = value.ref\n  if (entry === null) {\n    // This value is not a member of any map.\n    return\n  }\n  // Except during initialization (when the size is set to 0), this is the only\n  // place the `size` field should be updated, to ensure it's in sync with the\n  // the LRU.\n  value.size = size\n  updateLruSize(entry, size)\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    appendLayoutVaryPath: null,\n    clonePageVaryPathWithNewSearchParams: null,\n    finalizeLayoutVaryPath: null,\n    finalizeMetadataVaryPath: null,\n    finalizePageVaryPath: null,\n    getFulfilledRouteVaryPath: null,\n    getRouteVaryPath: null,\n    getSegmentVaryPathForRequest: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    appendLayoutVaryPath: function() {\n        return appendLayoutVaryPath;\n    },\n    clonePageVaryPathWithNewSearchParams: function() {\n        return clonePageVaryPathWithNewSearchParams;\n    },\n    finalizeLayoutVaryPath: function() {\n        return finalizeLayoutVaryPath;\n    },\n    finalizeMetadataVaryPath: function() {\n        return finalizeMetadataVaryPath;\n    },\n    finalizePageVaryPath: function() {\n        return finalizePageVaryPath;\n    },\n    getFulfilledRouteVaryPath: function() {\n        return getFulfilledRouteVaryPath;\n    },\n    getRouteVaryPath: function() {\n        return getRouteVaryPath;\n    },\n    getSegmentVaryPathForRequest: function() {\n        return getSegmentVaryPathForRequest;\n    }\n});\nconst _types = require(\"./types\");\nconst _cachemap = require(\"./cache-map\");\nconst _segmentvalueencoding = require(\"../../../shared/lib/segment-cache/segment-value-encoding\");\nfunction getRouteVaryPath(pathname, search, nextUrl) {\n    // requestKey -> searchParams -> nextUrl\n    const varyPath = {\n        value: pathname,\n        parent: {\n            value: search,\n            parent: {\n                value: nextUrl,\n                parent: null\n            }\n        }\n    };\n    return varyPath;\n}\nfunction getFulfilledRouteVaryPath(pathname, search, nextUrl, couldBeIntercepted) {\n    // This is called when a route's data is fulfilled. The cache entry will be\n    // re-keyed based on which inputs the response varies by.\n    // requestKey -> searchParams -> nextUrl\n    const varyPath = {\n        value: pathname,\n        parent: {\n            value: search,\n            parent: {\n                value: couldBeIntercepted ? nextUrl : _cachemap.Fallback,\n                parent: null\n            }\n        }\n    };\n    return varyPath;\n}\nfunction appendLayoutVaryPath(parentPath, cacheKey) {\n    const varyPathPart = {\n        value: cacheKey,\n        parent: parentPath\n    };\n    return varyPathPart;\n}\nfunction finalizeLayoutVaryPath(requestKey, varyPath) {\n    const layoutVaryPath = {\n        value: requestKey,\n        parent: varyPath\n    };\n    return layoutVaryPath;\n}\nfunction finalizePageVaryPath(requestKey, renderedSearch, varyPath) {\n    // Unlike layouts, a page segment's vary path also includes the search string.\n    // requestKey -> searchParams -> pathParams\n    const pageVaryPath = {\n        value: requestKey,\n        parent: {\n            value: renderedSearch,\n            parent: varyPath\n        }\n    };\n    return pageVaryPath;\n}\nfunction finalizeMetadataVaryPath(pageRequestKey, renderedSearch, varyPath) {\n    // The metadata \"segment\" is not a real segment because it doesn't exist in\n    // the normal structure of the route tree, but in terms of caching, it\n    // behaves like a page segment because it varies by all the same params as\n    // a page.\n    //\n    // To keep the protocol for querying the server simple, the request key for\n    // the metadata does not include any path information. It's unnecessary from\n    // the server's perspective, because unlike page segments, there's only one\n    // metadata response per URL, i.e. there's no need to distinguish multiple\n    // parallel pages.\n    //\n    // However, this means the metadata request key is insufficient for\n    // caching the the metadata in the client cache, because on the client we\n    // use the request key to distinguish the metadata entry from all other\n    // page's metadata entries.\n    //\n    // So instead we create a simulated request key based on the page segment.\n    // Conceptually this is equivalent to the request key the server would have\n    // assigned the metadata segment if it treated it as part of the actual\n    // route structure.\n    // If there are multiple parallel pages, we use whichever is the first one.\n    // This is fine because the only difference between request keys for\n    // different parallel pages are things like route groups and parallel\n    // route slots. As long as it's always the same one, it doesn't matter.\n    const pageVaryPath = {\n        // Append the actual metadata request key to the page request key. Note\n        // that we're not using a separate vary path part; it's unnecessary because\n        // these are not conceptually separate inputs.\n        value: pageRequestKey + _segmentvalueencoding.HEAD_REQUEST_KEY,\n        parent: {\n            value: renderedSearch,\n            parent: varyPath\n        }\n    };\n    return pageVaryPath;\n}\nfunction getSegmentVaryPathForRequest(fetchStrategy, tree) {\n    // This is used for storing pending requests in the cache. We want to choose\n    // the most generic vary path based on the strategy used to fetch it, i.e.\n    // static/PPR versus runtime prefetching, so that it can be reused as much\n    // as possible.\n    //\n    // We may be able to re-key the response to something even more generic once\n    // we receive it — for example, if the server tells us that the response\n    // doesn't vary on a particular param — but even before we send the request,\n    // we know some params are reusable based on the fetch strategy alone. For\n    // example, a static prefetch will never vary on search params.\n    //\n    // The original vary path with all the params filled in is stored on the\n    // route tree object. We will clone this one to create a new vary path\n    // where certain params are replaced with Fallback.\n    //\n    // This result of this function is not stored anywhere. It's only used to\n    // access the cache a single time.\n    //\n    // TODO: Rather than create a new list object just to access the cache, the\n    // plan is to add the concept of a \"vary mask\". This will represent all the\n    // params that can be treated as Fallback. (Or perhaps the inverse.)\n    const originalVaryPath = tree.varyPath;\n    // Only page segments (and the special \"metadata\" segment, which is treated\n    // like a page segment for the purposes of caching) may contain search\n    // params. There's no reason to include them in the vary path otherwise.\n    if (tree.isPage) {\n        // Only a runtime prefetch will include search params in the vary path.\n        // Static prefetches never include search params, so they can be reused\n        // across all possible search param values.\n        const doesVaryOnSearchParams = fetchStrategy === _types.FetchStrategy.Full || fetchStrategy === _types.FetchStrategy.PPRRuntime;\n        if (!doesVaryOnSearchParams) {\n            // The response from the the server will not vary on search params. Clone\n            // the end of the original vary path to replace the search params\n            // with Fallback.\n            //\n            // requestKey -> searchParams -> pathParams\n            //               ^ This part gets replaced with Fallback\n            const searchParamsVaryPath = originalVaryPath.parent;\n            const pathParamsVaryPath = searchParamsVaryPath.parent;\n            const patchedVaryPath = {\n                value: originalVaryPath.value,\n                parent: {\n                    value: _cachemap.Fallback,\n                    parent: pathParamsVaryPath\n                }\n            };\n            return patchedVaryPath;\n        }\n    }\n    // The request does vary on search params. We don't need to modify anything.\n    return originalVaryPath;\n}\nfunction clonePageVaryPathWithNewSearchParams(originalVaryPath, newSearch) {\n    // requestKey -> searchParams -> pathParams\n    //               ^ This part gets replaced with newSearch\n    const searchParamsVaryPath = originalVaryPath.parent;\n    const clonedVaryPath = {\n        value: originalVaryPath.value,\n        parent: {\n            value: newSearch,\n            parent: searchParamsVaryPath.parent\n        }\n    };\n    return clonedVaryPath;\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=vary-path.js.map","/**\n * For a given page path, this function ensures that there is a leading slash.\n * If there is not a leading slash, one is added, otherwise it is noop.\n */ \"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"ensureLeadingSlash\", {\n    enumerable: true,\n    get: function() {\n        return ensureLeadingSlash;\n    }\n});\nfunction ensureLeadingSlash(path) {\n    return path.startsWith('/') ? path : `/${path}`;\n}\n\n//# sourceMappingURL=ensure-leading-slash.js.map","import { ensureLeadingSlash } from '../../page-path/ensure-leading-slash'\nimport { isGroupSegment } from '../../segment'\n\n/**\n * Normalizes an app route so it represents the actual request path. Essentially\n * performing the following transformations:\n *\n * - `/(dashboard)/user/[id]/page` to `/user/[id]`\n * - `/(dashboard)/account/page` to `/account`\n * - `/user/[id]/page` to `/user/[id]`\n * - `/account/page` to `/account`\n * - `/page` to `/`\n * - `/(dashboard)/user/[id]/route` to `/user/[id]`\n * - `/(dashboard)/account/route` to `/account`\n * - `/user/[id]/route` to `/user/[id]`\n * - `/account/route` to `/account`\n * - `/route` to `/`\n * - `/` to `/`\n *\n * @param route the app route to normalize\n * @returns the normalized pathname\n */\nexport function normalizeAppPath(route: string) {\n  return ensureLeadingSlash(\n    route.split('/').reduce((pathname, segment, index, segments) => {\n      // Empty segments are ignored.\n      if (!segment) {\n        return pathname\n      }\n\n      // Groups are ignored.\n      if (isGroupSegment(segment)) {\n        return pathname\n      }\n\n      // Parallel segments are ignored.\n      if (segment[0] === '@') {\n        return pathname\n      }\n\n      // The last segment (if it's a leaf) should be ignored.\n      if (\n        (segment === 'page' || segment === 'route') &&\n        index === segments.length - 1\n      ) {\n        return pathname\n      }\n\n      return `${pathname}/${segment}`\n    }, '')\n  )\n}\n\n/**\n * Strips the `.rsc` extension if it's in the pathname.\n * Since this function is used on full urls it checks `?` for searchParams handling.\n */\nexport function normalizeRscURL(url: string) {\n  return url.replace(\n    /\\.rsc($|\\?)/,\n    // $1 ensures `?` is preserved\n    '$1'\n  )\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    INTERCEPTION_ROUTE_MARKERS: null,\n    extractInterceptionRouteInformation: null,\n    isInterceptionRouteAppPath: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    INTERCEPTION_ROUTE_MARKERS: function() {\n        return INTERCEPTION_ROUTE_MARKERS;\n    },\n    extractInterceptionRouteInformation: function() {\n        return extractInterceptionRouteInformation;\n    },\n    isInterceptionRouteAppPath: function() {\n        return isInterceptionRouteAppPath;\n    }\n});\nconst _apppaths = require(\"./app-paths\");\nconst INTERCEPTION_ROUTE_MARKERS = [\n    '(..)(..)',\n    '(.)',\n    '(..)',\n    '(...)'\n];\nfunction isInterceptionRouteAppPath(path) {\n    // TODO-APP: add more serious validation\n    return path.split('/').find((segment)=>INTERCEPTION_ROUTE_MARKERS.find((m)=>segment.startsWith(m))) !== undefined;\n}\nfunction extractInterceptionRouteInformation(path) {\n    let interceptingRoute;\n    let marker;\n    let interceptedRoute;\n    for (const segment of path.split('/')){\n        marker = INTERCEPTION_ROUTE_MARKERS.find((m)=>segment.startsWith(m));\n        if (marker) {\n            ;\n            [interceptingRoute, interceptedRoute] = path.split(marker, 2);\n            break;\n        }\n    }\n    if (!interceptingRoute || !marker || !interceptedRoute) {\n        throw Object.defineProperty(new Error(`Invalid interception route: ${path}. Must be in the format /<intercepting route>/(..|...|..)(..)/<intercepted route>`), \"__NEXT_ERROR_CODE\", {\n            value: \"E269\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    interceptingRoute = (0, _apppaths.normalizeAppPath)(interceptingRoute) // normalize the path, e.g. /(blog)/feed -> /feed\n    ;\n    switch(marker){\n        case '(.)':\n            // (.) indicates that we should match with sibling routes, so we just need to append the intercepted route to the intercepting route\n            if (interceptingRoute === '/') {\n                interceptedRoute = `/${interceptedRoute}`;\n            } else {\n                interceptedRoute = interceptingRoute + '/' + interceptedRoute;\n            }\n            break;\n        case '(..)':\n            // (..) indicates that we should match at one level up, so we need to remove the last segment of the intercepting route\n            if (interceptingRoute === '/') {\n                throw Object.defineProperty(new Error(`Invalid interception route: ${path}. Cannot use (..) marker at the root level, use (.) instead.`), \"__NEXT_ERROR_CODE\", {\n                    value: \"E207\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n            interceptedRoute = interceptingRoute.split('/').slice(0, -1).concat(interceptedRoute).join('/');\n            break;\n        case '(...)':\n            // (...) will match the route segment in the root directory, so we need to use the root directory to prepend the intercepted route\n            interceptedRoute = '/' + interceptedRoute;\n            break;\n        case '(..)(..)':\n            // (..)(..) indicates that we should match at two levels up, so we need to remove the last two segments of the intercepting route\n            const splitInterceptingRoute = interceptingRoute.split('/');\n            if (splitInterceptingRoute.length <= 2) {\n                throw Object.defineProperty(new Error(`Invalid interception route: ${path}. Cannot use (..)(..) marker at the root level or one level up.`), \"__NEXT_ERROR_CODE\", {\n                    value: \"E486\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n            interceptedRoute = splitInterceptingRoute.slice(0, -2).concat(interceptedRoute).join('/');\n            break;\n        default:\n            throw Object.defineProperty(new Error('Invariant: unexpected marker'), \"__NEXT_ERROR_CODE\", {\n                value: \"E112\",\n                enumerable: false,\n                configurable: true\n            });\n    }\n    return {\n        interceptingRoute,\n        interceptedRoute\n    };\n}\n\n//# sourceMappingURL=interception-routes.js.map","import type {\n  FlightRouterState,\n  Segment,\n} from '../../../shared/lib/app-router-types'\nimport { INTERCEPTION_ROUTE_MARKERS } from '../../../shared/lib/router/utils/interception-routes'\nimport type { Params } from '../../../server/request/params'\nimport {\n  isGroupSegment,\n  DEFAULT_SEGMENT_KEY,\n  PAGE_SEGMENT_KEY,\n} from '../../../shared/lib/segment'\nimport { matchSegment } from '../match-segments'\n\nconst removeLeadingSlash = (segment: string): string => {\n  return segment[0] === '/' ? segment.slice(1) : segment\n}\n\nconst segmentToPathname = (segment: Segment): string => {\n  if (typeof segment === 'string') {\n    // 'children' is not a valid path -- it's technically a parallel route that corresponds with the current segment's page\n    // if we don't skip it, then the computed pathname might be something like `/children` which doesn't make sense.\n    if (segment === 'children') return ''\n\n    return segment\n  }\n\n  return segment[1]\n}\n\nfunction normalizeSegments(segments: string[]): string {\n  return (\n    segments.reduce((acc, segment) => {\n      segment = removeLeadingSlash(segment)\n      if (segment === '' || isGroupSegment(segment)) {\n        return acc\n      }\n\n      return `${acc}/${segment}`\n    }, '') || '/'\n  )\n}\n\nexport function extractPathFromFlightRouterState(\n  flightRouterState: FlightRouterState\n): string | undefined {\n  const segment = Array.isArray(flightRouterState[0])\n    ? flightRouterState[0][1]\n    : flightRouterState[0]\n\n  if (\n    segment === DEFAULT_SEGMENT_KEY ||\n    INTERCEPTION_ROUTE_MARKERS.some((m) => segment.startsWith(m))\n  )\n    return undefined\n\n  if (segment.startsWith(PAGE_SEGMENT_KEY)) return ''\n\n  const segments = [segmentToPathname(segment)]\n  const parallelRoutes = flightRouterState[1] ?? {}\n\n  const childrenPath = parallelRoutes.children\n    ? extractPathFromFlightRouterState(parallelRoutes.children)\n    : undefined\n\n  if (childrenPath !== undefined) {\n    segments.push(childrenPath)\n  } else {\n    for (const [key, value] of Object.entries(parallelRoutes)) {\n      if (key === 'children') continue\n\n      const childPath = extractPathFromFlightRouterState(value)\n\n      if (childPath !== undefined) {\n        segments.push(childPath)\n      }\n    }\n  }\n\n  return normalizeSegments(segments)\n}\n\nfunction computeChangedPathImpl(\n  treeA: FlightRouterState,\n  treeB: FlightRouterState\n): string | null {\n  const [segmentA, parallelRoutesA] = treeA\n  const [segmentB, parallelRoutesB] = treeB\n\n  const normalizedSegmentA = segmentToPathname(segmentA)\n  const normalizedSegmentB = segmentToPathname(segmentB)\n\n  if (\n    INTERCEPTION_ROUTE_MARKERS.some(\n      (m) =>\n        normalizedSegmentA.startsWith(m) || normalizedSegmentB.startsWith(m)\n    )\n  ) {\n    return ''\n  }\n\n  if (!matchSegment(segmentA, segmentB)) {\n    // once we find where the tree changed, we compute the rest of the path by traversing the tree\n    return extractPathFromFlightRouterState(treeB) ?? ''\n  }\n\n  for (const parallelRouterKey in parallelRoutesA) {\n    if (parallelRoutesB[parallelRouterKey]) {\n      const changedPath = computeChangedPathImpl(\n        parallelRoutesA[parallelRouterKey],\n        parallelRoutesB[parallelRouterKey]\n      )\n      if (changedPath !== null) {\n        return `${segmentToPathname(segmentB)}/${changedPath}`\n      }\n    }\n  }\n\n  return null\n}\n\nexport function computeChangedPath(\n  treeA: FlightRouterState,\n  treeB: FlightRouterState\n): string | null {\n  const changedPath = computeChangedPathImpl(treeA, treeB)\n\n  if (changedPath == null || changedPath === '/') {\n    return changedPath\n  }\n\n  // lightweight normalization to remove route groups\n  return normalizeSegments(changedPath.split('/'))\n}\n\n/**\n * Recursively extracts dynamic parameters from FlightRouterState.\n */\nexport function getSelectedParams(\n  currentTree: FlightRouterState,\n  params: Params = {}\n): Params {\n  const parallelRoutes = currentTree[1]\n\n  for (const parallelRoute of Object.values(parallelRoutes)) {\n    const segment = parallelRoute[0]\n    const isDynamicParameter = Array.isArray(segment)\n    const segmentValue = isDynamicParameter ? segment[1] : segment\n    if (!segmentValue || segmentValue.startsWith(PAGE_SEGMENT_KEY)) continue\n\n    // Ensure catchAll and optional catchall are turned into an array\n    const isCatchAll =\n      isDynamicParameter && (segment[2] === 'c' || segment[2] === 'oc')\n\n    if (isCatchAll) {\n      params[segment[0]] = segment[1].split('/')\n    } else if (isDynamicParameter) {\n      params[segment[0]] = segment[1]\n    }\n\n    params = getSelectedParams(parallelRoute, params)\n  }\n\n  return params\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"handleMutable\", {\n    enumerable: true,\n    get: function() {\n        return handleMutable;\n    }\n});\nconst _computechangedpath = require(\"./compute-changed-path\");\nfunction isNotUndefined(value) {\n    return typeof value !== 'undefined';\n}\nfunction handleMutable(state, mutable) {\n    // shouldScroll is true by default, can override to false.\n    const shouldScroll = mutable.shouldScroll ?? true;\n    let previousNextUrl = state.previousNextUrl;\n    let nextUrl = state.nextUrl;\n    if (isNotUndefined(mutable.patchedTree)) {\n        // If we received a patched tree, we need to compute the changed path.\n        const changedPath = (0, _computechangedpath.computeChangedPath)(state.tree, mutable.patchedTree);\n        if (changedPath) {\n            // If the tree changed, we need to update the nextUrl\n            previousNextUrl = nextUrl;\n            nextUrl = changedPath;\n        } else if (!nextUrl) {\n            // if the tree ends up being the same (ie, no changed path), and we don't have a nextUrl, then we should use the canonicalUrl\n            nextUrl = state.canonicalUrl;\n        }\n    // otherwise this will be a no-op and continue to use the existing nextUrl\n    }\n    return {\n        // Set href.\n        canonicalUrl: mutable.canonicalUrl ?? state.canonicalUrl,\n        renderedSearch: mutable.renderedSearch ?? state.renderedSearch,\n        pushRef: {\n            pendingPush: isNotUndefined(mutable.pendingPush) ? mutable.pendingPush : state.pushRef.pendingPush,\n            mpaNavigation: isNotUndefined(mutable.mpaNavigation) ? mutable.mpaNavigation : state.pushRef.mpaNavigation,\n            preserveCustomHistoryState: isNotUndefined(mutable.preserveCustomHistoryState) ? mutable.preserveCustomHistoryState : state.pushRef.preserveCustomHistoryState\n        },\n        // All navigation requires scroll and focus management to trigger.\n        focusAndScrollRef: {\n            apply: shouldScroll ? isNotUndefined(mutable?.scrollableSegments) ? true : state.focusAndScrollRef.apply : false,\n            onlyHashChange: mutable.onlyHashChange || false,\n            hashFragment: shouldScroll ? // #top is handled in layout-router.\n            mutable.hashFragment && mutable.hashFragment !== '' ? decodeURIComponent(mutable.hashFragment.slice(1)) : state.focusAndScrollRef.hashFragment : null,\n            segmentPaths: shouldScroll ? mutable?.scrollableSegments ?? state.focusAndScrollRef.segmentPaths : []\n        },\n        // Apply cache.\n        cache: mutable.cache ? mutable.cache : state.cache,\n        // Apply patched router state.\n        tree: isNotUndefined(mutable.patchedTree) ? mutable.patchedTree : state.tree,\n        nextUrl,\n        previousNextUrl: previousNextUrl,\n        debugInfo: mutable.collectedDebugInfo ?? null\n    };\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=handle-mutable.js.map","import type { Segment } from '../../../shared/lib/app-router-types'\nimport { PAGE_SEGMENT_KEY } from '../../../shared/lib/segment'\n\nexport function createRouterCacheKey(\n  segment: Segment,\n  withoutSearchParameters: boolean = false\n) {\n  // if the segment is an array, it means it's a dynamic segment\n  // for example, ['lang', 'en', 'd']. We need to convert it to a string to store it as a cache node key.\n  if (Array.isArray(segment)) {\n    return `${segment[0]}|${segment[1]}|${segment[2]}`\n  }\n\n  // Page segments might have search parameters, ie __PAGE__?foo=bar\n  // When `withoutSearchParameters` is true, we only want to return the page segment\n  if (withoutSearchParameters && segment.startsWith(PAGE_SEGMENT_KEY)) {\n    return PAGE_SEGMENT_KEY\n  }\n\n  return segment\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"isNavigatingToNewRootLayout\", {\n    enumerable: true,\n    get: function() {\n        return isNavigatingToNewRootLayout;\n    }\n});\nfunction isNavigatingToNewRootLayout(currentTree, nextTree) {\n    // Compare segments\n    const currentTreeSegment = currentTree[0];\n    const nextTreeSegment = nextTree[0];\n    // If any segment is different before we find the root layout, the root layout has changed.\n    // E.g. /same/(group1)/layout.js -> /same/(group2)/layout.js\n    // First segment is 'same' for both, keep looking. (group1) changed to (group2) before the root layout was found, it must have changed.\n    if (Array.isArray(currentTreeSegment) && Array.isArray(nextTreeSegment)) {\n        // Compare dynamic param name and type but ignore the value, different values would not affect the current root layout\n        // /[name] - /slug1 and /slug2, both values (slug1 & slug2) still has the same layout /[name]/layout.js\n        if (currentTreeSegment[0] !== nextTreeSegment[0] || currentTreeSegment[2] !== nextTreeSegment[2]) {\n            return true;\n        }\n    } else if (currentTreeSegment !== nextTreeSegment) {\n        return true;\n    }\n    // Current tree root layout found\n    if (currentTree[4]) {\n        // If the next tree doesn't have the root layout flag, it must have changed.\n        return !nextTree[4];\n    }\n    // Current tree didn't have its root layout here, must have changed.\n    if (nextTree[4]) {\n        return true;\n    }\n    // We can't assume it's `parallelRoutes.children` here in case the root layout is `app/@something/layout.js`\n    // But it's not possible to be more than one parallelRoutes before the root layout is found\n    // TODO-APP: change to traverse all parallel routes\n    const currentTreeChild = Object.values(currentTree[1])[0];\n    const nextTreeChild = Object.values(nextTree[1])[0];\n    if (!currentTreeChild || !nextTreeChild) return true;\n    return isNavigatingToNewRootLayout(currentTreeChild, nextTreeChild);\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=is-navigating-to-new-root-layout.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    FreshnessPolicy: null,\n    createInitialCacheNodeForHydration: null,\n    isDeferredRsc: null,\n    spawnDynamicRequests: null,\n    startPPRNavigation: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    FreshnessPolicy: function() {\n        return FreshnessPolicy;\n    },\n    createInitialCacheNodeForHydration: function() {\n        return createInitialCacheNodeForHydration;\n    },\n    isDeferredRsc: function() {\n        return isDeferredRsc;\n    },\n    spawnDynamicRequests: function() {\n        return spawnDynamicRequests;\n    },\n    startPPRNavigation: function() {\n        return startPPRNavigation;\n    }\n});\nconst _segment = require(\"../../../shared/lib/segment\");\nconst _matchsegments = require(\"../match-segments\");\nconst _createhreffromurl = require(\"./create-href-from-url\");\nconst _createroutercachekey = require(\"./create-router-cache-key\");\nconst _fetchserverresponse = require(\"./fetch-server-response\");\nconst _useactionqueue = require(\"../use-action-queue\");\nconst _routerreducertypes = require(\"./router-reducer-types\");\nconst _isnavigatingtonewrootlayout = require(\"./is-navigating-to-new-root-layout\");\nconst _navigatereducer = require(\"./reducers/navigate-reducer\");\nconst _navigation = require(\"../segment-cache/navigation\");\nvar FreshnessPolicy = /*#__PURE__*/ function(FreshnessPolicy) {\n    FreshnessPolicy[FreshnessPolicy[\"Default\"] = 0] = \"Default\";\n    FreshnessPolicy[FreshnessPolicy[\"Hydration\"] = 1] = \"Hydration\";\n    FreshnessPolicy[FreshnessPolicy[\"HistoryTraversal\"] = 2] = \"HistoryTraversal\";\n    FreshnessPolicy[FreshnessPolicy[\"RefreshAll\"] = 3] = \"RefreshAll\";\n    FreshnessPolicy[FreshnessPolicy[\"HMRRefresh\"] = 4] = \"HMRRefresh\";\n    return FreshnessPolicy;\n}({});\nconst noop = ()=>{};\nfunction createInitialCacheNodeForHydration(navigatedAt, initialTree, seedData, seedHead) {\n    // Create the initial cache node tree, using the data embedded into the\n    // HTML document.\n    const accumulation = {\n        scrollableSegments: null,\n        separateRefreshUrls: null\n    };\n    const task = createCacheNodeOnNavigation(navigatedAt, initialTree, undefined, 1, seedData, seedHead, null, null, false, null, null, false, accumulation);\n    // NOTE: We intentionally don't check if any data needs to be fetched from the\n    // server. We assume the initial hydration payload is sufficient to render\n    // the page.\n    //\n    // The completeness of the initial data is an important property that we rely\n    // on as a last-ditch mechanism for recovering the app; we must always be able\n    // to reload a fresh HTML document to get to a consistent state.\n    //\n    // In the future, there may be cases where the server intentionally sends\n    // partial data and expects the client to fill in the rest, in which case this\n    // logic may change. (There already is a similar case where the server sends\n    // _no_ hydration data in the HTML document at all, and the client fetches it\n    // separately, but that's different because we still end up hydrating with a\n    // complete tree.)\n    return task.node;\n}\nfunction startPPRNavigation(navigatedAt, oldUrl, oldCacheNode, oldRouterState, newRouterState, freshness, seedData, seedHead, prefetchData, prefetchHead, isPrefetchHeadPartial, isSamePageNavigation, accumulation) {\n    const didFindRootLayout = false;\n    const parentNeedsDynamicRequest = false;\n    const parentRefreshUrl = null;\n    return updateCacheNodeOnNavigation(navigatedAt, oldUrl, oldCacheNode !== null ? oldCacheNode : undefined, oldRouterState, newRouterState, freshness, didFindRootLayout, seedData, seedHead, prefetchData, prefetchHead, isPrefetchHeadPartial, isSamePageNavigation, null, null, parentNeedsDynamicRequest, parentRefreshUrl, accumulation);\n}\nfunction updateCacheNodeOnNavigation(navigatedAt, oldUrl, oldCacheNode, oldRouterState, newRouterState, freshness, didFindRootLayout, seedData, seedHead, prefetchData, prefetchHead, isPrefetchHeadPartial, isSamePageNavigation, parentSegmentPath, parentParallelRouteKey, parentNeedsDynamicRequest, parentRefreshUrl, accumulation) {\n    // Check if this segment matches the one in the previous route.\n    const oldSegment = oldRouterState[0];\n    const newSegment = newRouterState[0];\n    if (!(0, _matchsegments.matchSegment)(newSegment, oldSegment)) {\n        // This segment does not match the previous route. We're now entering the\n        // new part of the target route. Switch to the \"create\" path.\n        if (// Check if the route tree changed before we reached a layout. (The\n        // highest-level layout in a route tree is referred to as the \"root\"\n        // layout.) This could mean that we're navigating between two different\n        // root layouts. When this happens, we perform a full-page (MPA-style)\n        // navigation.\n        //\n        // However, the algorithm for deciding where to start rendering a route\n        // (i.e. the one performed in order to reach this function) is stricter\n        // than the one used to detect a change in the root layout. So just\n        // because we're re-rendering a segment outside of the root layout does\n        // not mean we should trigger a full-page navigation.\n        //\n        // Specifically, we handle dynamic parameters differently: two segments\n        // are considered the same even if their parameter values are different.\n        //\n        // Refer to isNavigatingToNewRootLayout for details.\n        //\n        // Note that we only have to perform this extra traversal if we didn't\n        // already discover a root layout in the part of the tree that is\n        // unchanged. We also only need to compare the subtree that is not\n        // shared. In the common case, this branch is skipped completely.\n        !didFindRootLayout && (0, _isnavigatingtonewrootlayout.isNavigatingToNewRootLayout)(oldRouterState, newRouterState) || // The global Not Found route (app/global-not-found.tsx) is a special\n        // case, because it acts like a root layout, but in the router tree, it\n        // is rendered in the same position as app/layout.tsx.\n        //\n        // Any navigation to the global Not Found route should trigger a\n        // full-page navigation.\n        //\n        // TODO: We should probably model this by changing the key of the root\n        // segment when this happens. Then the root layout check would work\n        // as expected, without a special case.\n        newSegment === _segment.NOT_FOUND_SEGMENT_KEY) {\n            return null;\n        }\n        if (parentSegmentPath === null || parentParallelRouteKey === null) {\n            // The root should never mismatch. If it does, it suggests an internal\n            // Next.js error, or a malformed server response. Trigger a full-\n            // page navigation.\n            return null;\n        }\n        return createCacheNodeOnNavigation(navigatedAt, newRouterState, oldCacheNode, freshness, seedData, seedHead, prefetchData, prefetchHead, isPrefetchHeadPartial, parentSegmentPath, parentParallelRouteKey, parentNeedsDynamicRequest, accumulation);\n    }\n    // TODO: The segment paths are tracked so that LayoutRouter knows which\n    // segments to scroll to after a navigation. But we should just mark this\n    // information on the CacheNode directly. It used to be necessary to do this\n    // separately because CacheNodes were created lazily during render, not when\n    // rather than when creating the route tree.\n    const segmentPath = parentParallelRouteKey !== null && parentSegmentPath !== null ? parentSegmentPath.concat([\n        parentParallelRouteKey,\n        newSegment\n    ]) : [];\n    const newRouterStateChildren = newRouterState[1];\n    const oldRouterStateChildren = oldRouterState[1];\n    const seedDataChildren = seedData !== null ? seedData[1] : null;\n    const prefetchDataChildren = prefetchData !== null ? prefetchData[1] : null;\n    // We're currently traversing the part of the tree that was also part of\n    // the previous route. If we discover a root layout, then we don't need to\n    // trigger an MPA navigation.\n    const isRootLayout = newRouterState[4] === true;\n    const childDidFindRootLayout = didFindRootLayout || isRootLayout;\n    const oldParallelRoutes = oldCacheNode !== undefined ? oldCacheNode.parallelRoutes : undefined;\n    // Clone the current set of segment children, even if they aren't active in\n    // the new tree.\n    // TODO: We currently retain all the inactive segments indefinitely, until\n    // there's an explicit refresh, or a parent layout is lazily refreshed. We\n    // rely on this for popstate navigations, which update the Router State Tree\n    // but do not eagerly perform a data fetch, because they expect the segment\n    // data to already be in the Cache Node tree. For highly static sites that\n    // are mostly read-only, this may happen only rarely, causing memory to\n    // leak. We should figure out a better model for the lifetime of inactive\n    // segments, so we can maintain instant back/forward navigations without\n    // leaking memory indefinitely.\n    let shouldDropSiblingCaches = false;\n    let shouldRefreshDynamicData = false;\n    switch(freshness){\n        case 0:\n        case 2:\n        case 1:\n            // We should never drop dynamic data in shared layouts, except during\n            // a refresh.\n            shouldDropSiblingCaches = false;\n            shouldRefreshDynamicData = false;\n            break;\n        case 3:\n        case 4:\n            shouldDropSiblingCaches = true;\n            shouldRefreshDynamicData = true;\n            break;\n        default:\n            freshness;\n            break;\n    }\n    const newParallelRoutes = new Map(shouldDropSiblingCaches ? undefined : oldParallelRoutes);\n    // TODO: We're not consistent about how we do this check. Some places\n    // check if the segment starts with PAGE_SEGMENT_KEY, but most seem to\n    // check if there any any children, which is why I'm doing it here. We\n    // should probably encode an empty children set as `null` though. Either\n    // way, we should update all the checks to be consistent.\n    const isLeafSegment = Object.keys(newRouterStateChildren).length === 0;\n    // Get the data for this segment. Since it was part of the previous route,\n    // usually we just clone the data from the old CacheNode. However, during a\n    // refresh or a revalidation, there won't be any existing CacheNode. So we\n    // may need to consult the prefetch cache, like we would for a new segment.\n    let newCacheNode;\n    let needsDynamicRequest;\n    if (oldCacheNode !== undefined && !shouldRefreshDynamicData && // During a same-page navigation, we always refetch the page segments\n    !(isLeafSegment && isSamePageNavigation)) {\n        // Reuse the existing CacheNode\n        const dropPrefetchRsc = false;\n        newCacheNode = reuseDynamicCacheNode(dropPrefetchRsc, oldCacheNode, newParallelRoutes);\n        needsDynamicRequest = false;\n    } else if (seedData !== null && seedData[0] !== null) {\n        // If this navigation was the result of an action, then check if the\n        // server sent back data in the action response. We should favor using\n        // that, rather than performing a separate request. This is both better\n        // for performance and it's more likely to be consistent with any\n        // writes that were just performed by the action, compared to a\n        // separate request.\n        const seedRsc = seedData[0];\n        const seedLoading = seedData[2];\n        const isSeedRscPartial = false;\n        const isSeedHeadPartial = seedHead === null;\n        newCacheNode = readCacheNodeFromSeedData(seedRsc, seedLoading, isSeedRscPartial, seedHead, isSeedHeadPartial, isLeafSegment, newParallelRoutes, navigatedAt);\n        needsDynamicRequest = isLeafSegment && isSeedHeadPartial;\n    } else if (prefetchData !== null) {\n        // Consult the prefetch cache.\n        const prefetchRsc = prefetchData[0];\n        const prefetchLoading = prefetchData[2];\n        const isPrefetchRSCPartial = prefetchData[3];\n        newCacheNode = readCacheNodeFromSeedData(prefetchRsc, prefetchLoading, isPrefetchRSCPartial, prefetchHead, isPrefetchHeadPartial, isLeafSegment, newParallelRoutes, navigatedAt);\n        needsDynamicRequest = isPrefetchRSCPartial || isLeafSegment && isPrefetchHeadPartial;\n    } else {\n        // Spawn a request to fetch new data from the server.\n        newCacheNode = spawnNewCacheNode(newParallelRoutes, isLeafSegment, navigatedAt, freshness);\n        needsDynamicRequest = true;\n    }\n    // During a refresh navigation, there's a special case that happens when\n    // entering a \"default\" slot. The default slot may not be part of the\n    // current route; it may have been reused from an older route. If so,\n    // we need to fetch its data from the old route's URL rather than current\n    // route's URL. Keep track of this as we traverse the tree.\n    const href = newRouterState[2];\n    const refreshUrl = typeof href === 'string' && newRouterState[3] === 'refresh' ? // refresh URL as we continue traversing the tree.\n    href : parentRefreshUrl;\n    // If this segment itself needs to fetch new data from the server, then by\n    // definition it is being refreshed. Track its refresh URL so we know which\n    // URL to request the data from.\n    if (needsDynamicRequest && refreshUrl !== null) {\n        accumulateRefreshUrl(accumulation, refreshUrl);\n    }\n    // As we diff the trees, we may sometimes modify (copy-on-write, not mutate)\n    // the Route Tree that was returned by the server — for example, in the case\n    // of default parallel routes, we preserve the currently active segment. To\n    // avoid mutating the original tree, we clone the router state children along\n    // the return path.\n    let patchedRouterStateChildren = {};\n    let taskChildren = null;\n    // Most navigations require a request to fetch additional data from the\n    // server, either because the data was not already prefetched, or because the\n    // target route contains dynamic data that cannot be prefetched.\n    //\n    // However, if the target route is fully static, and it's already completely\n    // loaded into the segment cache, then we can skip the server request.\n    //\n    // This starts off as `false`, and is set to `true` if any of the child\n    // routes requires a dynamic request.\n    let childNeedsDynamicRequest = false;\n    // As we traverse the children, we'll construct a FlightRouterState that can\n    // be sent to the server to request the dynamic data. If it turns out that\n    // nothing in the subtree is dynamic (i.e. childNeedsDynamicRequest is false\n    // at the end), then this will be discarded.\n    // TODO: We can probably optimize the format of this data structure to only\n    // include paths that are dynamic. Instead of reusing the\n    // FlightRouterState type.\n    let dynamicRequestTreeChildren = {};\n    for(let parallelRouteKey in newRouterStateChildren){\n        let newRouterStateChild = newRouterStateChildren[parallelRouteKey];\n        const oldRouterStateChild = oldRouterStateChildren[parallelRouteKey];\n        if (oldRouterStateChild === undefined) {\n            // This should never happen, but if it does, it suggests a malformed\n            // server response. Trigger a full-page navigation.\n            return null;\n        }\n        const oldSegmentMapChild = oldParallelRoutes !== undefined ? oldParallelRoutes.get(parallelRouteKey) : undefined;\n        let seedDataChild = seedDataChildren !== null ? seedDataChildren[parallelRouteKey] : null;\n        let prefetchDataChild = prefetchDataChildren !== null ? prefetchDataChildren[parallelRouteKey] : null;\n        let newSegmentChild = newRouterStateChild[0];\n        let seedHeadChild = seedHead;\n        let prefetchHeadChild = prefetchHead;\n        let isPrefetchHeadPartialChild = isPrefetchHeadPartial;\n        if (// Skip this branch during a history traversal. We restore the tree that\n        // was stashed in the history entry as-is.\n        freshness !== 2 && newSegmentChild === _segment.DEFAULT_SEGMENT_KEY) {\n            // This is a \"default\" segment. These are never sent by the server during\n            // a soft navigation; instead, the client reuses whatever segment was\n            // already active in that slot on the previous route.\n            newRouterStateChild = reuseActiveSegmentInDefaultSlot(oldUrl, oldRouterStateChild);\n            newSegmentChild = newRouterStateChild[0];\n            // Since we're switching to a different route tree, these are no\n            // longer valid, because they correspond to the outer tree.\n            seedDataChild = null;\n            seedHeadChild = null;\n            prefetchDataChild = null;\n            prefetchHeadChild = null;\n            isPrefetchHeadPartialChild = false;\n        }\n        const newSegmentKeyChild = (0, _createroutercachekey.createRouterCacheKey)(newSegmentChild);\n        const oldCacheNodeChild = oldSegmentMapChild !== undefined ? oldSegmentMapChild.get(newSegmentKeyChild) : undefined;\n        const taskChild = updateCacheNodeOnNavigation(navigatedAt, oldUrl, oldCacheNodeChild, oldRouterStateChild, newRouterStateChild, freshness, childDidFindRootLayout, seedDataChild ?? null, seedHeadChild, prefetchDataChild ?? null, prefetchHeadChild, isPrefetchHeadPartialChild, isSamePageNavigation, segmentPath, parallelRouteKey, parentNeedsDynamicRequest || needsDynamicRequest, refreshUrl, accumulation);\n        if (taskChild === null) {\n            // One of the child tasks discovered a change to the root layout.\n            // Immediately unwind from this recursive traversal. This will trigger a\n            // full-page navigation.\n            return null;\n        }\n        // Recursively propagate up the child tasks.\n        if (taskChildren === null) {\n            taskChildren = new Map();\n        }\n        taskChildren.set(parallelRouteKey, taskChild);\n        const newCacheNodeChild = taskChild.node;\n        if (newCacheNodeChild !== null) {\n            const newSegmentMapChild = new Map(shouldDropSiblingCaches ? undefined : oldSegmentMapChild);\n            newSegmentMapChild.set(newSegmentKeyChild, newCacheNodeChild);\n            newParallelRoutes.set(parallelRouteKey, newSegmentMapChild);\n        }\n        // The child tree's route state may be different from the prefetched\n        // route sent by the server. We need to clone it as we traverse back up\n        // the tree.\n        const taskChildRoute = taskChild.route;\n        patchedRouterStateChildren[parallelRouteKey] = taskChildRoute;\n        const dynamicRequestTreeChild = taskChild.dynamicRequestTree;\n        if (dynamicRequestTreeChild !== null) {\n            // Something in the child tree is dynamic.\n            childNeedsDynamicRequest = true;\n            dynamicRequestTreeChildren[parallelRouteKey] = dynamicRequestTreeChild;\n        } else {\n            dynamicRequestTreeChildren[parallelRouteKey] = taskChildRoute;\n        }\n    }\n    return {\n        status: needsDynamicRequest ? 0 : 1,\n        route: patchRouterStateWithNewChildren(newRouterState, patchedRouterStateChildren),\n        node: newCacheNode,\n        dynamicRequestTree: createDynamicRequestTree(newRouterState, dynamicRequestTreeChildren, needsDynamicRequest, childNeedsDynamicRequest, parentNeedsDynamicRequest),\n        refreshUrl,\n        children: taskChildren\n    };\n}\nfunction createCacheNodeOnNavigation(navigatedAt, newRouterState, oldCacheNode, freshness, seedData, seedHead, prefetchData, prefetchHead, isPrefetchHeadPartial, parentSegmentPath, parentParallelRouteKey, parentNeedsDynamicRequest, accumulation) {\n    // Same traversal as updateCacheNodeNavigation, but simpler. We switch to this\n    // path once we reach the part of the tree that was not in the previous route.\n    // We don't need to diff against the old tree, we just need to create a new\n    // one. We also don't need to worry about any refresh-related logic.\n    //\n    // For the most part, this is a subset of updateCacheNodeOnNavigation, so any\n    // change that happens in this function likely needs to be applied to that\n    // one, too. However there are some places where the behavior intentionally\n    // diverges, which is why we keep them separate.\n    const newSegment = newRouterState[0];\n    const segmentPath = parentParallelRouteKey !== null && parentSegmentPath !== null ? parentSegmentPath.concat([\n        parentParallelRouteKey,\n        newSegment\n    ]) : [];\n    const newRouterStateChildren = newRouterState[1];\n    const prefetchDataChildren = prefetchData !== null ? prefetchData[1] : null;\n    const seedDataChildren = seedData !== null ? seedData[1] : null;\n    const oldParallelRoutes = oldCacheNode !== undefined ? oldCacheNode.parallelRoutes : undefined;\n    let shouldDropSiblingCaches = false;\n    let shouldRefreshDynamicData = false;\n    let dropPrefetchRsc = false;\n    switch(freshness){\n        case 0:\n            // We should never drop dynamic data in sibling caches except during\n            // a refresh.\n            shouldDropSiblingCaches = false;\n            // Only reuse the dynamic data if experimental.staleTimes.dynamic config\n            // is set, and the data is not stale. (This is not a recommended API with\n            // Cache Components, but it's supported for backwards compatibility. Use\n            // cacheLife instead.)\n            //\n            // DYNAMIC_STALETIME_MS defaults to 0, but it can be increased.\n            shouldRefreshDynamicData = oldCacheNode === undefined || navigatedAt - oldCacheNode.navigatedAt >= _navigatereducer.DYNAMIC_STALETIME_MS;\n            dropPrefetchRsc = false;\n            break;\n        case 1:\n            // During hydration, we assume the data sent by the server is both\n            // consistent and complete.\n            shouldRefreshDynamicData = false;\n            shouldDropSiblingCaches = false;\n            dropPrefetchRsc = false;\n            break;\n        case 2:\n            // During back/forward navigations, we reuse the dynamic data regardless\n            // of how stale it may be.\n            shouldRefreshDynamicData = false;\n            shouldRefreshDynamicData = false;\n            // Only show prefetched data if the dynamic data is still pending. This\n            // avoids a flash back to the prefetch state in a case where it's highly\n            // likely to have already streamed in.\n            //\n            // Tehnically, what we're actually checking is whether the dynamic network\n            // response was received. But since it's a streaming response, this does\n            // not mean that all the dynamic data has fully streamed in. It just means\n            // that _some_ of the dynamic data was received. But as a heuristic, we\n            // assume that the rest dynamic data will stream in quickly, so it's still\n            // better to skip the prefetch state.\n            if (oldCacheNode !== undefined) {\n                const oldRsc = oldCacheNode.rsc;\n                const oldRscDidResolve = !isDeferredRsc(oldRsc) || oldRsc.status !== 'pending';\n                dropPrefetchRsc = oldRscDidResolve;\n            } else {\n                dropPrefetchRsc = false;\n            }\n            break;\n        case 3:\n        case 4:\n            // Drop all dynamic data.\n            shouldRefreshDynamicData = true;\n            shouldDropSiblingCaches = true;\n            dropPrefetchRsc = false;\n            break;\n        default:\n            freshness;\n            break;\n    }\n    const newParallelRoutes = new Map(shouldDropSiblingCaches ? undefined : oldParallelRoutes);\n    const isLeafSegment = Object.keys(newRouterStateChildren).length === 0;\n    if (isLeafSegment) {\n        // The segment path of every leaf segment (i.e. page) is collected into\n        // a result array. This is used by the LayoutRouter to scroll to ensure that\n        // new pages are visible after a navigation.\n        //\n        // This only happens for new pages, not for refreshed pages.\n        //\n        // TODO: We should use a string to represent the segment path instead of\n        // an array. We already use a string representation for the path when\n        // accessing the Segment Cache, so we can use the same one.\n        if (accumulation.scrollableSegments === null) {\n            accumulation.scrollableSegments = [];\n        }\n        accumulation.scrollableSegments.push(segmentPath);\n    }\n    let newCacheNode;\n    let needsDynamicRequest;\n    if (!shouldRefreshDynamicData && oldCacheNode !== undefined) {\n        // Reuse the existing CacheNode\n        newCacheNode = reuseDynamicCacheNode(dropPrefetchRsc, oldCacheNode, newParallelRoutes);\n        needsDynamicRequest = false;\n    } else if (seedData !== null && seedData[0] !== null) {\n        // If this navigation was the result of an action, then check if the\n        // server sent back data in the action response. We should favor using\n        // that, rather than performing a separate request. This is both better\n        // for performance and it's more likely to be consistent with any\n        // writes that were just performed by the action, compared to a\n        // separate request.\n        const seedRsc = seedData[0];\n        const seedLoading = seedData[2];\n        const isSeedRscPartial = false;\n        const isSeedHeadPartial = seedHead === null && freshness !== 1;\n        newCacheNode = readCacheNodeFromSeedData(seedRsc, seedLoading, isSeedRscPartial, seedHead, isSeedHeadPartial, isLeafSegment, newParallelRoutes, navigatedAt);\n        needsDynamicRequest = isLeafSegment && isSeedHeadPartial;\n    } else if (freshness === 1 && isLeafSegment && seedHead !== null) {\n        // This is another weird case related to \"not found\" pages and hydration.\n        // There will be a head sent by the server, but no page seed data.\n        // TODO: We really should get rid of all these \"not found\" specific quirks\n        // and make sure the tree is always consistent.\n        const seedRsc = null;\n        const seedLoading = null;\n        const isSeedRscPartial = false;\n        const isSeedHeadPartial = false;\n        newCacheNode = readCacheNodeFromSeedData(seedRsc, seedLoading, isSeedRscPartial, seedHead, isSeedHeadPartial, isLeafSegment, newParallelRoutes, navigatedAt);\n        needsDynamicRequest = false;\n    } else if (freshness !== 1 && prefetchData !== null) {\n        // Consult the prefetch cache.\n        const prefetchRsc = prefetchData[0];\n        const prefetchLoading = prefetchData[2];\n        const isPrefetchRSCPartial = prefetchData[3];\n        newCacheNode = readCacheNodeFromSeedData(prefetchRsc, prefetchLoading, isPrefetchRSCPartial, prefetchHead, isPrefetchHeadPartial, isLeafSegment, newParallelRoutes, navigatedAt);\n        needsDynamicRequest = isPrefetchRSCPartial || isLeafSegment && isPrefetchHeadPartial;\n    } else {\n        // Spawn a request to fetch new data from the server.\n        newCacheNode = spawnNewCacheNode(newParallelRoutes, isLeafSegment, navigatedAt, freshness);\n        needsDynamicRequest = true;\n    }\n    let patchedRouterStateChildren = {};\n    let taskChildren = null;\n    let childNeedsDynamicRequest = false;\n    let dynamicRequestTreeChildren = {};\n    for(let parallelRouteKey in newRouterStateChildren){\n        const newRouterStateChild = newRouterStateChildren[parallelRouteKey];\n        const oldSegmentMapChild = oldParallelRoutes !== undefined ? oldParallelRoutes.get(parallelRouteKey) : undefined;\n        const seedDataChild = seedDataChildren !== null ? seedDataChildren[parallelRouteKey] : null;\n        const prefetchDataChild = prefetchDataChildren !== null ? prefetchDataChildren[parallelRouteKey] : null;\n        const newSegmentChild = newRouterStateChild[0];\n        const newSegmentKeyChild = (0, _createroutercachekey.createRouterCacheKey)(newSegmentChild);\n        const oldCacheNodeChild = oldSegmentMapChild !== undefined ? oldSegmentMapChild.get(newSegmentKeyChild) : undefined;\n        const taskChild = createCacheNodeOnNavigation(navigatedAt, newRouterStateChild, oldCacheNodeChild, freshness, seedDataChild ?? null, seedHead, prefetchDataChild ?? null, prefetchHead, isPrefetchHeadPartial, segmentPath, parallelRouteKey, parentNeedsDynamicRequest || needsDynamicRequest, accumulation);\n        if (taskChildren === null) {\n            taskChildren = new Map();\n        }\n        taskChildren.set(parallelRouteKey, taskChild);\n        const newCacheNodeChild = taskChild.node;\n        if (newCacheNodeChild !== null) {\n            const newSegmentMapChild = new Map(shouldDropSiblingCaches ? undefined : oldSegmentMapChild);\n            newSegmentMapChild.set(newSegmentKeyChild, newCacheNodeChild);\n            newParallelRoutes.set(parallelRouteKey, newSegmentMapChild);\n        }\n        const taskChildRoute = taskChild.route;\n        patchedRouterStateChildren[parallelRouteKey] = taskChildRoute;\n        const dynamicRequestTreeChild = taskChild.dynamicRequestTree;\n        if (dynamicRequestTreeChild !== null) {\n            childNeedsDynamicRequest = true;\n            dynamicRequestTreeChildren[parallelRouteKey] = dynamicRequestTreeChild;\n        } else {\n            dynamicRequestTreeChildren[parallelRouteKey] = taskChildRoute;\n        }\n    }\n    return {\n        status: needsDynamicRequest ? 0 : 1,\n        route: patchRouterStateWithNewChildren(newRouterState, patchedRouterStateChildren),\n        node: newCacheNode,\n        dynamicRequestTree: createDynamicRequestTree(newRouterState, dynamicRequestTreeChildren, needsDynamicRequest, childNeedsDynamicRequest, parentNeedsDynamicRequest),\n        // This route is not part of the current tree, so there's no reason to\n        // track the refresh URL.\n        refreshUrl: null,\n        children: taskChildren\n    };\n}\nfunction patchRouterStateWithNewChildren(baseRouterState, newChildren) {\n    const clone = [\n        baseRouterState[0],\n        newChildren\n    ];\n    // Based on equivalent logic in apply-router-state-patch-to-tree, but should\n    // confirm whether we need to copy all of these fields. Not sure the server\n    // ever sends, e.g. the refetch marker.\n    if (2 in baseRouterState) {\n        clone[2] = baseRouterState[2];\n    }\n    if (3 in baseRouterState) {\n        clone[3] = baseRouterState[3];\n    }\n    if (4 in baseRouterState) {\n        clone[4] = baseRouterState[4];\n    }\n    return clone;\n}\nfunction createDynamicRequestTree(newRouterState, dynamicRequestTreeChildren, needsDynamicRequest, childNeedsDynamicRequest, parentNeedsDynamicRequest) {\n    // Create a FlightRouterState that instructs the server how to render the\n    // requested segment.\n    //\n    // Or, if neither this segment nor any of the children require a new data,\n    // then we return `null` to skip the request.\n    let dynamicRequestTree = null;\n    if (needsDynamicRequest) {\n        dynamicRequestTree = patchRouterStateWithNewChildren(newRouterState, dynamicRequestTreeChildren);\n        // The \"refetch\" marker is set on the top-most segment that requires new\n        // data. We can omit it if a parent was already marked.\n        if (!parentNeedsDynamicRequest) {\n            dynamicRequestTree[3] = 'refetch';\n        }\n    } else if (childNeedsDynamicRequest) {\n        // This segment does not request new data, but at least one of its\n        // children does.\n        dynamicRequestTree = patchRouterStateWithNewChildren(newRouterState, dynamicRequestTreeChildren);\n    } else {\n        dynamicRequestTree = null;\n    }\n    return dynamicRequestTree;\n}\nfunction accumulateRefreshUrl(accumulation, refreshUrl) {\n    // This is a refresh navigation, and we're inside a \"default\" slot that's\n    // not part of the current route; it was reused from an older route. In\n    // order to get fresh data for this reused route, we need to issue a\n    // separate request using the old route's URL.\n    //\n    // Track these extra URLs in the accumulated result. Later, we'll construct\n    // an appropriate request for each unique URL in the final set. The reason\n    // we don't do it immediately here is so we can deduplicate multiple\n    // instances of the same URL into a single request. See\n    // listenForDynamicRequest for more details.\n    const separateRefreshUrls = accumulation.separateRefreshUrls;\n    if (separateRefreshUrls === null) {\n        accumulation.separateRefreshUrls = new Set([\n            refreshUrl\n        ]);\n    } else {\n        separateRefreshUrls.add(refreshUrl);\n    }\n}\nfunction reuseActiveSegmentInDefaultSlot(oldUrl, oldRouterState) {\n    // This is a \"default\" segment. These are never sent by the server during a\n    // soft navigation; instead, the client reuses whatever segment was already\n    // active in that slot on the previous route. This means if we later need to\n    // refresh the segment, it will have to be refetched from the previous route's\n    // URL. We store it in the Flight Router State.\n    //\n    // TODO: We also mark the segment with a \"refresh\" marker but I think we can\n    // get rid of that eventually by making sure we only add URLs to page segments\n    // that are reused. Then the presence of the URL alone is enough.\n    let reusedRouterState;\n    const oldRefreshMarker = oldRouterState[3];\n    if (oldRefreshMarker === 'refresh') {\n        // This segment was already reused from an even older route. Keep its\n        // existing URL and refresh marker.\n        reusedRouterState = oldRouterState;\n    } else {\n        // This segment was not previously reused, and it's not on the new route.\n        // So it must have been delivered in the old route.\n        reusedRouterState = patchRouterStateWithNewChildren(oldRouterState, oldRouterState[1]);\n        reusedRouterState[2] = (0, _createhreffromurl.createHrefFromUrl)(oldUrl);\n        reusedRouterState[3] = 'refresh';\n    }\n    return reusedRouterState;\n}\nfunction reuseDynamicCacheNode(dropPrefetchRsc, existingCacheNode, parallelRoutes) {\n    // Clone an existing CacheNode's data, with (possibly) new children.\n    const cacheNode = {\n        rsc: existingCacheNode.rsc,\n        prefetchRsc: dropPrefetchRsc ? null : existingCacheNode.prefetchRsc,\n        head: existingCacheNode.head,\n        prefetchHead: dropPrefetchRsc ? null : existingCacheNode.prefetchHead,\n        loading: existingCacheNode.loading,\n        parallelRoutes,\n        // Don't update the navigatedAt timestamp, since we're reusing\n        // existing data.\n        navigatedAt: existingCacheNode.navigatedAt\n    };\n    return cacheNode;\n}\nfunction readCacheNodeFromSeedData(seedRsc, seedLoading, isSeedRscPartial, seedHead, isSeedHeadPartial, isPageSegment, parallelRoutes, navigatedAt) {\n    // TODO: Currently this is threaded through the navigation logic using the\n    // CacheNodeSeedData type, but in the future this will read directly from\n    // the Segment Cache. See readRenderSnapshotFromCache.\n    let rsc;\n    let prefetchRsc;\n    if (isSeedRscPartial) {\n        // The prefetched data contains dynamic holes. Create a pending promise that\n        // will be fulfilled when the dynamic data is received from the server.\n        prefetchRsc = seedRsc;\n        rsc = createDeferredRsc();\n    } else {\n        // The prefetched data is complete. Use it directly.\n        prefetchRsc = null;\n        rsc = seedRsc;\n    }\n    // If this is a page segment, also read the head.\n    let prefetchHead;\n    let head;\n    if (isPageSegment) {\n        if (isSeedHeadPartial) {\n            prefetchHead = seedHead;\n            head = createDeferredRsc();\n        } else {\n            prefetchHead = null;\n            head = seedHead;\n        }\n    } else {\n        prefetchHead = null;\n        head = null;\n    }\n    const cacheNode = {\n        rsc,\n        prefetchRsc,\n        head,\n        prefetchHead,\n        // TODO: Technically, a loading boundary could contain dynamic data. We\n        // should have separate `loading` and `prefetchLoading` fields to handle\n        // this, like we do for the segment data and head.\n        loading: seedLoading,\n        parallelRoutes,\n        navigatedAt\n    };\n    return cacheNode;\n}\nfunction spawnNewCacheNode(parallelRoutes, isLeafSegment, navigatedAt, freshness) {\n    // We should never spawn network requests during hydration. We must treat the\n    // initial payload as authoritative, because the initial page load is used\n    // as a last-ditch mechanism for recovering the app.\n    //\n    // This is also an important safety check because if this leaks into the\n    // server rendering path (which theoretically it never should because\n    // the server payload should be consistent), the server would hang because\n    // these promises would never resolve.\n    //\n    // TODO: There is an existing case where the global \"not found\" boundary\n    // triggers this path. But it does render correctly despite that. That's an\n    // unusual render path so it's not surprising, but we should look into\n    // modeling it in a more consistent way. See also the /_notFound special\n    // case in updateCacheNodeOnNavigation.\n    const isHydration = freshness === 1;\n    const cacheNode = {\n        rsc: !isHydration ? createDeferredRsc() : null,\n        prefetchRsc: null,\n        head: !isHydration && isLeafSegment ? createDeferredRsc() : null,\n        prefetchHead: null,\n        loading: !isHydration ? createDeferredRsc() : null,\n        parallelRoutes,\n        navigatedAt\n    };\n    return cacheNode;\n}\n// Represents whether the previuos navigation resulted in a route tree mismatch.\n// A mismatch results in a refresh of the page. If there are two successive\n// mismatches, we will fall back to an MPA navigation, to prevent a retry loop.\nlet previousNavigationDidMismatch = false;\nfunction spawnDynamicRequests(task, primaryUrl, nextUrl, freshnessPolicy, accumulation) {\n    const dynamicRequestTree = task.dynamicRequestTree;\n    if (dynamicRequestTree === null) {\n        // This navigation was fully cached. There are no dynamic requests to spawn.\n        previousNavigationDidMismatch = false;\n        return;\n    }\n    // This is intentionally not an async function to discourage the caller from\n    // awaiting the result. Any subsequent async operations spawned by this\n    // function should result in a separate navigation task, rather than\n    // block the original one.\n    //\n    // In this function we spawn (but do not await) all the network requests that\n    // block the navigation, and collect the promises. The next function,\n    // `finishNavigationTask`, can await the promises in any order without\n    // accidentally introducing a network waterfall.\n    const primaryRequestPromise = fetchMissingDynamicData(task, dynamicRequestTree, primaryUrl, nextUrl, freshnessPolicy);\n    const separateRefreshUrls = accumulation.separateRefreshUrls;\n    let refreshRequestPromises = null;\n    if (separateRefreshUrls !== null) {\n        // There are multiple URLs that we need to request the data from. This\n        // happens when a \"default\" parallel route slot is present in the tree, and\n        // its data cannot be fetched from the current route. We need to split the\n        // combined dynamic request tree into separate requests per URL.\n        // TODO: Create a scoped dynamic request tree that omits anything that\n        // is not relevant to the given URL. Without doing this, the server may\n        // sometimes render more data than necessary; this is not a regression\n        // compared to the pre-Segment Cache implementation, though, just an\n        // optimization we can make in the future.\n        // Construct a request tree for each additional refresh URL. This will\n        // prune away everything except the parts of the tree that match the\n        // given refresh URL.\n        refreshRequestPromises = [];\n        const canonicalUrl = (0, _createhreffromurl.createHrefFromUrl)(primaryUrl);\n        for (const refreshUrl of separateRefreshUrls){\n            if (refreshUrl === canonicalUrl) {\n                continue;\n            }\n            // TODO: Create a scoped dynamic request tree that omits anything that\n            // is not relevant to the given URL. Without doing this, the server may\n            // sometimes render more data than necessary; this is not a regression\n            // compared to the pre-Segment Cache implementation, though, just an\n            // optimization we can make in the future.\n            // const scopedDynamicRequestTree = splitTaskByURL(task, refreshUrl)\n            const scopedDynamicRequestTree = dynamicRequestTree;\n            if (scopedDynamicRequestTree !== null) {\n                refreshRequestPromises.push(fetchMissingDynamicData(task, scopedDynamicRequestTree, new URL(refreshUrl, location.origin), // TODO: Just noticed that this should actually the Next-Url at the\n                // time the refresh URL was set, not the current Next-Url. Need to\n                // start tracking this alongside the refresh URL. In the meantime,\n                // if a refresh fails due to a mismatch, it will trigger a\n                // hard refresh.\n                nextUrl, freshnessPolicy));\n            }\n        }\n    }\n    // Further async operations are moved into this separate function to\n    // discourage sequential network requests.\n    const voidPromise = finishNavigationTask(task, nextUrl, primaryRequestPromise, refreshRequestPromises);\n    // `finishNavigationTask` is responsible for error handling, so we can attach\n    // noop callbacks to this promise.\n    voidPromise.then(noop, noop);\n}\nasync function finishNavigationTask(task, nextUrl, primaryRequestPromise, refreshRequestPromises) {\n    // Wait for all the requests to finish, or for the first one to fail.\n    let exitStatus = await waitForRequestsToFinish(primaryRequestPromise, refreshRequestPromises);\n    // Once the all the requests have finished, check the tree for any remaining\n    // pending tasks. If anything is still pending, it means the server response\n    // does not match the client, and we must refresh to get back to a consistent\n    // state. We can skip this step if we already detected a mismatch during the\n    // first phase; it doesn't matter in that case because we're going to refresh\n    // the whole tree regardless.\n    if (exitStatus === 0) {\n        exitStatus = abortRemainingPendingTasks(task, null, null);\n    }\n    switch(exitStatus){\n        case 0:\n            {\n                // The task has completely finished. There's no missing data. Exit.\n                previousNavigationDidMismatch = false;\n                return;\n            }\n        case 1:\n            {\n                // Some data failed to finish loading. Trigger a soft retry.\n                // TODO: As an extra precaution against soft retry loops, consider\n                // tracking whether a navigation was itself triggered by a retry. If two\n                // happen in a row, fall back to a hard retry.\n                const isHardRetry = false;\n                const primaryRequestResult = await primaryRequestPromise;\n                dispatchRetryDueToTreeMismatch(isHardRetry, primaryRequestResult.url, nextUrl, primaryRequestResult.seed, task.route);\n                return;\n            }\n        case 2:\n            {\n                // Some data failed to finish loading in a non-recoverable way, such as a\n                // network error. Trigger an MPA navigation.\n                //\n                // Hard navigating/refreshing is how we prevent an infinite retry loop\n                // caused by a network error — when the network fails, we fall back to the\n                // browser behavior for offline navigations. In the future, Next.js may\n                // introduce its own custom handling of offline navigations, but that\n                // doesn't exist yet.\n                const isHardRetry = true;\n                const primaryRequestResult = await primaryRequestPromise;\n                dispatchRetryDueToTreeMismatch(isHardRetry, primaryRequestResult.url, nextUrl, primaryRequestResult.seed, task.route);\n                return;\n            }\n        default:\n            {\n                return exitStatus;\n            }\n    }\n}\nfunction waitForRequestsToFinish(primaryRequestPromise, refreshRequestPromises) {\n    // Custom async combinator logic. This could be replaced by Promise.any but\n    // we don't assume that's available.\n    //\n    // Each promise resolves once the server responsds and the data is written\n    // into the CacheNode tree. Resolve the combined promise once all the\n    // requests finish.\n    //\n    // Or, resolve as soon as one of the requests fails, without waiting for the\n    // others to finish.\n    return new Promise((resolve)=>{\n        const onFulfill = (result)=>{\n            if (result.exitStatus === 0) {\n                remainingCount--;\n                if (remainingCount === 0) {\n                    // All the requests finished successfully.\n                    resolve(0);\n                }\n            } else {\n                // One of the requests failed. Exit with a failing status.\n                // NOTE: It's possible for one of the requests to fail with SoftRetry\n                // and a later one to fail with HardRetry. In this case, we choose to\n                // retry immediately, rather than delay the retry until all the requests\n                // finish. If it fails again, we will hard retry on the next\n                // attempt, anyway.\n                resolve(result.exitStatus);\n            }\n        };\n        // onReject shouldn't ever be called because fetchMissingDynamicData's\n        // entire body is wrapped in a try/catch. This is just defensive.\n        const onReject = ()=>resolve(2);\n        // Attach the listeners to the promises.\n        let remainingCount = 1;\n        primaryRequestPromise.then(onFulfill, onReject);\n        if (refreshRequestPromises !== null) {\n            remainingCount += refreshRequestPromises.length;\n            refreshRequestPromises.forEach((refreshRequestPromise)=>refreshRequestPromise.then(onFulfill, onReject));\n        }\n    });\n}\nfunction dispatchRetryDueToTreeMismatch(isHardRetry, retryUrl, retryNextUrl, seed, baseTree) {\n    // If this is the second time in a row that a navigation resulted in a\n    // mismatch, fall back to a hard (MPA) refresh.\n    isHardRetry = isHardRetry || previousNavigationDidMismatch;\n    previousNavigationDidMismatch = true;\n    const retryAction = {\n        type: _routerreducertypes.ACTION_SERVER_PATCH,\n        previousTree: baseTree,\n        url: retryUrl,\n        nextUrl: retryNextUrl,\n        seed,\n        mpa: isHardRetry\n    };\n    (0, _useactionqueue.dispatchAppRouterAction)(retryAction);\n}\nasync function fetchMissingDynamicData(task, dynamicRequestTree, url, nextUrl, freshnessPolicy) {\n    try {\n        const result = await (0, _fetchserverresponse.fetchServerResponse)(url, {\n            flightRouterState: dynamicRequestTree,\n            nextUrl,\n            isHmrRefresh: freshnessPolicy === 4\n        });\n        if (typeof result === 'string') {\n            // fetchServerResponse will return an href to indicate that the SPA\n            // navigation failed. For example, if the server triggered a hard\n            // redirect, or the fetch request errored. Initiate an MPA navigation\n            // to the given href.\n            return {\n                exitStatus: 2,\n                url: new URL(result, location.origin),\n                seed: null\n            };\n        }\n        const seed = (0, _navigation.convertServerPatchToFullTree)(task.route, result.flightData, result.renderedSearch);\n        const didReceiveUnknownParallelRoute = writeDynamicDataIntoNavigationTask(task, seed.tree, seed.data, seed.head, result.debugInfo);\n        return {\n            exitStatus: didReceiveUnknownParallelRoute ? 1 : 0,\n            url: new URL(result.canonicalUrl, location.origin),\n            seed\n        };\n    } catch  {\n        // This shouldn't happen because fetchServerResponse's entire body is\n        // wrapped in a try/catch. If it does, though, it implies the server failed\n        // to respond with any tree at all. So we must fall back to a hard retry.\n        return {\n            exitStatus: 2,\n            url: url,\n            seed: null\n        };\n    }\n}\nfunction writeDynamicDataIntoNavigationTask(task, serverRouterState, dynamicData, dynamicHead, debugInfo) {\n    if (task.status === 0 && dynamicData !== null) {\n        task.status = 1;\n        finishPendingCacheNode(task.node, dynamicData, dynamicHead, debugInfo);\n    }\n    const taskChildren = task.children;\n    const serverChildren = serverRouterState[1];\n    const dynamicDataChildren = dynamicData !== null ? dynamicData[1] : null;\n    // Detect whether the server sends a parallel route slot that the client\n    // doesn't know about.\n    let didReceiveUnknownParallelRoute = false;\n    if (taskChildren !== null) {\n        for(const parallelRouteKey in serverChildren){\n            const serverRouterStateChild = serverChildren[parallelRouteKey];\n            const dynamicDataChild = dynamicDataChildren !== null ? dynamicDataChildren[parallelRouteKey] : null;\n            const taskChild = taskChildren.get(parallelRouteKey);\n            if (taskChild === undefined) {\n                // The server sent a child segment that the client doesn't know about.\n                //\n                // When we receive an unknown parallel route, we must consider it a\n                // mismatch. This is unlike the case where the segment itself\n                // mismatches, because multiple routes can be active simultaneously.\n                // But a given layout should never have a mismatching set of\n                // child slots.\n                //\n                // Theoretically, this should only happen in development during an HMR\n                // refresh, because the set of parallel routes for a layout does not\n                // change over the lifetime of a build/deployment. In production, we\n                // should have already mismatched on either the build id or the segment\n                // path. But as an extra precaution, we validate in prod, too.\n                didReceiveUnknownParallelRoute = true;\n            } else {\n                const taskSegment = taskChild.route[0];\n                if ((0, _matchsegments.matchSegment)(serverRouterStateChild[0], taskSegment) && dynamicDataChild !== null && dynamicDataChild !== undefined) {\n                    // Found a match for this task. Keep traversing down the task tree.\n                    const childDidReceiveUnknownParallelRoute = writeDynamicDataIntoNavigationTask(taskChild, serverRouterStateChild, dynamicDataChild, dynamicHead, debugInfo);\n                    if (childDidReceiveUnknownParallelRoute) {\n                        didReceiveUnknownParallelRoute = true;\n                    }\n                }\n            }\n        }\n    }\n    return didReceiveUnknownParallelRoute;\n}\nfunction finishPendingCacheNode(cacheNode, dynamicData, dynamicHead, debugInfo) {\n    // Writes a dynamic response into an existing Cache Node tree. This does _not_\n    // create a new tree, it updates the existing tree in-place. So it must follow\n    // the Suspense rules of cache safety — it can resolve pending promises, but\n    // it cannot overwrite existing data. It can add segments to the tree (because\n    // a missing segment will cause the layout router to suspend).\n    // but it cannot delete them.\n    //\n    // We must resolve every promise in the tree, or else it will suspend\n    // indefinitely. If we did not receive data for a segment, we will resolve its\n    // data promise to `null` to trigger a lazy fetch during render.\n    // Use the dynamic data from the server to fulfill the deferred RSC promise\n    // on the Cache Node.\n    const rsc = cacheNode.rsc;\n    const dynamicSegmentData = dynamicData[0];\n    if (dynamicSegmentData === null) {\n        // This is an empty CacheNode; this particular server request did not\n        // render this segment. There may be a separate pending request that will,\n        // though, so we won't abort the task until all pending requests finish.\n        return;\n    }\n    if (rsc === null) {\n        // This is a lazy cache node. We can overwrite it. This is only safe\n        // because we know that the LayoutRouter suspends if `rsc` is `null`.\n        cacheNode.rsc = dynamicSegmentData;\n    } else if (isDeferredRsc(rsc)) {\n        // This is a deferred RSC promise. We can fulfill it with the data we just\n        // received from the server. If it was already resolved by a different\n        // navigation, then this does nothing because we can't overwrite data.\n        rsc.resolve(dynamicSegmentData, debugInfo);\n    } else {\n    // This is not a deferred RSC promise, nor is it empty, so it must have\n    // been populated by a different navigation. We must not overwrite it.\n    }\n    // If we navigated without a prefetch, then `loading` will be a deferred promise too.\n    // Fulfill it using the dynamic response so that we can display the loading boundary.\n    const loading = cacheNode.loading;\n    if (isDeferredRsc(loading)) {\n        const dynamicLoading = dynamicData[2];\n        loading.resolve(dynamicLoading, debugInfo);\n    }\n    // Check if this is a leaf segment. If so, it will have a `head` property with\n    // a pending promise that needs to be resolved with the dynamic head from\n    // the server.\n    const head = cacheNode.head;\n    if (isDeferredRsc(head)) {\n        head.resolve(dynamicHead, debugInfo);\n    }\n}\nfunction abortRemainingPendingTasks(task, error, debugInfo) {\n    let exitStatus;\n    if (task.status === 0) {\n        // The data for this segment is still missing.\n        task.status = 2;\n        abortPendingCacheNode(task.node, error, debugInfo);\n        // If the server failed to fulfill the data for this segment, it implies\n        // that the route tree received from the server mismatched the tree that\n        // was previously prefetched.\n        //\n        // In an app with fully static routes and no proxy-driven redirects or\n        // rewrites, this should never happen, because the route for a URL would\n        // always be the same across multiple requests. So, this implies that some\n        // runtime routing condition changed, likely in a proxy, without being\n        // pushed to the client.\n        //\n        // When this happens, we treat this the same as a refresh(). The entire\n        // tree will be re-rendered from the root.\n        if (task.refreshUrl === null) {\n            // Trigger a \"soft\" refresh. Essentially the same as calling `refresh()`\n            // in a Server Action.\n            exitStatus = 1;\n        } else {\n            // The mismatch was discovered inside an inactive parallel route. This\n            // implies the inactive parallel route is no longer reachable at the URL\n            // that originally rendered it. Fall back to an MPA refresh.\n            // TODO: An alternative could be to trigger a soft refresh but to _not_\n            // re-use the inactive parallel routes this time. Similar to what would\n            // happen if were to do a hard refrehs, but without the HTML page.\n            exitStatus = 2;\n        }\n    } else {\n        // This segment finished. (An error here is treated as Done because they are\n        // surfaced to the application during render.)\n        exitStatus = 0;\n    }\n    const taskChildren = task.children;\n    if (taskChildren !== null) {\n        for (const [, taskChild] of taskChildren){\n            const childExitStatus = abortRemainingPendingTasks(taskChild, error, debugInfo);\n            // Propagate the exit status up the tree. The statuses are ordered by\n            // their precedence.\n            if (childExitStatus > exitStatus) {\n                exitStatus = childExitStatus;\n            }\n        }\n    }\n    return exitStatus;\n}\nfunction abortPendingCacheNode(cacheNode, error, debugInfo) {\n    const rsc = cacheNode.rsc;\n    if (isDeferredRsc(rsc)) {\n        if (error === null) {\n            // This will trigger a lazy fetch during render.\n            rsc.resolve(null, debugInfo);\n        } else {\n            // This will trigger an error during rendering.\n            rsc.reject(error, debugInfo);\n        }\n    }\n    const loading = cacheNode.loading;\n    if (isDeferredRsc(loading)) {\n        loading.resolve(null, debugInfo);\n    }\n    // Check if this is a leaf segment. If so, it will have a `head` property with\n    // a pending promise that needs to be resolved. If an error was provided, we\n    // will not resolve it with an error, since this is rendered at the root of\n    // the app. We want the segment to error, not the entire app.\n    const head = cacheNode.head;\n    if (isDeferredRsc(head)) {\n        head.resolve(null, debugInfo);\n    }\n}\nconst DEFERRED = Symbol();\nfunction isDeferredRsc(value) {\n    return value && typeof value === 'object' && value.tag === DEFERRED;\n}\nfunction createDeferredRsc() {\n    // Create an unresolved promise that represents data derived from a Flight\n    // response. The promise will be resolved later as soon as we start receiving\n    // data from the server, i.e. as soon as the Flight client decodes and returns\n    // the top-level response object.\n    // The `_debugInfo` field contains profiling information. Promises that are\n    // created by Flight already have this info added by React; for any derived\n    // promise created by the router, we need to transfer the Flight debug info\n    // onto the derived promise.\n    //\n    // The debug info represents the latency between the start of the navigation\n    // and the start of rendering. (It does not represent the time it takes for\n    // whole stream to finish.)\n    const debugInfo = [];\n    let resolve;\n    let reject;\n    const pendingRsc = new Promise((res, rej)=>{\n        resolve = res;\n        reject = rej;\n    });\n    pendingRsc.status = 'pending';\n    pendingRsc.resolve = (value, responseDebugInfo)=>{\n        if (pendingRsc.status === 'pending') {\n            const fulfilledRsc = pendingRsc;\n            fulfilledRsc.status = 'fulfilled';\n            fulfilledRsc.value = value;\n            if (responseDebugInfo !== null) {\n                // Transfer the debug info to the derived promise.\n                debugInfo.push.apply(debugInfo, responseDebugInfo);\n            }\n            resolve(value);\n        }\n    };\n    pendingRsc.reject = (error, responseDebugInfo)=>{\n        if (pendingRsc.status === 'pending') {\n            const rejectedRsc = pendingRsc;\n            rejectedRsc.status = 'rejected';\n            rejectedRsc.reason = error;\n            if (responseDebugInfo !== null) {\n                // Transfer the debug info to the derived promise.\n                debugInfo.push.apply(debugInfo, responseDebugInfo);\n            }\n            reject(error);\n        }\n    };\n    pendingRsc.tag = DEFERRED;\n    pendingRsc._debugInfo = debugInfo;\n    return pendingRsc;\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=ppr-navigations.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    convertServerPatchToFullTree: null,\n    navigate: null,\n    navigateToSeededRoute: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    convertServerPatchToFullTree: function() {\n        return convertServerPatchToFullTree;\n    },\n    navigate: function() {\n        return navigate;\n    },\n    navigateToSeededRoute: function() {\n        return navigateToSeededRoute;\n    }\n});\nconst _fetchserverresponse = require(\"../router-reducer/fetch-server-response\");\nconst _pprnavigations = require(\"../router-reducer/ppr-navigations\");\nconst _createhreffromurl = require(\"../router-reducer/create-href-from-url\");\nconst _cache = require(\"./cache\");\nconst _cachekey = require(\"./cache-key\");\nconst _segment = require(\"../../../shared/lib/segment\");\nconst _types = require(\"./types\");\nfunction navigate(url, currentUrl, currentCacheNode, currentFlightRouterState, nextUrl, freshnessPolicy, shouldScroll, accumulation) {\n    const now = Date.now();\n    const href = url.href;\n    // We special case navigations to the exact same URL as the current location.\n    // It's a common UI pattern for apps to refresh when you click a link to the\n    // current page. So when this happens, we refresh the dynamic data in the page\n    // segments.\n    //\n    // Note that this does not apply if the any part of the hash or search query\n    // has changed. This might feel a bit weird but it makes more sense when you\n    // consider that the way to trigger this behavior is to click the same link\n    // multiple times.\n    //\n    // TODO: We should probably refresh the *entire* route when this case occurs,\n    // not just the page segments. Essentially treating it the same as a refresh()\n    // triggered by an action, which is the more explicit way of modeling the UI\n    // pattern described above.\n    //\n    // Also note that this only refreshes the dynamic data, not static/ cached\n    // data. If the page segment is fully static and prefetched, the request is\n    // skipped. (This is also how refresh() works.)\n    const isSamePageNavigation = href === currentUrl.href;\n    const cacheKey = (0, _cachekey.createCacheKey)(href, nextUrl);\n    const route = (0, _cache.readRouteCacheEntry)(now, cacheKey);\n    if (route !== null && route.status === _cache.EntryStatus.Fulfilled) {\n        // We have a matching prefetch.\n        const snapshot = readRenderSnapshotFromCache(now, route, route.tree);\n        const prefetchFlightRouterState = snapshot.flightRouterState;\n        const prefetchSeedData = snapshot.seedData;\n        const headSnapshot = readHeadSnapshotFromCache(now, route);\n        const prefetchHead = headSnapshot.rsc;\n        const isPrefetchHeadPartial = headSnapshot.isPartial;\n        // TODO: The \"canonicalUrl\" stored in the cache doesn't include the hash,\n        // because hash entries do not vary by hash fragment. However, the one\n        // we set in the router state *does* include the hash, and it's used to\n        // sync with the actual browser location. To make this less of a refactor\n        // hazard, we should always track the hash separately from the rest of\n        // the URL.\n        const newCanonicalUrl = route.canonicalUrl + url.hash;\n        const renderedSearch = route.renderedSearch;\n        return navigateUsingPrefetchedRouteTree(now, url, currentUrl, nextUrl, isSamePageNavigation, currentCacheNode, currentFlightRouterState, prefetchFlightRouterState, prefetchSeedData, prefetchHead, isPrefetchHeadPartial, newCanonicalUrl, renderedSearch, freshnessPolicy, shouldScroll);\n    }\n    // There was no matching route tree in the cache. Let's see if we can\n    // construct an \"optimistic\" route tree.\n    //\n    // Do not construct an optimistic route tree if there was a cache hit, but\n    // the entry has a rejected status, since it may have been rejected due to a\n    // rewrite or redirect based on the search params.\n    //\n    // TODO: There are multiple reasons a prefetch might be rejected; we should\n    // track them explicitly and choose what to do here based on that.\n    if (route === null || route.status !== _cache.EntryStatus.Rejected) {\n        const optimisticRoute = (0, _cache.requestOptimisticRouteCacheEntry)(now, url, nextUrl);\n        if (optimisticRoute !== null) {\n            // We have an optimistic route tree. Proceed with the normal flow.\n            const snapshot = readRenderSnapshotFromCache(now, optimisticRoute, optimisticRoute.tree);\n            const prefetchFlightRouterState = snapshot.flightRouterState;\n            const prefetchSeedData = snapshot.seedData;\n            const headSnapshot = readHeadSnapshotFromCache(now, optimisticRoute);\n            const prefetchHead = headSnapshot.rsc;\n            const isPrefetchHeadPartial = headSnapshot.isPartial;\n            const newCanonicalUrl = optimisticRoute.canonicalUrl + url.hash;\n            const newRenderedSearch = optimisticRoute.renderedSearch;\n            return navigateUsingPrefetchedRouteTree(now, url, currentUrl, nextUrl, isSamePageNavigation, currentCacheNode, currentFlightRouterState, prefetchFlightRouterState, prefetchSeedData, prefetchHead, isPrefetchHeadPartial, newCanonicalUrl, newRenderedSearch, freshnessPolicy, shouldScroll);\n        }\n    }\n    // There's no matching prefetch for this route in the cache.\n    let collectedDebugInfo = accumulation.collectedDebugInfo ?? [];\n    if (accumulation.collectedDebugInfo === undefined) {\n        collectedDebugInfo = accumulation.collectedDebugInfo = [];\n    }\n    return {\n        tag: _types.NavigationResultTag.Async,\n        data: navigateDynamicallyWithNoPrefetch(now, url, currentUrl, nextUrl, currentCacheNode, currentFlightRouterState, freshnessPolicy, shouldScroll, collectedDebugInfo)\n    };\n}\nfunction navigateToSeededRoute(now, url, canonicalUrl, navigationSeed, currentUrl, currentCacheNode, currentFlightRouterState, freshnessPolicy, nextUrl, shouldScroll) {\n    // A version of navigate() that accepts the target route tree as an argument\n    // rather than reading it from the prefetch cache.\n    const accumulation = {\n        scrollableSegments: null,\n        separateRefreshUrls: null\n    };\n    const isSamePageNavigation = url.href === currentUrl.href;\n    const task = (0, _pprnavigations.startPPRNavigation)(now, currentUrl, currentCacheNode, currentFlightRouterState, navigationSeed.tree, freshnessPolicy, navigationSeed.data, navigationSeed.head, null, null, false, isSamePageNavigation, accumulation);\n    if (task !== null) {\n        (0, _pprnavigations.spawnDynamicRequests)(task, url, nextUrl, freshnessPolicy, accumulation);\n        return navigationTaskToResult(task, canonicalUrl, navigationSeed.renderedSearch, accumulation.scrollableSegments, shouldScroll, url.hash);\n    }\n    // Could not perform a SPA navigation. Revert to a full-page (MPA) navigation.\n    return {\n        tag: _types.NavigationResultTag.MPA,\n        data: canonicalUrl\n    };\n}\nfunction navigateUsingPrefetchedRouteTree(now, url, currentUrl, nextUrl, isSamePageNavigation, currentCacheNode, currentFlightRouterState, prefetchFlightRouterState, prefetchSeedData, prefetchHead, isPrefetchHeadPartial, canonicalUrl, renderedSearch, freshnessPolicy, shouldScroll) {\n    // Recursively construct a prefetch tree by reading from the Segment Cache. To\n    // maintain compatibility, we output the same data structures as the old\n    // prefetching implementation: FlightRouterState and CacheNodeSeedData.\n    // TODO: Eventually updateCacheNodeOnNavigation (or the equivalent) should\n    // read from the Segment Cache directly. It's only structured this way for now\n    // so we can share code with the old prefetching implementation.\n    const accumulation = {\n        scrollableSegments: null,\n        separateRefreshUrls: null\n    };\n    const seedData = null;\n    const seedHead = null;\n    const task = (0, _pprnavigations.startPPRNavigation)(now, currentUrl, currentCacheNode, currentFlightRouterState, prefetchFlightRouterState, freshnessPolicy, seedData, seedHead, prefetchSeedData, prefetchHead, isPrefetchHeadPartial, isSamePageNavigation, accumulation);\n    if (task !== null) {\n        (0, _pprnavigations.spawnDynamicRequests)(task, url, nextUrl, freshnessPolicy, accumulation);\n        return navigationTaskToResult(task, canonicalUrl, renderedSearch, accumulation.scrollableSegments, shouldScroll, url.hash);\n    }\n    // Could not perform a SPA navigation. Revert to a full-page (MPA) navigation.\n    return {\n        tag: _types.NavigationResultTag.MPA,\n        data: canonicalUrl\n    };\n}\nfunction navigationTaskToResult(task, canonicalUrl, renderedSearch, scrollableSegments, shouldScroll, hash) {\n    return {\n        tag: _types.NavigationResultTag.Success,\n        data: {\n            flightRouterState: task.route,\n            cacheNode: task.node,\n            canonicalUrl,\n            renderedSearch,\n            scrollableSegments,\n            shouldScroll,\n            hash\n        }\n    };\n}\nfunction readRenderSnapshotFromCache(now, route, tree) {\n    let childRouterStates = {};\n    let childSeedDatas = {};\n    const slots = tree.slots;\n    if (slots !== null) {\n        for(const parallelRouteKey in slots){\n            const childTree = slots[parallelRouteKey];\n            const childResult = readRenderSnapshotFromCache(now, route, childTree);\n            childRouterStates[parallelRouteKey] = childResult.flightRouterState;\n            childSeedDatas[parallelRouteKey] = childResult.seedData;\n        }\n    }\n    let rsc = null;\n    let loading = null;\n    let isPartial = true;\n    const segmentEntry = (0, _cache.readSegmentCacheEntry)(now, tree.varyPath);\n    if (segmentEntry !== null) {\n        switch(segmentEntry.status){\n            case _cache.EntryStatus.Fulfilled:\n                {\n                    // Happy path: a cache hit\n                    rsc = segmentEntry.rsc;\n                    loading = segmentEntry.loading;\n                    isPartial = segmentEntry.isPartial;\n                    break;\n                }\n            case _cache.EntryStatus.Pending:\n                {\n                    // We haven't received data for this segment yet, but there's already\n                    // an in-progress request. Since it's extremely likely to arrive\n                    // before the dynamic data response, we might as well use it.\n                    const promiseForFulfilledEntry = (0, _cache.waitForSegmentCacheEntry)(segmentEntry);\n                    rsc = promiseForFulfilledEntry.then((entry)=>entry !== null ? entry.rsc : null);\n                    loading = promiseForFulfilledEntry.then((entry)=>entry !== null ? entry.loading : null);\n                    // Because the request is still pending, we typically don't know yet\n                    // whether the response will be partial. We shouldn't skip this segment\n                    // during the dynamic navigation request. Otherwise, we might need to\n                    // do yet another request to fill in the remaining data, creating\n                    // a waterfall.\n                    //\n                    // The one exception is if this segment is being fetched with via\n                    // prefetch={true} (i.e. the \"force stale\" or \"full\" strategy). If so,\n                    // we can assume the response will be full. This field is set to `false`\n                    // for such segments.\n                    isPartial = segmentEntry.isPartial;\n                    break;\n                }\n            case _cache.EntryStatus.Empty:\n            case _cache.EntryStatus.Rejected:\n                break;\n            default:\n                segmentEntry;\n        }\n    }\n    // The navigation implementation expects the search params to be\n    // included in the segment. However, the Segment Cache tracks search\n    // params separately from the rest of the segment key. So we need to\n    // add them back here.\n    //\n    // See corresponding comment in convertFlightRouterStateToTree.\n    //\n    // TODO: What we should do instead is update the navigation diffing\n    // logic to compare search params explicitly. This is a temporary\n    // solution until more of the Segment Cache implementation has settled.\n    const segment = (0, _segment.addSearchParamsIfPageSegment)(tree.segment, Object.fromEntries(new URLSearchParams(route.renderedSearch)));\n    // We don't need this information in a render snapshot, so this can just be a placeholder.\n    const hasRuntimePrefetch = false;\n    return {\n        flightRouterState: [\n            segment,\n            childRouterStates,\n            null,\n            null,\n            tree.isRootLayout\n        ],\n        seedData: [\n            rsc,\n            childSeedDatas,\n            loading,\n            isPartial,\n            hasRuntimePrefetch\n        ]\n    };\n}\nfunction readHeadSnapshotFromCache(now, route) {\n    // Same as readRenderSnapshotFromCache, but for the head\n    let rsc = null;\n    let isPartial = true;\n    const segmentEntry = (0, _cache.readSegmentCacheEntry)(now, route.metadata.varyPath);\n    if (segmentEntry !== null) {\n        switch(segmentEntry.status){\n            case _cache.EntryStatus.Fulfilled:\n                {\n                    rsc = segmentEntry.rsc;\n                    isPartial = segmentEntry.isPartial;\n                    break;\n                }\n            case _cache.EntryStatus.Pending:\n                {\n                    const promiseForFulfilledEntry = (0, _cache.waitForSegmentCacheEntry)(segmentEntry);\n                    rsc = promiseForFulfilledEntry.then((entry)=>entry !== null ? entry.rsc : null);\n                    isPartial = segmentEntry.isPartial;\n                    break;\n                }\n            case _cache.EntryStatus.Empty:\n            case _cache.EntryStatus.Rejected:\n                break;\n            default:\n                segmentEntry;\n        }\n    }\n    return {\n        rsc,\n        isPartial\n    };\n}\n// Used to request all the dynamic data for a route, rather than just a subset,\n// e.g. during a refresh or a revalidation. Typically this gets constructed\n// during the normal flow when diffing the route tree, but for an unprefetched\n// navigation, where we don't know the structure of the target route, we use\n// this instead.\nconst DynamicRequestTreeForEntireRoute = [\n    '',\n    {},\n    null,\n    'refetch'\n];\nasync function navigateDynamicallyWithNoPrefetch(now, url, currentUrl, nextUrl, currentCacheNode, currentFlightRouterState, freshnessPolicy, shouldScroll, collectedDebugInfo) {\n    // Runs when a navigation happens but there's no cached prefetch we can use.\n    // Don't bother to wait for a prefetch response; go straight to a full\n    // navigation that contains both static and dynamic data in a single stream.\n    // (This is unlike the old navigation implementation, which instead blocks\n    // the dynamic request until a prefetch request is received.)\n    //\n    // To avoid duplication of logic, we're going to pretend that the tree\n    // returned by the dynamic request is, in fact, a prefetch tree. Then we can\n    // use the same server response to write the actual data into the CacheNode\n    // tree. So it's the same flow as the \"happy path\" (prefetch, then\n    // navigation), except we use a single server response for both stages.\n    let dynamicRequestTree;\n    switch(freshnessPolicy){\n        case _pprnavigations.FreshnessPolicy.Default:\n        case _pprnavigations.FreshnessPolicy.HistoryTraversal:\n            dynamicRequestTree = currentFlightRouterState;\n            break;\n        case _pprnavigations.FreshnessPolicy.Hydration:\n        case _pprnavigations.FreshnessPolicy.RefreshAll:\n        case _pprnavigations.FreshnessPolicy.HMRRefresh:\n            dynamicRequestTree = DynamicRequestTreeForEntireRoute;\n            break;\n        default:\n            freshnessPolicy;\n            dynamicRequestTree = currentFlightRouterState;\n            break;\n    }\n    const promiseForDynamicServerResponse = (0, _fetchserverresponse.fetchServerResponse)(url, {\n        flightRouterState: dynamicRequestTree,\n        nextUrl\n    });\n    const result = await promiseForDynamicServerResponse;\n    if (typeof result === 'string') {\n        // This is an MPA navigation.\n        const newUrl = result;\n        return {\n            tag: _types.NavigationResultTag.MPA,\n            data: newUrl\n        };\n    }\n    const { flightData, canonicalUrl, renderedSearch, debugInfo: debugInfoFromResponse } = result;\n    if (debugInfoFromResponse !== null) {\n        collectedDebugInfo.push(...debugInfoFromResponse);\n    }\n    // Since the response format of dynamic requests and prefetches is slightly\n    // different, we'll need to massage the data a bit. Create FlightRouterState\n    // tree that simulates what we'd receive as the result of a prefetch.\n    const navigationSeed = convertServerPatchToFullTree(currentFlightRouterState, flightData, renderedSearch);\n    return navigateToSeededRoute(now, url, (0, _createhreffromurl.createHrefFromUrl)(canonicalUrl), navigationSeed, currentUrl, currentCacheNode, currentFlightRouterState, freshnessPolicy, nextUrl, shouldScroll);\n}\nfunction convertServerPatchToFullTree(currentTree, flightData, renderedSearch) {\n    // During a client navigation or prefetch, the server sends back only a patch\n    // for the parts of the tree that have changed.\n    //\n    // This applies the patch to the base tree to create a full representation of\n    // the resulting tree.\n    //\n    // The return type includes a full FlightRouterState tree and a full\n    // CacheNodeSeedData tree. (Conceptually these are the same tree, and should\n    // eventually be unified, but there's still lots of existing code that\n    // operates on FlightRouterState trees alone without the CacheNodeSeedData.)\n    //\n    // TODO: This similar to what apply-router-state-patch-to-tree does. It\n    // will eventually fully replace it. We should get rid of all the remaining\n    // places where we iterate over the server patch format. This should also\n    // eventually replace normalizeFlightData.\n    let baseTree = currentTree;\n    let baseData = null;\n    let head = null;\n    for (const { segmentPath, tree: treePatch, seedData: dataPatch, head: headPatch } of flightData){\n        const result = convertServerPatchToFullTreeImpl(baseTree, baseData, treePatch, dataPatch, segmentPath, 0);\n        baseTree = result.tree;\n        baseData = result.data;\n        // This is the same for all patches per response, so just pick an\n        // arbitrary one\n        head = headPatch;\n    }\n    return {\n        tree: baseTree,\n        data: baseData,\n        renderedSearch,\n        head\n    };\n}\nfunction convertServerPatchToFullTreeImpl(baseRouterState, baseData, treePatch, dataPatch, segmentPath, index) {\n    if (index === segmentPath.length) {\n        // We reached the part of the tree that we need to patch.\n        return {\n            tree: treePatch,\n            data: dataPatch\n        };\n    }\n    // segmentPath represents the parent path of subtree. It's a repeating\n    // pattern of parallel route key and segment:\n    //\n    //   [string, Segment, string, Segment, string, Segment, ...]\n    //\n    // This path tells us which part of the base tree to apply the tree patch.\n    //\n    // NOTE: We receive the FlightRouterState patch in the same request as the\n    // seed data patch. Therefore we don't need to worry about diffing the segment\n    // values; we can assume the server sent us a correct result.\n    const updatedParallelRouteKey = segmentPath[index];\n    // const segment: Segment = segmentPath[index + 1] <-- Not used, see note above\n    const baseTreeChildren = baseRouterState[1];\n    const baseSeedDataChildren = baseData !== null ? baseData[1] : null;\n    const newTreeChildren = {};\n    const newSeedDataChildren = {};\n    for(const parallelRouteKey in baseTreeChildren){\n        const childBaseRouterState = baseTreeChildren[parallelRouteKey];\n        const childBaseSeedData = baseSeedDataChildren !== null ? baseSeedDataChildren[parallelRouteKey] ?? null : null;\n        if (parallelRouteKey === updatedParallelRouteKey) {\n            const result = convertServerPatchToFullTreeImpl(childBaseRouterState, childBaseSeedData, treePatch, dataPatch, segmentPath, // Advance the index by two and keep cloning until we reach\n            // the end of the segment path.\n            index + 2);\n            newTreeChildren[parallelRouteKey] = result.tree;\n            newSeedDataChildren[parallelRouteKey] = result.data;\n        } else {\n            // This child is not being patched. Copy it over as-is.\n            newTreeChildren[parallelRouteKey] = childBaseRouterState;\n            newSeedDataChildren[parallelRouteKey] = childBaseSeedData;\n        }\n    }\n    let clonedTree;\n    let clonedSeedData;\n    // Clone all the fields except the children.\n    // Clone the FlightRouterState tree. Based on equivalent logic in\n    // apply-router-state-patch-to-tree, but should confirm whether we need to\n    // copy all of these fields. Not sure the server ever sends, e.g. the\n    // refetch marker.\n    clonedTree = [\n        baseRouterState[0],\n        newTreeChildren\n    ];\n    if (2 in baseRouterState) {\n        clonedTree[2] = baseRouterState[2];\n    }\n    if (3 in baseRouterState) {\n        clonedTree[3] = baseRouterState[3];\n    }\n    if (4 in baseRouterState) {\n        clonedTree[4] = baseRouterState[4];\n    }\n    // Clone the CacheNodeSeedData tree.\n    const isEmptySeedDataPartial = true;\n    clonedSeedData = [\n        null,\n        newSeedDataChildren,\n        null,\n        isEmptySeedDataPartial,\n        false\n    ];\n    return {\n        tree: clonedTree,\n        data: clonedSeedData\n    };\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=navigation.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    DYNAMIC_STALETIME_MS: null,\n    STATIC_STALETIME_MS: null,\n    generateSegmentsFromPatch: null,\n    handleExternalUrl: null,\n    handleNavigationResult: null,\n    navigateReducer: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    DYNAMIC_STALETIME_MS: function() {\n        return DYNAMIC_STALETIME_MS;\n    },\n    STATIC_STALETIME_MS: function() {\n        return STATIC_STALETIME_MS;\n    },\n    generateSegmentsFromPatch: function() {\n        return generateSegmentsFromPatch;\n    },\n    handleExternalUrl: function() {\n        return handleExternalUrl;\n    },\n    handleNavigationResult: function() {\n        return handleNavigationResult;\n    },\n    navigateReducer: function() {\n        return navigateReducer;\n    }\n});\nconst _createhreffromurl = require(\"../create-href-from-url\");\nconst _handlemutable = require(\"../handle-mutable\");\nconst _navigation = require(\"../../segment-cache/navigation\");\nconst _types = require(\"../../segment-cache/types\");\nconst _cache = require(\"../../segment-cache/cache\");\nconst _pprnavigations = require(\"../ppr-navigations\");\nconst DYNAMIC_STALETIME_MS = Number(process.env.__NEXT_CLIENT_ROUTER_DYNAMIC_STALETIME) * 1000;\nconst STATIC_STALETIME_MS = (0, _cache.getStaleTimeMs)(Number(process.env.__NEXT_CLIENT_ROUTER_STATIC_STALETIME));\nfunction handleExternalUrl(state, mutable, url, pendingPush) {\n    mutable.mpaNavigation = true;\n    mutable.canonicalUrl = url;\n    mutable.pendingPush = pendingPush;\n    mutable.scrollableSegments = undefined;\n    return (0, _handlemutable.handleMutable)(state, mutable);\n}\nfunction generateSegmentsFromPatch(flightRouterPatch) {\n    const segments = [];\n    const [segment, parallelRoutes] = flightRouterPatch;\n    if (Object.keys(parallelRoutes).length === 0) {\n        return [\n            [\n                segment\n            ]\n        ];\n    }\n    for (const [parallelRouteKey, parallelRoute] of Object.entries(parallelRoutes)){\n        for (const childSegment of generateSegmentsFromPatch(parallelRoute)){\n            // If the segment is empty, it means we are at the root of the tree\n            if (segment === '') {\n                segments.push([\n                    parallelRouteKey,\n                    ...childSegment\n                ]);\n            } else {\n                segments.push([\n                    segment,\n                    parallelRouteKey,\n                    ...childSegment\n                ]);\n            }\n        }\n    }\n    return segments;\n}\nfunction handleNavigationResult(url, state, mutable, pendingPush, result) {\n    switch(result.tag){\n        case _types.NavigationResultTag.MPA:\n            {\n                // Perform an MPA navigation.\n                const newUrl = result.data;\n                return handleExternalUrl(state, mutable, newUrl, pendingPush);\n            }\n        case _types.NavigationResultTag.Success:\n            {\n                // Received a new result.\n                mutable.cache = result.data.cacheNode;\n                mutable.patchedTree = result.data.flightRouterState;\n                mutable.renderedSearch = result.data.renderedSearch;\n                mutable.canonicalUrl = result.data.canonicalUrl;\n                // TODO: During a refresh, we don't set the `scrollableSegments`. There's\n                // some confusing and subtle logic in `handleMutable` that decides what\n                // to do when `shouldScroll` is set but `scrollableSegments` is not. I'm\n                // not convinced it's totally coherent but the tests assert on this\n                // particular behavior so I've ported the logic as-is from the previous\n                // router implementation, for now.\n                mutable.scrollableSegments = result.data.scrollableSegments ?? undefined;\n                mutable.shouldScroll = result.data.shouldScroll;\n                mutable.hashFragment = result.data.hash;\n                // Check if the only thing that changed was the hash fragment.\n                const oldUrl = new URL(state.canonicalUrl, url);\n                const onlyHashChange = // We don't need to compare the origins, because client-driven\n                // navigations are always same-origin.\n                url.pathname === oldUrl.pathname && url.search === oldUrl.search && url.hash !== oldUrl.hash;\n                if (onlyHashChange) {\n                    // The only updated part of the URL is the hash.\n                    mutable.onlyHashChange = true;\n                    mutable.shouldScroll = result.data.shouldScroll;\n                    mutable.hashFragment = url.hash;\n                    // Setting this to an empty array triggers a scroll for all new and\n                    // updated segments. See `ScrollAndFocusHandler` for more details.\n                    mutable.scrollableSegments = [];\n                }\n                return (0, _handlemutable.handleMutable)(state, mutable);\n            }\n        case _types.NavigationResultTag.Async:\n            {\n                return result.data.then((asyncResult)=>handleNavigationResult(url, state, mutable, pendingPush, asyncResult), // If the navigation failed, return the current state.\n                // TODO: This matches the current behavior but we need to do something\n                // better here if the network fails.\n                ()=>{\n                    return state;\n                });\n            }\n        default:\n            {\n                result;\n                return state;\n            }\n    }\n}\nfunction navigateReducer(state, action) {\n    const { url, isExternalUrl, navigateType, shouldScroll } = action;\n    const mutable = {};\n    const href = (0, _createhreffromurl.createHrefFromUrl)(url);\n    const pendingPush = navigateType === 'push';\n    mutable.preserveCustomHistoryState = false;\n    mutable.pendingPush = pendingPush;\n    if (isExternalUrl) {\n        return handleExternalUrl(state, mutable, url.toString(), pendingPush);\n    }\n    // Handles case where `<meta http-equiv=\"refresh\">` tag is present,\n    // which will trigger an MPA navigation.\n    if (document.getElementById('__next-page-redirect')) {\n        return handleExternalUrl(state, mutable, href, pendingPush);\n    }\n    // Temporary glue code between the router reducer and the new navigation\n    // implementation. Eventually we'll rewrite the router reducer to a\n    // state machine.\n    const currentUrl = new URL(state.canonicalUrl, location.origin);\n    const result = (0, _navigation.navigate)(url, currentUrl, state.cache, state.tree, state.nextUrl, _pprnavigations.FreshnessPolicy.Default, shouldScroll, mutable);\n    return handleNavigationResult(url, state, mutable, pendingPush, result);\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=navigate-reducer.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"createPromiseWithResolvers\", {\n    enumerable: true,\n    get: function() {\n        return createPromiseWithResolvers;\n    }\n});\nfunction createPromiseWithResolvers() {\n    // Shim of Stage 4 Promise.withResolvers proposal\n    let resolve;\n    let reject;\n    const promise = new Promise((res, rej)=>{\n        resolve = res;\n        reject = rej;\n    });\n    return {\n        resolve: resolve,\n        reject: reject,\n        promise\n    };\n}\n\n//# sourceMappingURL=promise-with-resolvers.js.map","import type {\n  TreePrefetch,\n  RootTreePrefetch,\n  SegmentPrefetch,\n} from '../../../server/app-render/collect-segment-data'\nimport type { LoadingModuleData } from '../../../shared/lib/app-router-types'\nimport type {\n  CacheNodeSeedData,\n  Segment as FlightRouterStateSegment,\n} from '../../../shared/lib/app-router-types'\nimport { HasLoadingBoundary } from '../../../shared/lib/app-router-types'\nimport {\n  NEXT_DID_POSTPONE_HEADER,\n  NEXT_ROUTER_PREFETCH_HEADER,\n  NEXT_ROUTER_SEGMENT_PREFETCH_HEADER,\n  NEXT_ROUTER_STALE_TIME_HEADER,\n  NEXT_ROUTER_STATE_TREE_HEADER,\n  NEXT_URL,\n  RSC_CONTENT_TYPE_HEADER,\n  RSC_HEADER,\n} from '../app-router-headers'\nimport {\n  createFetch,\n  createFromNextReadableStream,\n  type RSCResponse,\n  type RequestHeaders,\n} from '../router-reducer/fetch-server-response'\nimport {\n  pingPrefetchTask,\n  isPrefetchTaskDirty,\n  type PrefetchTask,\n  type PrefetchSubtaskResult,\n  startRevalidationCooldown,\n} from './scheduler'\nimport {\n  type RouteVaryPath,\n  type SegmentVaryPath,\n  type PartialSegmentVaryPath,\n  getRouteVaryPath,\n  getFulfilledRouteVaryPath,\n  getSegmentVaryPathForRequest,\n  appendLayoutVaryPath,\n  finalizeLayoutVaryPath,\n  finalizePageVaryPath,\n  clonePageVaryPathWithNewSearchParams,\n  type PageVaryPath,\n  finalizeMetadataVaryPath,\n} from './vary-path'\nimport { getAppBuildId } from '../../app-build-id'\nimport { createHrefFromUrl } from '../router-reducer/create-href-from-url'\nimport type { NormalizedSearch, RouteCacheKey } from './cache-key'\n// TODO: Rename this module to avoid confusion with other types of cache keys\nimport { createCacheKey as createPrefetchRequestKey } from './cache-key'\nimport {\n  doesStaticSegmentAppearInURL,\n  getCacheKeyForDynamicParam,\n  getRenderedPathname,\n  getRenderedSearch,\n  parseDynamicParamFromURLPart,\n} from '../../route-params'\nimport {\n  createCacheMap,\n  getFromCacheMap,\n  setInCacheMap,\n  setSizeInCacheMap,\n  deleteFromCacheMap,\n  isValueExpired,\n  type CacheMap,\n  type UnknownMapEntry,\n} from './cache-map'\nimport {\n  appendSegmentRequestKeyPart,\n  convertSegmentPathToStaticExportFilename,\n  createSegmentRequestKeyPart,\n  HEAD_REQUEST_KEY,\n  ROOT_SEGMENT_REQUEST_KEY,\n  type SegmentRequestKey,\n} from '../../../shared/lib/segment-cache/segment-value-encoding'\nimport type {\n  FlightRouterState,\n  NavigationFlightResponse,\n} from '../../../shared/lib/app-router-types'\nimport {\n  normalizeFlightData,\n  prepareFlightRouterStateForRequest,\n} from '../../flight-data-helpers'\nimport { STATIC_STALETIME_MS } from '../router-reducer/reducers/navigate-reducer'\nimport { pingVisibleLinks } from '../links'\nimport { PAGE_SEGMENT_KEY } from '../../../shared/lib/segment'\nimport { FetchStrategy } from './types'\nimport { createPromiseWithResolvers } from '../../../shared/lib/promise-with-resolvers'\n\n/**\n * Ensures a minimum stale time of 30s to avoid issues where the server sends a too\n * short-lived stale time, which would prevent anything from being prefetched.\n */\nexport function getStaleTimeMs(staleTimeSeconds: number): number {\n  return Math.max(staleTimeSeconds, 30) * 1000\n}\n\n// A note on async/await when working in the prefetch cache:\n//\n// Most async operations in the prefetch cache should *not* use async/await,\n// Instead, spawn a subtask that writes the results to a cache entry, and attach\n// a \"ping\" listener to notify the prefetch queue to try again.\n//\n// The reason is we need to be able to access the segment cache and traverse its\n// data structures synchronously. For example, if there's a synchronous update\n// we can take an immediate snapshot of the cache to produce something we can\n// render. Limiting the use of async/await also makes it easier to avoid race\n// conditions, which is especially important because is cache is mutable.\n//\n// Another reason is that while we're performing async work, it's possible for\n// existing entries to become stale, or for Link prefetches to be removed from\n// the queue. For optimal scheduling, we need to be able to \"cancel\" subtasks\n// that are no longer needed. So, when a segment is received from the server, we\n// restart from the root of the tree that's being prefetched, to confirm all the\n// parent segments are still cached. If the segment is no longer reachable from\n// the root, then it's effectively canceled. This is similar to the design of\n// Rust Futures, or React Suspense.\n\ntype RouteTreeShared = {\n  requestKey: SegmentRequestKey\n  // TODO: Remove the `segment` field, now that it can be reconstructed\n  // from `param`.\n  segment: FlightRouterStateSegment\n  slots: null | {\n    [parallelRouteKey: string]: RouteTree\n  }\n  isRootLayout: boolean\n\n  // If this is a dynamic route, indicates whether there is a loading boundary\n  // somewhere in the tree. If not, we can skip the prefetch for the data,\n  // because we know it would be an empty response. (For a static/PPR route,\n  // this value is disregarded, because in that model `loading.tsx` is treated\n  // like any other Suspense boundary.)\n  hasLoadingBoundary: HasLoadingBoundary\n\n  // Indicates whether this route has a runtime prefetch that we can request.\n  // This is determined by the server; it's not purely a user configuration\n  // because the server may determine that a route is fully static and doesn't\n  // need runtime prefetching regardless of the configuration.\n  hasRuntimePrefetch: boolean\n}\n\ntype LayoutRouteTree = RouteTreeShared & {\n  isPage: false\n  varyPath: SegmentVaryPath\n}\n\ntype PageRouteTree = RouteTreeShared & {\n  isPage: true\n  varyPath: PageVaryPath\n}\n\nexport type RouteTree = LayoutRouteTree | PageRouteTree\n\ntype RouteCacheEntryShared = {\n  // This is false only if we're certain the route cannot be intercepted. It's\n  // true in all other cases, including on initialization when we haven't yet\n  // received a response from the server.\n  couldBeIntercepted: boolean\n\n  // Map-related fields.\n  ref: UnknownMapEntry | null\n  size: number\n  staleAt: number\n  version: number\n}\n\n/**\n * Tracks the status of a cache entry as it progresses from no data (Empty),\n * waiting for server data (Pending), and finished (either Fulfilled or\n * Rejected depending on the response from the server.\n */\nexport const enum EntryStatus {\n  Empty = 0,\n  Pending = 1,\n  Fulfilled = 2,\n  Rejected = 3,\n}\n\ntype PendingRouteCacheEntry = RouteCacheEntryShared & {\n  status: EntryStatus.Empty | EntryStatus.Pending\n  blockedTasks: Set<PrefetchTask> | null\n  canonicalUrl: null\n  renderedSearch: null\n  tree: null\n  metadata: null\n  isPPREnabled: false\n}\n\ntype RejectedRouteCacheEntry = RouteCacheEntryShared & {\n  status: EntryStatus.Rejected\n  blockedTasks: Set<PrefetchTask> | null\n  canonicalUrl: null\n  renderedSearch: null\n  tree: null\n  metadata: null\n  isPPREnabled: boolean\n}\n\nexport type FulfilledRouteCacheEntry = RouteCacheEntryShared & {\n  status: EntryStatus.Fulfilled\n  blockedTasks: null\n  canonicalUrl: string\n  renderedSearch: NormalizedSearch\n  tree: RouteTree\n  metadata: RouteTree\n  isPPREnabled: boolean\n}\n\nexport type RouteCacheEntry =\n  | PendingRouteCacheEntry\n  | FulfilledRouteCacheEntry\n  | RejectedRouteCacheEntry\n\ntype SegmentCacheEntryShared = {\n  fetchStrategy: FetchStrategy\n\n  // Map-related fields.\n  ref: UnknownMapEntry | null\n  size: number\n  staleAt: number\n  version: number\n}\n\nexport type EmptySegmentCacheEntry = SegmentCacheEntryShared & {\n  status: EntryStatus.Empty\n  rsc: null\n  loading: null\n  isPartial: true\n  promise: null\n}\n\nexport type PendingSegmentCacheEntry = SegmentCacheEntryShared & {\n  status: EntryStatus.Pending\n  rsc: null\n  loading: null\n  isPartial: boolean\n  promise: null | PromiseWithResolvers<FulfilledSegmentCacheEntry | null>\n}\n\ntype RejectedSegmentCacheEntry = SegmentCacheEntryShared & {\n  status: EntryStatus.Rejected\n  rsc: null\n  loading: null\n  isPartial: true\n  promise: null\n}\n\nexport type FulfilledSegmentCacheEntry = SegmentCacheEntryShared & {\n  status: EntryStatus.Fulfilled\n  rsc: React.ReactNode | null\n  loading: LoadingModuleData | Promise<LoadingModuleData>\n  isPartial: boolean\n  promise: null\n}\n\nexport type SegmentCacheEntry =\n  | EmptySegmentCacheEntry\n  | PendingSegmentCacheEntry\n  | RejectedSegmentCacheEntry\n  | FulfilledSegmentCacheEntry\n\nexport type NonEmptySegmentCacheEntry = Exclude<\n  SegmentCacheEntry,\n  EmptySegmentCacheEntry\n>\n\nconst isOutputExportMode =\n  process.env.NODE_ENV === 'production' &&\n  process.env.__NEXT_CONFIG_OUTPUT === 'export'\n\nconst MetadataOnlyRequestTree: FlightRouterState = [\n  '',\n  {},\n  null,\n  'metadata-only',\n]\n\nlet routeCacheMap: CacheMap<RouteCacheEntry> = createCacheMap()\nlet segmentCacheMap: CacheMap<SegmentCacheEntry> = createCacheMap()\n\n// All invalidation listeners for the whole cache are tracked in single set.\n// Since we don't yet support tag or path-based invalidation, there's no point\n// tracking them any more granularly than this. Once we add granular\n// invalidation, that may change, though generally the model is to just notify\n// the listeners and allow the caller to poll the prefetch cache with a new\n// prefetch task if desired.\nlet invalidationListeners: Set<PrefetchTask> | null = null\n\n// Incrementing counter used to track cache invalidations.\nlet currentCacheVersion = 0\n\nexport function getCurrentCacheVersion(): number {\n  return currentCacheVersion\n}\n\n/**\n * Used to clear the client prefetch cache when a server action calls\n * revalidatePath or revalidateTag. Eventually we will support only clearing the\n * segments that were actually affected, but there's more work to be done on the\n * server before the client is able to do this correctly.\n */\nexport function revalidateEntireCache(\n  nextUrl: string | null,\n  tree: FlightRouterState\n) {\n  // Increment the current cache version. This does not eagerly evict anything\n  // from the cache, but because all the entries are versioned, and we check\n  // the version when reading from the cache, this effectively causes all\n  // entries to be evicted lazily. We do it lazily because in the future,\n  // actions like revalidateTag or refresh will not evict the entire cache,\n  // but rather some subset of the entries.\n  currentCacheVersion++\n\n  // Start a cooldown before re-prefetching to allow CDN cache propagation.\n  startRevalidationCooldown()\n\n  // Prefetch all the currently visible links again, to re-fill the cache.\n  pingVisibleLinks(nextUrl, tree)\n\n  // Similarly, notify all invalidation listeners (i.e. those passed to\n  // `router.prefetch(onInvalidate)`), so they can trigger a new prefetch\n  // if needed.\n  pingInvalidationListeners(nextUrl, tree)\n}\n\nfunction attachInvalidationListener(task: PrefetchTask): void {\n  // This function is called whenever a prefetch task reads a cache entry. If\n  // the task has an onInvalidate function associated with it — i.e. the one\n  // optionally passed to router.prefetch(onInvalidate) — then we attach that\n  // listener to the every cache entry that the task reads. Then, if an entry\n  // is invalidated, we call the function.\n  if (task.onInvalidate !== null) {\n    if (invalidationListeners === null) {\n      invalidationListeners = new Set([task])\n    } else {\n      invalidationListeners.add(task)\n    }\n  }\n}\n\nfunction notifyInvalidationListener(task: PrefetchTask): void {\n  const onInvalidate = task.onInvalidate\n  if (onInvalidate !== null) {\n    // Clear the callback from the task object to guarantee it's not called more\n    // than once.\n    task.onInvalidate = null\n\n    // This is a user-space function, so we must wrap in try/catch.\n    try {\n      onInvalidate()\n    } catch (error) {\n      if (typeof reportError === 'function') {\n        reportError(error)\n      } else {\n        console.error(error)\n      }\n    }\n  }\n}\n\nexport function pingInvalidationListeners(\n  nextUrl: string | null,\n  tree: FlightRouterState\n): void {\n  // The rough equivalent of pingVisibleLinks, but for onInvalidate callbacks.\n  // This is called when the Next-Url or the base tree changes, since those\n  // may affect the result of a prefetch task. It's also called after a\n  // cache invalidation.\n  if (invalidationListeners !== null) {\n    const tasks = invalidationListeners\n    invalidationListeners = null\n    for (const task of tasks) {\n      if (isPrefetchTaskDirty(task, nextUrl, tree)) {\n        notifyInvalidationListener(task)\n      }\n    }\n  }\n}\n\nexport function readRouteCacheEntry(\n  now: number,\n  key: RouteCacheKey\n): RouteCacheEntry | null {\n  const varyPath: RouteVaryPath = getRouteVaryPath(\n    key.pathname,\n    key.search,\n    key.nextUrl\n  )\n  const isRevalidation = false\n  return getFromCacheMap(\n    now,\n    getCurrentCacheVersion(),\n    routeCacheMap,\n    varyPath,\n    isRevalidation\n  )\n}\n\nexport function readSegmentCacheEntry(\n  now: number,\n  varyPath: SegmentVaryPath\n): SegmentCacheEntry | null {\n  const isRevalidation = false\n  return getFromCacheMap(\n    now,\n    getCurrentCacheVersion(),\n    segmentCacheMap,\n    varyPath,\n    isRevalidation\n  )\n}\n\nfunction readRevalidatingSegmentCacheEntry(\n  now: number,\n  varyPath: SegmentVaryPath\n): SegmentCacheEntry | null {\n  const isRevalidation = true\n  return getFromCacheMap(\n    now,\n    getCurrentCacheVersion(),\n    segmentCacheMap,\n    varyPath,\n    isRevalidation\n  )\n}\n\nexport function waitForSegmentCacheEntry(\n  pendingEntry: PendingSegmentCacheEntry\n): Promise<FulfilledSegmentCacheEntry | null> {\n  // Because the entry is pending, there's already a in-progress request.\n  // Attach a promise to the entry that will resolve when the server responds.\n  let promiseWithResolvers = pendingEntry.promise\n  if (promiseWithResolvers === null) {\n    promiseWithResolvers = pendingEntry.promise =\n      createPromiseWithResolvers<FulfilledSegmentCacheEntry | null>()\n  } else {\n    // There's already a promise we can use\n  }\n  return promiseWithResolvers.promise\n}\n\n/**\n * Checks if an entry for a route exists in the cache. If so, it returns the\n * entry, If not, it adds an empty entry to the cache and returns it.\n */\nexport function readOrCreateRouteCacheEntry(\n  now: number,\n  task: PrefetchTask,\n  key: RouteCacheKey\n): RouteCacheEntry {\n  attachInvalidationListener(task)\n\n  const existingEntry = readRouteCacheEntry(now, key)\n  if (existingEntry !== null) {\n    return existingEntry\n  }\n  // Create a pending entry and add it to the cache.\n  const pendingEntry: PendingRouteCacheEntry = {\n    canonicalUrl: null,\n    status: EntryStatus.Empty,\n    blockedTasks: null,\n    tree: null,\n    metadata: null,\n    // This is initialized to true because we don't know yet whether the route\n    // could be intercepted. It's only set to false once we receive a response\n    // from the server.\n    couldBeIntercepted: true,\n    // Similarly, we don't yet know if the route supports PPR.\n    isPPREnabled: false,\n    renderedSearch: null,\n\n    // Map-related fields\n    ref: null,\n    size: 0,\n    // Since this is an empty entry, there's no reason to ever evict it. It will\n    // be updated when the data is populated.\n    staleAt: Infinity,\n    version: getCurrentCacheVersion(),\n  }\n  const varyPath: RouteVaryPath = getRouteVaryPath(\n    key.pathname,\n    key.search,\n    key.nextUrl\n  )\n  const isRevalidation = false\n  setInCacheMap(routeCacheMap, varyPath, pendingEntry, isRevalidation)\n  return pendingEntry\n}\n\nexport function requestOptimisticRouteCacheEntry(\n  now: number,\n  requestedUrl: URL,\n  nextUrl: string | null\n): FulfilledRouteCacheEntry | null {\n  // This function is called during a navigation when there was no matching\n  // route tree in the prefetch cache. Before de-opting to a blocking,\n  // unprefetched navigation, we will first attempt to construct an \"optimistic\"\n  // route tree by checking the cache for similar routes.\n  //\n  // Check if there's a route with the same pathname, but with different\n  // search params. We can then base our optimistic route tree on this entry.\n  //\n  // Conceptually, we are simulating what would happen if we did perform a\n  // prefetch the requested URL, under the assumption that the server will\n  // not redirect or rewrite the request in a different manner than the\n  // base route tree. This assumption might not hold, in which case we'll have\n  // to recover when we perform the dynamic navigation request. However, this\n  // is what would happen if a route were dynamically rewritten/redirected\n  // in between the prefetch and the navigation. So the logic needs to exist\n  // to handle this case regardless.\n\n  // Look for a route with the same pathname, but with an empty search string.\n  // TODO: There's nothing inherently special about the empty search string;\n  // it's chosen somewhat arbitrarily, with the rationale that it's the most\n  // likely one to exist. But we should update this to match _any_ search\n  // string. The plan is to generalize this logic alongside other improvements\n  // related to \"fallback\" cache entries.\n  const requestedSearch = requestedUrl.search as NormalizedSearch\n  if (requestedSearch === '') {\n    // The caller would have already checked if a route with an empty search\n    // string is in the cache. So we can bail out here.\n    return null\n  }\n  const urlWithoutSearchParams = new URL(requestedUrl)\n  urlWithoutSearchParams.search = ''\n  const routeWithNoSearchParams = readRouteCacheEntry(\n    now,\n    createPrefetchRequestKey(urlWithoutSearchParams.href, nextUrl)\n  )\n\n  if (\n    routeWithNoSearchParams === null ||\n    routeWithNoSearchParams.status !== EntryStatus.Fulfilled\n  ) {\n    // Bail out of constructing an optimistic route tree. This will result in\n    // a blocking, unprefetched navigation.\n    return null\n  }\n\n  // Now we have a base route tree we can \"patch\" with our optimistic values.\n\n  // Optimistically assume that redirects for the requested pathname do\n  // not vary on the search string. Therefore, if the base route was\n  // redirected to a different search string, then the optimistic route\n  // should be redirected to the same search string. Otherwise, we use\n  // the requested search string.\n  const canonicalUrlForRouteWithNoSearchParams = new URL(\n    routeWithNoSearchParams.canonicalUrl,\n    requestedUrl.origin\n  )\n  const optimisticCanonicalSearch =\n    canonicalUrlForRouteWithNoSearchParams.search !== ''\n      ? // Base route was redirected. Reuse the same redirected search string.\n        canonicalUrlForRouteWithNoSearchParams.search\n      : requestedSearch\n\n  // Similarly, optimistically assume that rewrites for the requested\n  // pathname do not vary on the search string. Therefore, if the base\n  // route was rewritten to a different search string, then the optimistic\n  // route should be rewritten to the same search string. Otherwise, we use\n  // the requested search string.\n  const optimisticRenderedSearch =\n    routeWithNoSearchParams.renderedSearch !== ''\n      ? // Base route was rewritten. Reuse the same rewritten search string.\n        routeWithNoSearchParams.renderedSearch\n      : requestedSearch\n\n  const optimisticUrl = new URL(\n    routeWithNoSearchParams.canonicalUrl,\n    location.origin\n  )\n  optimisticUrl.search = optimisticCanonicalSearch\n  const optimisticCanonicalUrl = createHrefFromUrl(optimisticUrl)\n\n  const optimisticRouteTree = createOptimisticRouteTree(\n    routeWithNoSearchParams.tree,\n    optimisticRenderedSearch\n  )\n  const optimisticMetadataTree = createOptimisticRouteTree(\n    routeWithNoSearchParams.metadata,\n    optimisticRenderedSearch\n  )\n\n  // Clone the base route tree, and override the relevant fields with our\n  // optimistic values.\n  const optimisticEntry: FulfilledRouteCacheEntry = {\n    canonicalUrl: optimisticCanonicalUrl,\n\n    status: EntryStatus.Fulfilled,\n    // This isn't cloned because it's instance-specific\n    blockedTasks: null,\n    tree: optimisticRouteTree,\n    metadata: optimisticMetadataTree,\n    couldBeIntercepted: routeWithNoSearchParams.couldBeIntercepted,\n    isPPREnabled: routeWithNoSearchParams.isPPREnabled,\n\n    // Override the rendered search with the optimistic value.\n    renderedSearch: optimisticRenderedSearch,\n\n    // Map-related fields\n    ref: null,\n    size: 0,\n    staleAt: routeWithNoSearchParams.staleAt,\n    version: routeWithNoSearchParams.version,\n  }\n\n  // Do not insert this entry into the cache. It only exists so we can\n  // perform the current navigation. Just return it to the caller.\n  return optimisticEntry\n}\n\nfunction createOptimisticRouteTree(\n  tree: RouteTree,\n  newRenderedSearch: NormalizedSearch\n): RouteTree {\n  // Create a new route tree that identical to the original one except for\n  // the rendered search string, which is contained in the vary path.\n\n  let clonedSlots: Record<string, RouteTree> | null = null\n  const originalSlots = tree.slots\n  if (originalSlots !== null) {\n    clonedSlots = {}\n    for (const parallelRouteKey in originalSlots) {\n      const childTree = originalSlots[parallelRouteKey]\n      clonedSlots[parallelRouteKey] = createOptimisticRouteTree(\n        childTree,\n        newRenderedSearch\n      )\n    }\n  }\n\n  // We only need to clone the vary path if the route is a page.\n  if (tree.isPage) {\n    return {\n      requestKey: tree.requestKey,\n      segment: tree.segment,\n      varyPath: clonePageVaryPathWithNewSearchParams(\n        tree.varyPath,\n        newRenderedSearch\n      ),\n      isPage: true,\n      slots: clonedSlots,\n      isRootLayout: tree.isRootLayout,\n      hasLoadingBoundary: tree.hasLoadingBoundary,\n      hasRuntimePrefetch: tree.hasRuntimePrefetch,\n    }\n  }\n\n  return {\n    requestKey: tree.requestKey,\n    segment: tree.segment,\n    varyPath: tree.varyPath,\n    isPage: false,\n    slots: clonedSlots,\n    isRootLayout: tree.isRootLayout,\n    hasLoadingBoundary: tree.hasLoadingBoundary,\n    hasRuntimePrefetch: tree.hasRuntimePrefetch,\n  }\n}\n\n/**\n * Checks if an entry for a segment exists in the cache. If so, it returns the\n * entry, If not, it adds an empty entry to the cache and returns it.\n */\nexport function readOrCreateSegmentCacheEntry(\n  now: number,\n  fetchStrategy: FetchStrategy,\n  route: FulfilledRouteCacheEntry,\n  tree: RouteTree\n): SegmentCacheEntry {\n  const existingEntry = readSegmentCacheEntry(now, tree.varyPath)\n  if (existingEntry !== null) {\n    return existingEntry\n  }\n  // Create a pending entry and add it to the cache.\n  const varyPathForRequest = getSegmentVaryPathForRequest(fetchStrategy, tree)\n  const pendingEntry = createDetachedSegmentCacheEntry(route.staleAt)\n  const isRevalidation = false\n  setInCacheMap(\n    segmentCacheMap,\n    varyPathForRequest,\n    pendingEntry,\n    isRevalidation\n  )\n  return pendingEntry\n}\n\nexport function readOrCreateRevalidatingSegmentEntry(\n  now: number,\n  fetchStrategy: FetchStrategy,\n  route: FulfilledRouteCacheEntry,\n  tree: RouteTree\n): SegmentCacheEntry {\n  // This function is called when we've already confirmed that a particular\n  // segment is cached, but we want to perform another request anyway in case it\n  // returns more complete and/or fresher data than we already have. The logic\n  // for deciding whether to replace the existing entry is handled elsewhere;\n  // this function just handles retrieving a cache entry that we can use to\n  // track the revalidation.\n  //\n  // The reason revalidations are stored in the cache is because we need to be\n  // able to dedupe multiple revalidation requests. The reason they have to be\n  // handled specially is because we shouldn't overwrite a \"normal\" entry if\n  // one exists at the same keypath. So, for each internal cache location, there\n  // is a special \"revalidation\" slot that is used solely for this purpose.\n  //\n  // You can think of it as if all the revalidation entries were stored in a\n  // separate cache map from the canonical entries, and then transfered to the\n  // canonical cache map once the request is complete — this isn't how it's\n  // actually implemented, since it's more efficient to store them in the same\n  // data structure as the normal entries, but that's how it's modeled\n  // conceptually.\n\n  // TODO: Once we implement Fallback behavior for params, where an entry is\n  // re-keyed based on response information, we'll need to account for the\n  // possibility that the keypath of the previous entry is more generic than\n  // the keypath of the revalidating entry. In other words, the server could\n  // return a less generic entry upon revalidation. For now, though, this isn't\n  // a concern because the keypath is based solely on the prefetch strategy,\n  // not on data contained in the response.\n  const existingEntry = readRevalidatingSegmentCacheEntry(now, tree.varyPath)\n  if (existingEntry !== null) {\n    return existingEntry\n  }\n  // Create a pending entry and add it to the cache.\n  const varyPathForRequest = getSegmentVaryPathForRequest(fetchStrategy, tree)\n  const pendingEntry = createDetachedSegmentCacheEntry(route.staleAt)\n  const isRevalidation = true\n  setInCacheMap(\n    segmentCacheMap,\n    varyPathForRequest,\n    pendingEntry,\n    isRevalidation\n  )\n  return pendingEntry\n}\n\nexport function overwriteRevalidatingSegmentCacheEntry(\n  fetchStrategy: FetchStrategy,\n  route: FulfilledRouteCacheEntry,\n  tree: RouteTree\n) {\n  // This function is called when we've already decided to replace an existing\n  // revalidation entry. Create a new entry and write it into the cache,\n  // overwriting the previous value.\n  const varyPathForRequest = getSegmentVaryPathForRequest(fetchStrategy, tree)\n  const pendingEntry = createDetachedSegmentCacheEntry(route.staleAt)\n  const isRevalidation = true\n  setInCacheMap(\n    segmentCacheMap,\n    varyPathForRequest,\n    pendingEntry,\n    isRevalidation\n  )\n  return pendingEntry\n}\n\nexport function upsertSegmentEntry(\n  now: number,\n  varyPath: SegmentVaryPath,\n  candidateEntry: SegmentCacheEntry\n): SegmentCacheEntry | null {\n  // We have a new entry that has not yet been inserted into the cache. Before\n  // we do so, we need to confirm whether it takes precedence over the existing\n  // entry (if one exists).\n  // TODO: We should not upsert an entry if its key was invalidated in the time\n  // since the request was made. We can do that by passing the \"owner\" entry to\n  // this function and confirming it's the same as `existingEntry`.\n\n  if (isValueExpired(now, getCurrentCacheVersion(), candidateEntry)) {\n    // The entry is expired. We cannot upsert it.\n    return null\n  }\n\n  const existingEntry = readSegmentCacheEntry(now, varyPath)\n  if (existingEntry !== null) {\n    // Don't replace a more specific segment with a less-specific one. A case where this\n    // might happen is if the existing segment was fetched via\n    // `<Link prefetch={true}>`.\n    if (\n      // We fetched the new segment using a different, less specific fetch strategy\n      // than the segment we already have in the cache, so it can't have more content.\n      (candidateEntry.fetchStrategy !== existingEntry.fetchStrategy &&\n        !canNewFetchStrategyProvideMoreContent(\n          existingEntry.fetchStrategy,\n          candidateEntry.fetchStrategy\n        )) ||\n      // The existing entry isn't partial, but the new one is.\n      // (TODO: can this be true if `candidateEntry.fetchStrategy >= existingEntry.fetchStrategy`?)\n      (!existingEntry.isPartial && candidateEntry.isPartial)\n    ) {\n      // We're going to leave revalidating entry in the cache so that it doesn't\n      // get revalidated again unnecessarily. Downgrade the Fulfilled entry to\n      // Rejected and null out the data so it can be garbage collected. We leave\n      // `staleAt` intact to prevent subsequent revalidation attempts only until\n      // the entry expires.\n      const rejectedEntry: RejectedSegmentCacheEntry = candidateEntry as any\n      rejectedEntry.status = EntryStatus.Rejected\n      rejectedEntry.loading = null\n      rejectedEntry.rsc = null\n      return null\n    }\n\n    // Evict the existing entry from the cache.\n    deleteFromCacheMap(existingEntry)\n  }\n\n  const isRevalidation = false\n  setInCacheMap(segmentCacheMap, varyPath, candidateEntry, isRevalidation)\n  return candidateEntry\n}\n\nexport function createDetachedSegmentCacheEntry(\n  staleAt: number\n): EmptySegmentCacheEntry {\n  const emptyEntry: EmptySegmentCacheEntry = {\n    status: EntryStatus.Empty,\n    // Default to assuming the fetch strategy will be PPR. This will be updated\n    // when a fetch is actually initiated.\n    fetchStrategy: FetchStrategy.PPR,\n    rsc: null,\n    loading: null,\n    isPartial: true,\n    promise: null,\n\n    // Map-related fields\n    ref: null,\n    size: 0,\n    staleAt,\n    version: 0,\n  }\n  return emptyEntry\n}\n\nexport function upgradeToPendingSegment(\n  emptyEntry: EmptySegmentCacheEntry,\n  fetchStrategy: FetchStrategy\n): PendingSegmentCacheEntry {\n  const pendingEntry: PendingSegmentCacheEntry = emptyEntry as any\n  pendingEntry.status = EntryStatus.Pending\n  pendingEntry.fetchStrategy = fetchStrategy\n\n  if (fetchStrategy === FetchStrategy.Full) {\n    // We can assume the response will contain the full segment data. Set this\n    // to false so we know it's OK to omit this segment from any navigation\n    // requests that may happen while the data is still pending.\n    pendingEntry.isPartial = false\n  }\n\n  // Set the version here, since this is right before the request is initiated.\n  // The next time the global cache version is incremented, the entry will\n  // effectively be evicted. This happens before initiating the request, rather\n  // than when receiving the response, because it's guaranteed to happen\n  // before the data is read on the server.\n  pendingEntry.version = getCurrentCacheVersion()\n  return pendingEntry\n}\n\nfunction pingBlockedTasks(entry: {\n  blockedTasks: Set<PrefetchTask> | null\n}): void {\n  const blockedTasks = entry.blockedTasks\n  if (blockedTasks !== null) {\n    for (const task of blockedTasks) {\n      pingPrefetchTask(task)\n    }\n    entry.blockedTasks = null\n  }\n}\n\nfunction fulfillRouteCacheEntry(\n  entry: RouteCacheEntry,\n  tree: RouteTree,\n  metadataVaryPath: PageVaryPath,\n  staleAt: number,\n  couldBeIntercepted: boolean,\n  canonicalUrl: string,\n  renderedSearch: NormalizedSearch,\n  isPPREnabled: boolean\n): FulfilledRouteCacheEntry {\n  // The Head is not actually part of the route tree, but other than that, it's\n  // fetched and cached like a segment. Some functions expect a RouteTree\n  // object, so rather than fork the logic in all those places, we use this\n  // \"fake\" one.\n  const metadata: RouteTree = {\n    requestKey: HEAD_REQUEST_KEY,\n    segment: HEAD_REQUEST_KEY,\n    varyPath: metadataVaryPath,\n    // The metadata isn't really a \"page\" (though it isn't really a \"segment\"\n    // either) but for the purposes of how this field is used, it behaves like\n    // one. If this logic ever gets more complex we can change this to an enum.\n    isPage: true,\n    slots: null,\n    isRootLayout: false,\n    hasLoadingBoundary: HasLoadingBoundary.SubtreeHasNoLoadingBoundary,\n    hasRuntimePrefetch: false,\n  }\n  const fulfilledEntry: FulfilledRouteCacheEntry = entry as any\n  fulfilledEntry.status = EntryStatus.Fulfilled\n  fulfilledEntry.tree = tree\n  fulfilledEntry.metadata = metadata\n  fulfilledEntry.staleAt = staleAt\n  fulfilledEntry.couldBeIntercepted = couldBeIntercepted\n  fulfilledEntry.canonicalUrl = canonicalUrl\n  fulfilledEntry.renderedSearch = renderedSearch\n  fulfilledEntry.isPPREnabled = isPPREnabled\n  pingBlockedTasks(entry)\n  return fulfilledEntry\n}\n\nfunction fulfillSegmentCacheEntry(\n  segmentCacheEntry: PendingSegmentCacheEntry,\n  rsc: React.ReactNode,\n  loading: LoadingModuleData | Promise<LoadingModuleData>,\n  staleAt: number,\n  isPartial: boolean\n): FulfilledSegmentCacheEntry {\n  const fulfilledEntry: FulfilledSegmentCacheEntry = segmentCacheEntry as any\n  fulfilledEntry.status = EntryStatus.Fulfilled\n  fulfilledEntry.rsc = rsc\n  fulfilledEntry.loading = loading\n  fulfilledEntry.staleAt = staleAt\n  fulfilledEntry.isPartial = isPartial\n  // Resolve any listeners that were waiting for this data.\n  if (segmentCacheEntry.promise !== null) {\n    segmentCacheEntry.promise.resolve(fulfilledEntry)\n    // Free the promise for garbage collection.\n    fulfilledEntry.promise = null\n  }\n  return fulfilledEntry\n}\n\nfunction rejectRouteCacheEntry(\n  entry: PendingRouteCacheEntry,\n  staleAt: number\n): void {\n  const rejectedEntry: RejectedRouteCacheEntry = entry as any\n  rejectedEntry.status = EntryStatus.Rejected\n  rejectedEntry.staleAt = staleAt\n  pingBlockedTasks(entry)\n}\n\nfunction rejectSegmentCacheEntry(\n  entry: PendingSegmentCacheEntry,\n  staleAt: number\n): void {\n  const rejectedEntry: RejectedSegmentCacheEntry = entry as any\n  rejectedEntry.status = EntryStatus.Rejected\n  rejectedEntry.staleAt = staleAt\n  if (entry.promise !== null) {\n    // NOTE: We don't currently propagate the reason the prefetch was canceled\n    // but we could by accepting a `reason` argument.\n    entry.promise.resolve(null)\n    entry.promise = null\n  }\n}\n\ntype RouteTreeAccumulator = {\n  metadataVaryPath: PageVaryPath | null\n}\n\nfunction convertRootTreePrefetchToRouteTree(\n  rootTree: RootTreePrefetch,\n  renderedPathname: string,\n  renderedSearch: NormalizedSearch,\n  acc: RouteTreeAccumulator\n) {\n  // Remove trailing and leading slashes\n  const pathnameParts = renderedPathname.split('/').filter((p) => p !== '')\n  const index = 0\n  const rootSegment = ROOT_SEGMENT_REQUEST_KEY\n  return convertTreePrefetchToRouteTree(\n    rootTree.tree,\n    rootSegment,\n    null,\n    ROOT_SEGMENT_REQUEST_KEY,\n    pathnameParts,\n    index,\n    renderedSearch,\n    acc\n  )\n}\n\nfunction convertTreePrefetchToRouteTree(\n  prefetch: TreePrefetch,\n  segment: FlightRouterStateSegment,\n  partialVaryPath: PartialSegmentVaryPath | null,\n  requestKey: SegmentRequestKey,\n  pathnameParts: Array<string>,\n  pathnamePartsIndex: number,\n  renderedSearch: NormalizedSearch,\n  acc: RouteTreeAccumulator\n): RouteTree {\n  // Converts the route tree sent by the server into the format used by the\n  // cache. The cached version of the tree includes additional fields, such as a\n  // cache key for each segment. Since this is frequently accessed, we compute\n  // it once instead of on every access. This same cache key is also used to\n  // request the segment from the server.\n\n  let slots: { [parallelRouteKey: string]: RouteTree } | null = null\n  let isPage: boolean\n  let varyPath: SegmentVaryPath\n  const prefetchSlots = prefetch.slots\n  if (prefetchSlots !== null) {\n    isPage = false\n    varyPath = finalizeLayoutVaryPath(requestKey, partialVaryPath)\n\n    slots = {}\n    for (let parallelRouteKey in prefetchSlots) {\n      const childPrefetch = prefetchSlots[parallelRouteKey]\n      const childParamName = childPrefetch.name\n      const childParamType = childPrefetch.paramType\n      const childServerSentParamKey = childPrefetch.paramKey\n\n      let childDoesAppearInURL: boolean\n      let childSegment: FlightRouterStateSegment\n      let childPartialVaryPath: PartialSegmentVaryPath | null\n      if (childParamType !== null) {\n        // This segment is parameterized. Get the param from the pathname.\n        const childParamValue = parseDynamicParamFromURLPart(\n          childParamType,\n          pathnameParts,\n          pathnamePartsIndex\n        )\n\n        // Assign a cache key to the segment, based on the param value. In the\n        // pre-Segment Cache implementation, the server computes this and sends\n        // it in the body of the response. In the Segment Cache implementation,\n        // the server sends an empty string and we fill it in here.\n\n        // TODO: We're intentionally not adding the search param to page\n        // segments here; it's tracked separately and added back during a read.\n        // This would clearer if we waited to construct the segment until it's\n        // read from the cache, since that's effectively what we're\n        // doing anyway.\n        const childParamKey =\n          // The server omits this field from the prefetch response when\n          // cacheComponents is enabled.\n          childServerSentParamKey !== null\n            ? childServerSentParamKey\n            : // If no param key was sent, use the value parsed on the client.\n              getCacheKeyForDynamicParam(\n                childParamValue,\n                '' as NormalizedSearch\n              )\n\n        childPartialVaryPath = appendLayoutVaryPath(\n          partialVaryPath,\n          childParamKey\n        )\n        childSegment = [childParamName, childParamKey, childParamType]\n        childDoesAppearInURL = true\n      } else {\n        // This segment does not have a param. Inherit the partial vary path of\n        // the parent.\n        childPartialVaryPath = partialVaryPath\n        childSegment = childParamName\n        childDoesAppearInURL = doesStaticSegmentAppearInURL(childParamName)\n      }\n\n      // Only increment the index if the segment appears in the URL. If it's a\n      // \"virtual\" segment, like a route group, it remains the same.\n      const childPathnamePartsIndex = childDoesAppearInURL\n        ? pathnamePartsIndex + 1\n        : pathnamePartsIndex\n\n      const childRequestKeyPart = createSegmentRequestKeyPart(childSegment)\n      const childRequestKey = appendSegmentRequestKeyPart(\n        requestKey,\n        parallelRouteKey,\n        childRequestKeyPart\n      )\n      slots[parallelRouteKey] = convertTreePrefetchToRouteTree(\n        childPrefetch,\n        childSegment,\n        childPartialVaryPath,\n        childRequestKey,\n        pathnameParts,\n        childPathnamePartsIndex,\n        renderedSearch,\n        acc\n      )\n    }\n  } else {\n    if (requestKey.endsWith(PAGE_SEGMENT_KEY)) {\n      // This is a page segment.\n      isPage = true\n      varyPath = finalizePageVaryPath(\n        requestKey,\n        renderedSearch,\n        partialVaryPath\n      )\n      // The metadata \"segment\" is not part the route tree, but it has the same\n      // conceptual params as a page segment. Write the vary path into the\n      // accumulator object. If there are multiple parallel pages, we use the\n      // first one. Which page we choose is arbitrary as long as it's\n      // consistently the same one every time every time. See\n      // finalizeMetadataVaryPath for more details.\n      if (acc.metadataVaryPath === null) {\n        acc.metadataVaryPath = finalizeMetadataVaryPath(\n          requestKey,\n          renderedSearch,\n          partialVaryPath\n        )\n      }\n    } else {\n      // This is a layout segment.\n      isPage = false\n      varyPath = finalizeLayoutVaryPath(requestKey, partialVaryPath)\n    }\n  }\n\n  return {\n    requestKey,\n    segment,\n    varyPath,\n    // TODO: Cheating the type system here a bit because TypeScript can't tell\n    // that the type of isPage and varyPath are consistent. The fix would be to\n    // create separate constructors and call the appropriate one from each of\n    // the branches above. Just seems a bit overkill only for one field so I'll\n    // leave it as-is for now. If isPage were wrong it would break the behavior\n    // and we'd catch it quickly, anyway.\n    isPage: isPage as boolean as any,\n    slots,\n    isRootLayout: prefetch.isRootLayout,\n    // This field is only relevant to dynamic routes. For a PPR/static route,\n    // there's always some partial loading state we can fetch.\n    hasLoadingBoundary: HasLoadingBoundary.SegmentHasLoadingBoundary,\n    hasRuntimePrefetch: prefetch.hasRuntimePrefetch,\n  }\n}\n\nfunction convertRootFlightRouterStateToRouteTree(\n  flightRouterState: FlightRouterState,\n  renderedSearch: NormalizedSearch,\n  acc: RouteTreeAccumulator\n): RouteTree {\n  return convertFlightRouterStateToRouteTree(\n    flightRouterState,\n    ROOT_SEGMENT_REQUEST_KEY,\n    null,\n    renderedSearch,\n    acc\n  )\n}\n\nfunction convertFlightRouterStateToRouteTree(\n  flightRouterState: FlightRouterState,\n  requestKey: SegmentRequestKey,\n  parentPartialVaryPath: PartialSegmentVaryPath | null,\n  renderedSearch: NormalizedSearch,\n  acc: RouteTreeAccumulator\n): RouteTree {\n  const originalSegment = flightRouterState[0]\n\n  let segment: FlightRouterStateSegment\n  let partialVaryPath: PartialSegmentVaryPath | null\n  let isPage: boolean\n  let varyPath: SegmentVaryPath\n  if (Array.isArray(originalSegment)) {\n    isPage = false\n    const paramCacheKey = originalSegment[1]\n    partialVaryPath = appendLayoutVaryPath(parentPartialVaryPath, paramCacheKey)\n    varyPath = finalizeLayoutVaryPath(requestKey, partialVaryPath)\n    segment = originalSegment\n  } else {\n    // This segment does not have a param. Inherit the partial vary path of\n    // the parent.\n    partialVaryPath = parentPartialVaryPath\n    if (requestKey.endsWith(PAGE_SEGMENT_KEY)) {\n      // This is a page segment.\n      isPage = true\n\n      // The navigation implementation expects the search params to be included\n      // in the segment. However, in the case of a static response, the search\n      // params are omitted. So the client needs to add them back in when reading\n      // from the Segment Cache.\n      //\n      // For consistency, we'll do this for dynamic responses, too.\n      //\n      // TODO: We should move search params out of FlightRouterState and handle\n      // them entirely on the client, similar to our plan for dynamic params.\n      segment = PAGE_SEGMENT_KEY\n      varyPath = finalizePageVaryPath(\n        requestKey,\n        renderedSearch,\n        partialVaryPath\n      )\n      // The metadata \"segment\" is not part the route tree, but it has the same\n      // conceptual params as a page segment. Write the vary path into the\n      // accumulator object. If there are multiple parallel pages, we use the\n      // first one. Which page we choose is arbitrary as long as it's\n      // consistently the same one every time every time. See\n      // finalizeMetadataVaryPath for more details.\n      if (acc.metadataVaryPath === null) {\n        acc.metadataVaryPath = finalizeMetadataVaryPath(\n          requestKey,\n          renderedSearch,\n          partialVaryPath\n        )\n      }\n    } else {\n      // This is a layout segment.\n      isPage = false\n      segment = originalSegment\n      varyPath = finalizeLayoutVaryPath(requestKey, partialVaryPath)\n    }\n  }\n\n  let slots: { [parallelRouteKey: string]: RouteTree } | null = null\n\n  const parallelRoutes = flightRouterState[1]\n  for (let parallelRouteKey in parallelRoutes) {\n    const childRouterState = parallelRoutes[parallelRouteKey]\n    const childSegment = childRouterState[0]\n    // TODO: Eventually, the param values will not be included in the response\n    // from the server. We'll instead fill them in on the client by parsing\n    // the URL. This is where we'll do that.\n    const childRequestKeyPart = createSegmentRequestKeyPart(childSegment)\n    const childRequestKey = appendSegmentRequestKeyPart(\n      requestKey,\n      parallelRouteKey,\n      childRequestKeyPart\n    )\n    const childTree = convertFlightRouterStateToRouteTree(\n      childRouterState,\n      childRequestKey,\n      partialVaryPath,\n      renderedSearch,\n      acc\n    )\n    if (slots === null) {\n      slots = {\n        [parallelRouteKey]: childTree,\n      }\n    } else {\n      slots[parallelRouteKey] = childTree\n    }\n  }\n\n  return {\n    requestKey,\n    segment,\n    varyPath,\n    // TODO: Cheating the type system here a bit because TypeScript can't tell\n    // that the type of isPage and varyPath are consistent. The fix would be to\n    // create separate constructors and call the appropriate one from each of\n    // the branches above. Just seems a bit overkill only for one field so I'll\n    // leave it as-is for now. If isPage were wrong it would break the behavior\n    // and we'd catch it quickly, anyway.\n    isPage: isPage as boolean as any,\n    slots,\n    isRootLayout: flightRouterState[4] === true,\n    hasLoadingBoundary:\n      flightRouterState[5] !== undefined\n        ? flightRouterState[5]\n        : HasLoadingBoundary.SubtreeHasNoLoadingBoundary,\n\n    // Non-static tree responses are only used by apps that haven't adopted\n    // Cache Components. So this is always false.\n    hasRuntimePrefetch: false,\n  }\n}\n\nexport function convertRouteTreeToFlightRouterState(\n  routeTree: RouteTree\n): FlightRouterState {\n  const parallelRoutes: Record<string, FlightRouterState> = {}\n  if (routeTree.slots !== null) {\n    for (const parallelRouteKey in routeTree.slots) {\n      parallelRoutes[parallelRouteKey] = convertRouteTreeToFlightRouterState(\n        routeTree.slots[parallelRouteKey]\n      )\n    }\n  }\n  const flightRouterState: FlightRouterState = [\n    routeTree.segment,\n    parallelRoutes,\n    null,\n    null,\n    routeTree.isRootLayout,\n  ]\n  return flightRouterState\n}\n\nexport async function fetchRouteOnCacheMiss(\n  entry: PendingRouteCacheEntry,\n  task: PrefetchTask,\n  key: RouteCacheKey\n): Promise<PrefetchSubtaskResult<null> | null> {\n  // This function is allowed to use async/await because it contains the actual\n  // fetch that gets issued on a cache miss. Notice it writes the result to the\n  // cache entry directly, rather than return data that is then written by\n  // the caller.\n  const pathname = key.pathname\n  const search = key.search\n  const nextUrl = key.nextUrl\n  const segmentPath = '/_tree' as SegmentRequestKey\n\n  const headers: RequestHeaders = {\n    [RSC_HEADER]: '1',\n    [NEXT_ROUTER_PREFETCH_HEADER]: '1',\n    [NEXT_ROUTER_SEGMENT_PREFETCH_HEADER]: segmentPath,\n  }\n  if (nextUrl !== null) {\n    headers[NEXT_URL] = nextUrl\n  }\n\n  try {\n    const url = new URL(pathname + search, location.origin)\n    let response\n    let urlAfterRedirects\n    if (isOutputExportMode) {\n      // In output: \"export\" mode, we can't use headers to request a particular\n      // segment. Instead, we encode the extra request information into the URL.\n      // This is not part of the \"public\" interface of the app; it's an internal\n      // Next.js implementation detail that the app developer should not need to\n      // concern themselves with.\n      //\n      // For example, to request a segment:\n      //\n      //   Path passed to <Link>:   /path/to/page\n      //   Path passed to fetch:    /path/to/page/__next-segments/_tree\n      //\n      //   (This is not the exact protocol, just an illustration.)\n      //\n      // Before we do that, though, we need to account for redirects. Even in\n      // output: \"export\" mode, a proxy might redirect the page to a different\n      // location, but we shouldn't assume or expect that they also redirect all\n      // the segment files, too.\n      //\n      // To check whether the page is redirected, previously we perform a range\n      // request of 64 bytes of the HTML document to check if the target page\n      // is part of this app (by checking if build id matches). Only if the target\n      // page is part of this app do we determine the final canonical URL.\n      //\n      // However, as mentioned in https://github.com/vercel/next.js/pull/85903,\n      // some popular static hosting providers (like Cloudflare Pages or Render.com)\n      // do not support range requests, in the worst case, the entire HTML instead\n      // of 64 bytes could be returned, which is wasteful.\n      //\n      // So instead, we drops the check for build id here, and simply perform\n      // a HEAD request to rejects 1xx/4xx/5xx responses, and then determine the\n      // final URL after redirects.\n      //\n      // NOTE: We could embed the route tree into the HTML document, to avoid\n      // a second request. We're not doing that currently because it would make\n      // the HTML document larger and affect normal page loads.\n      const headResponse = await fetch(url, {\n        method: 'HEAD',\n      })\n      if (headResponse.status < 200 || headResponse.status >= 400) {\n        // The target page responded w/o a successful status code\n        // Could be a WAF serving a 403, or a 5xx from a backend\n        //\n        // Note that we can't use headResponse.ok here, because\n        // Response#ok returns `false` with 3xx responses.\n        rejectRouteCacheEntry(entry, Date.now() + 10 * 1000)\n        return null\n      }\n\n      urlAfterRedirects = headResponse.redirected\n        ? new URL(headResponse.url)\n        : url\n\n      response = await fetchPrefetchResponse(\n        addSegmentPathToUrlInOutputExportMode(urlAfterRedirects, segmentPath),\n        headers\n      )\n    } else {\n      // \"Server\" mode. We can use request headers instead of the pathname.\n      // TODO: The eventual plan is to get rid of our custom request headers and\n      // encode everything into the URL, using a similar strategy to the\n      // \"output: export\" block above.\n      response = await fetchPrefetchResponse(url, headers)\n      urlAfterRedirects =\n        response !== null && response.redirected ? new URL(response.url) : url\n    }\n\n    if (\n      !response ||\n      !response.ok ||\n      // 204 is a Cache miss. Though theoretically this shouldn't happen when\n      // PPR is enabled, because we always respond to route tree requests, even\n      // if it needs to be blockingly generated on demand.\n      response.status === 204 ||\n      !response.body\n    ) {\n      // Server responded with an error, or with a miss. We should still cache\n      // the response, but we can try again after 10 seconds.\n      rejectRouteCacheEntry(entry, Date.now() + 10 * 1000)\n      return null\n    }\n\n    // TODO: The canonical URL is the href without the origin. I think\n    // historically the reason for this is because the initial canonical URL\n    // gets passed as a prop to the top-level React component, which means it\n    // needs to be computed during SSR. If it were to include the origin, it\n    // would need to always be same as location.origin on the client, to prevent\n    // a hydration mismatch. To sidestep this complexity, we omit the origin.\n    //\n    // However, since this is neither a native URL object nor a fully qualified\n    // URL string, we need to be careful about how we use it. To prevent subtle\n    // mistakes, we should create a special type for it, instead of just string.\n    // Or, we should just use a (readonly) URL object instead. The type of the\n    // prop that we pass to seed the initial state does not need to be the same\n    // type as the state itself.\n    const canonicalUrl = createHrefFromUrl(urlAfterRedirects)\n\n    // Check whether the response varies based on the Next-Url header.\n    const varyHeader = response.headers.get('vary')\n    const couldBeIntercepted =\n      varyHeader !== null && varyHeader.includes(NEXT_URL)\n\n    // Track when the network connection closes.\n    const closed = createPromiseWithResolvers<void>()\n\n    // This checks whether the response was served from the per-segment cache,\n    // rather than the old prefetching flow. If it fails, it implies that PPR\n    // is disabled on this route.\n    const routeIsPPREnabled =\n      response.headers.get(NEXT_DID_POSTPONE_HEADER) === '2' ||\n      // In output: \"export\" mode, we can't rely on response headers. But if we\n      // receive a well-formed response, we can assume it's a static response,\n      // because all data is static in this mode.\n      isOutputExportMode\n\n    if (routeIsPPREnabled) {\n      const prefetchStream = createPrefetchResponseStream(\n        response.body,\n        closed.resolve,\n        function onResponseSizeUpdate(size) {\n          setSizeInCacheMap(entry, size)\n        }\n      )\n      const serverData = await createFromNextReadableStream<RootTreePrefetch>(\n        prefetchStream,\n        headers\n      )\n      if (serverData.buildId !== getAppBuildId()) {\n        // The server build does not match the client. Treat as a 404. During\n        // an actual navigation, the router will trigger an MPA navigation.\n        // TODO: Consider moving the build ID to a response header so we can check\n        // it before decoding the response, and so there's one way of checking\n        // across all response types.\n        // TODO: We should cache the fact that this is an MPA navigation.\n        rejectRouteCacheEntry(entry, Date.now() + 10 * 1000)\n        return null\n      }\n\n      // Get the params that were used to render the target page. These may\n      // be different from the params in the request URL, if the page\n      // was rewritten.\n      const renderedPathname = getRenderedPathname(response)\n      const renderedSearch = getRenderedSearch(response)\n\n      // Convert the server-sent data into the RouteTree format used by the\n      // client cache.\n      //\n      // During this traversal, we accumulate additional data into this\n      // \"accumulator\" object.\n      const acc: RouteTreeAccumulator = { metadataVaryPath: null }\n      const routeTree = convertRootTreePrefetchToRouteTree(\n        serverData,\n        renderedPathname,\n        renderedSearch,\n        acc\n      )\n      const metadataVaryPath = acc.metadataVaryPath\n      if (metadataVaryPath === null) {\n        rejectRouteCacheEntry(entry, Date.now() + 10 * 1000)\n        return null\n      }\n\n      const staleTimeMs = getStaleTimeMs(serverData.staleTime)\n      fulfillRouteCacheEntry(\n        entry,\n        routeTree,\n        metadataVaryPath,\n        Date.now() + staleTimeMs,\n        couldBeIntercepted,\n        canonicalUrl,\n        renderedSearch,\n        routeIsPPREnabled\n      )\n    } else {\n      // PPR is not enabled for this route. The server responds with a\n      // different format (FlightRouterState) that we need to convert.\n      // TODO: We will unify the responses eventually. I'm keeping the types\n      // separate for now because FlightRouterState has so many\n      // overloaded concerns.\n      const prefetchStream = createPrefetchResponseStream(\n        response.body,\n        closed.resolve,\n        function onResponseSizeUpdate(size) {\n          setSizeInCacheMap(entry, size)\n        }\n      )\n      const serverData =\n        await createFromNextReadableStream<NavigationFlightResponse>(\n          prefetchStream,\n          headers\n        )\n      if (serverData.b !== getAppBuildId()) {\n        // The server build does not match the client. Treat as a 404. During\n        // an actual navigation, the router will trigger an MPA navigation.\n        // TODO: Consider moving the build ID to a response header so we can check\n        // it before decoding the response, and so there's one way of checking\n        // across all response types.\n        // TODO: We should cache the fact that this is an MPA navigation.\n        rejectRouteCacheEntry(entry, Date.now() + 10 * 1000)\n        return null\n      }\n\n      writeDynamicTreeResponseIntoCache(\n        Date.now(),\n        task,\n        // The non-PPR response format is what we'd get if we prefetched these segments\n        // using the LoadingBoundary fetch strategy, so mark their cache entries accordingly.\n        FetchStrategy.LoadingBoundary,\n        response as RSCResponse<NavigationFlightResponse>,\n        serverData,\n        entry,\n        couldBeIntercepted,\n        canonicalUrl,\n        routeIsPPREnabled\n      )\n    }\n\n    if (!couldBeIntercepted) {\n      // This route will never be intercepted. So we can use this entry for all\n      // requests to this route, regardless of the Next-Url header. This works\n      // because when reading the cache we always check for a valid\n      // non-intercepted entry first.\n\n      // Re-key the entry. The `set` implementation handles removing it from\n      // its previous position in the cache. We don't need to do anything to\n      // update the LRU, because the entry is already in it.\n      // TODO: Treat this as an upsert — should check if an entry already\n      // exists at the new keypath, and if so, whether we should keep that\n      // one instead.\n      const fulfilledVaryPath: RouteVaryPath = getFulfilledRouteVaryPath(\n        pathname,\n        search,\n        nextUrl,\n        couldBeIntercepted\n      )\n      const isRevalidation = false\n      setInCacheMap(routeCacheMap, fulfilledVaryPath, entry, isRevalidation)\n    }\n    // Return a promise that resolves when the network connection closes, so\n    // the scheduler can track the number of concurrent network connections.\n    return { value: null, closed: closed.promise }\n  } catch (error) {\n    // Either the connection itself failed, or something bad happened while\n    // decoding the response.\n    rejectRouteCacheEntry(entry, Date.now() + 10 * 1000)\n    return null\n  }\n}\n\nexport async function fetchSegmentOnCacheMiss(\n  route: FulfilledRouteCacheEntry,\n  segmentCacheEntry: PendingSegmentCacheEntry,\n  routeKey: RouteCacheKey,\n  tree: RouteTree\n): Promise<PrefetchSubtaskResult<FulfilledSegmentCacheEntry> | null> {\n  // This function is allowed to use async/await because it contains the actual\n  // fetch that gets issued on a cache miss. Notice it writes the result to the\n  // cache entry directly, rather than return data that is then written by\n  // the caller.\n  //\n  // Segment fetches are non-blocking so we don't need to ping the scheduler\n  // on completion.\n\n  // Use the canonical URL to request the segment, not the original URL. These\n  // are usually the same, but the canonical URL will be different if the route\n  // tree response was redirected. To avoid an extra waterfall on every segment\n  // request, we pass the redirected URL instead of the original one.\n  const url = new URL(route.canonicalUrl, location.origin)\n  const nextUrl = routeKey.nextUrl\n\n  const requestKey = tree.requestKey\n  const normalizedRequestKey =\n    requestKey === ROOT_SEGMENT_REQUEST_KEY\n      ? // The root segment is a special case. To simplify the server-side\n        // handling of these requests, we encode the root segment path as\n        // `_index` instead of as an empty string. This should be treated as\n        // an implementation detail and not as a stable part of the protocol.\n        // It just needs to match the equivalent logic that happens when\n        // prerendering the responses. It should not leak outside of Next.js.\n        ('/_index' as SegmentRequestKey)\n      : requestKey\n\n  const headers: RequestHeaders = {\n    [RSC_HEADER]: '1',\n    [NEXT_ROUTER_PREFETCH_HEADER]: '1',\n    [NEXT_ROUTER_SEGMENT_PREFETCH_HEADER]: normalizedRequestKey,\n  }\n  if (nextUrl !== null) {\n    headers[NEXT_URL] = nextUrl\n  }\n\n  const requestUrl = isOutputExportMode\n    ? // In output: \"export\" mode, we need to add the segment path to the URL.\n      addSegmentPathToUrlInOutputExportMode(url, normalizedRequestKey)\n    : url\n  try {\n    const response = await fetchPrefetchResponse(requestUrl, headers)\n    if (\n      !response ||\n      !response.ok ||\n      response.status === 204 || // Cache miss\n      // This checks whether the response was served from the per-segment cache,\n      // rather than the old prefetching flow. If it fails, it implies that PPR\n      // is disabled on this route. Theoretically this should never happen\n      // because we only issue requests for segments once we've verified that\n      // the route supports PPR.\n      (response.headers.get(NEXT_DID_POSTPONE_HEADER) !== '2' &&\n        // In output: \"export\" mode, we can't rely on response headers. But if\n        // we receive a well-formed response, we can assume it's a static\n        // response, because all data is static in this mode.\n        !isOutputExportMode) ||\n      !response.body\n    ) {\n      // Server responded with an error, or with a miss. We should still cache\n      // the response, but we can try again after 10 seconds.\n      rejectSegmentCacheEntry(segmentCacheEntry, Date.now() + 10 * 1000)\n      return null\n    }\n\n    // Track when the network connection closes.\n    const closed = createPromiseWithResolvers<void>()\n\n    // Wrap the original stream in a new stream that never closes. That way the\n    // Flight client doesn't error if there's a hanging promise.\n    const prefetchStream = createPrefetchResponseStream(\n      response.body,\n      closed.resolve,\n      function onResponseSizeUpdate(size) {\n        setSizeInCacheMap(segmentCacheEntry, size)\n      }\n    )\n    const serverData = await (createFromNextReadableStream(\n      prefetchStream,\n      headers\n    ) as Promise<SegmentPrefetch>)\n    if (serverData.buildId !== getAppBuildId()) {\n      // The server build does not match the client. Treat as a 404. During\n      // an actual navigation, the router will trigger an MPA navigation.\n      // TODO: Consider moving the build ID to a response header so we can check\n      // it before decoding the response, and so there's one way of checking\n      // across all response types.\n      rejectSegmentCacheEntry(segmentCacheEntry, Date.now() + 10 * 1000)\n      return null\n    }\n    return {\n      value: fulfillSegmentCacheEntry(\n        segmentCacheEntry,\n        serverData.rsc,\n        serverData.loading,\n        // TODO: The server does not currently provide per-segment stale time.\n        // So we use the stale time of the route.\n        route.staleAt,\n        serverData.isPartial\n      ),\n      // Return a promise that resolves when the network connection closes, so\n      // the scheduler can track the number of concurrent network connections.\n      closed: closed.promise,\n    }\n  } catch (error) {\n    // Either the connection itself failed, or something bad happened while\n    // decoding the response.\n    rejectSegmentCacheEntry(segmentCacheEntry, Date.now() + 10 * 1000)\n    return null\n  }\n}\n\nexport async function fetchSegmentPrefetchesUsingDynamicRequest(\n  task: PrefetchTask,\n  route: FulfilledRouteCacheEntry,\n  fetchStrategy:\n    | FetchStrategy.LoadingBoundary\n    | FetchStrategy.PPRRuntime\n    | FetchStrategy.Full,\n  dynamicRequestTree: FlightRouterState,\n  spawnedEntries: Map<SegmentRequestKey, PendingSegmentCacheEntry>\n): Promise<PrefetchSubtaskResult<null> | null> {\n  const key = task.key\n  const url = new URL(route.canonicalUrl, location.origin)\n  const nextUrl = key.nextUrl\n\n  if (\n    spawnedEntries.size === 1 &&\n    spawnedEntries.has(route.metadata.requestKey)\n  ) {\n    // The only thing pending is the head. Instruct the server to\n    // skip over everything else.\n    dynamicRequestTree = MetadataOnlyRequestTree\n  }\n\n  const headers: RequestHeaders = {\n    [RSC_HEADER]: '1',\n    [NEXT_ROUTER_STATE_TREE_HEADER]:\n      prepareFlightRouterStateForRequest(dynamicRequestTree),\n  }\n  if (nextUrl !== null) {\n    headers[NEXT_URL] = nextUrl\n  }\n  switch (fetchStrategy) {\n    case FetchStrategy.Full: {\n      // We omit the prefetch header from a full prefetch because it's essentially\n      // just a navigation request that happens ahead of time — it should include\n      // all the same data in the response.\n      break\n    }\n    case FetchStrategy.PPRRuntime: {\n      headers[NEXT_ROUTER_PREFETCH_HEADER] = '2'\n      break\n    }\n    case FetchStrategy.LoadingBoundary: {\n      headers[NEXT_ROUTER_PREFETCH_HEADER] = '1'\n      break\n    }\n    default: {\n      fetchStrategy satisfies never\n    }\n  }\n\n  try {\n    const response = await fetchPrefetchResponse(url, headers)\n    if (!response || !response.ok || !response.body) {\n      // Server responded with an error, or with a miss. We should still cache\n      // the response, but we can try again after 10 seconds.\n      rejectSegmentEntriesIfStillPending(spawnedEntries, Date.now() + 10 * 1000)\n      return null\n    }\n\n    const renderedSearch = getRenderedSearch(response)\n    if (renderedSearch !== route.renderedSearch) {\n      // The search params that were used to render the target page are\n      // different from the search params in the request URL. This only happens\n      // when there's a dynamic rewrite in between the tree prefetch and the\n      // data prefetch.\n      // TODO: For now, since this is an edge case, we reject the prefetch, but\n      // the proper way to handle this is to evict the stale route tree entry\n      // then fill the cache with the new response.\n      rejectSegmentEntriesIfStillPending(spawnedEntries, Date.now() + 10 * 1000)\n      return null\n    }\n\n    // Track when the network connection closes.\n    const closed = createPromiseWithResolvers<void>()\n\n    let fulfilledEntries: Array<FulfilledSegmentCacheEntry> | null = null\n    const prefetchStream = createPrefetchResponseStream(\n      response.body,\n      closed.resolve,\n      function onResponseSizeUpdate(totalBytesReceivedSoFar) {\n        // When processing a dynamic response, we don't know how large each\n        // individual segment is, so approximate by assiging each segment\n        // the average of the total response size.\n        if (fulfilledEntries === null) {\n          // Haven't received enough data yet to know which segments\n          // were included.\n          return\n        }\n        const averageSize = totalBytesReceivedSoFar / fulfilledEntries.length\n        for (const entry of fulfilledEntries) {\n          setSizeInCacheMap(entry, averageSize)\n        }\n      }\n    )\n    const serverData = await (createFromNextReadableStream(\n      prefetchStream,\n      headers\n    ) as Promise<NavigationFlightResponse>)\n\n    const isResponsePartial =\n      fetchStrategy === FetchStrategy.PPRRuntime\n        ? // A runtime prefetch may have holes.\n          serverData.rp?.[0] === true\n        : // Full and LoadingBoundary prefetches cannot have holes.\n          // (even if we did set the prefetch header, we only use this codepath for non-PPR-enabled routes)\n          false\n\n    // Aside from writing the data into the cache, this function also returns\n    // the entries that were fulfilled, so we can streamingly update their sizes\n    // in the LRU as more data comes in.\n    fulfilledEntries = writeDynamicRenderResponseIntoCache(\n      Date.now(),\n      task,\n      fetchStrategy,\n      response as RSCResponse<NavigationFlightResponse>,\n      serverData,\n      isResponsePartial,\n      route,\n      spawnedEntries\n    )\n\n    // Return a promise that resolves when the network connection closes, so\n    // the scheduler can track the number of concurrent network connections.\n    return { value: null, closed: closed.promise }\n  } catch (error) {\n    rejectSegmentEntriesIfStillPending(spawnedEntries, Date.now() + 10 * 1000)\n    return null\n  }\n}\n\nfunction writeDynamicTreeResponseIntoCache(\n  now: number,\n  task: PrefetchTask,\n  fetchStrategy:\n    | FetchStrategy.LoadingBoundary\n    | FetchStrategy.PPRRuntime\n    | FetchStrategy.Full,\n  response: RSCResponse<NavigationFlightResponse>,\n  serverData: NavigationFlightResponse,\n  entry: PendingRouteCacheEntry,\n  couldBeIntercepted: boolean,\n  canonicalUrl: string,\n  routeIsPPREnabled: boolean\n) {\n  // Get the URL that was used to render the target page. This may be different\n  // from the URL in the request URL, if the page was rewritten.\n  const renderedSearch = getRenderedSearch(response)\n\n  const normalizedFlightDataResult = normalizeFlightData(serverData.f)\n  if (\n    // A string result means navigating to this route will result in an\n    // MPA navigation.\n    typeof normalizedFlightDataResult === 'string' ||\n    normalizedFlightDataResult.length !== 1\n  ) {\n    rejectRouteCacheEntry(entry, now + 10 * 1000)\n    return\n  }\n  const flightData = normalizedFlightDataResult[0]\n  if (!flightData.isRootRender) {\n    // Unexpected response format.\n    rejectRouteCacheEntry(entry, now + 10 * 1000)\n    return\n  }\n\n  const flightRouterState = flightData.tree\n  // For runtime prefetches, stale time is in the payload at rp[1].\n  // For other responses, fall back to the header.\n  const staleTimeSeconds =\n    typeof serverData.rp?.[1] === 'number'\n      ? serverData.rp[1]\n      : parseInt(response.headers.get(NEXT_ROUTER_STALE_TIME_HEADER) ?? '', 10)\n  const staleTimeMs = !isNaN(staleTimeSeconds)\n    ? getStaleTimeMs(staleTimeSeconds)\n    : STATIC_STALETIME_MS\n\n  // If the response contains dynamic holes, then we must conservatively assume\n  // that any individual segment might contain dynamic holes, and also the\n  // head. If it did not contain dynamic holes, then we can assume every segment\n  // and the head is completely static.\n  const isResponsePartial =\n    response.headers.get(NEXT_DID_POSTPONE_HEADER) === '1'\n\n  // Convert the server-sent data into the RouteTree format used by the\n  // client cache.\n  //\n  // During this traversal, we accumulate additional data into this\n  // \"accumulator\" object.\n  const acc: RouteTreeAccumulator = { metadataVaryPath: null }\n  const routeTree = convertRootFlightRouterStateToRouteTree(\n    flightRouterState,\n    renderedSearch,\n    acc\n  )\n  const metadataVaryPath = acc.metadataVaryPath\n  if (metadataVaryPath === null) {\n    rejectRouteCacheEntry(entry, now + 10 * 1000)\n    return\n  }\n\n  const fulfilledEntry = fulfillRouteCacheEntry(\n    entry,\n    routeTree,\n    metadataVaryPath,\n    now + staleTimeMs,\n    couldBeIntercepted,\n    canonicalUrl,\n    renderedSearch,\n    routeIsPPREnabled\n  )\n\n  // If the server sent segment data as part of the response, we should write\n  // it into the cache to prevent a second, redundant prefetch request.\n  //\n  // TODO: When `clientSegmentCache` is enabled, the server does not include\n  // segment data when responding to a route tree prefetch request. However,\n  // when `clientSegmentCache` is set to \"client-only\", and PPR is enabled (or\n  // the page is fully static), the normal check is bypassed and the server\n  // responds with the full page. This is a temporary situation until we can\n  // remove the \"client-only\" option. Then, we can delete this function call.\n  writeDynamicRenderResponseIntoCache(\n    now,\n    task,\n    fetchStrategy,\n    response,\n    serverData,\n    isResponsePartial,\n    fulfilledEntry,\n    null\n  )\n}\n\nfunction rejectSegmentEntriesIfStillPending(\n  entries: Map<SegmentRequestKey, SegmentCacheEntry>,\n  staleAt: number\n): Array<FulfilledSegmentCacheEntry> {\n  const fulfilledEntries = []\n  for (const entry of entries.values()) {\n    if (entry.status === EntryStatus.Pending) {\n      rejectSegmentCacheEntry(entry, staleAt)\n    } else if (entry.status === EntryStatus.Fulfilled) {\n      fulfilledEntries.push(entry)\n    }\n  }\n  return fulfilledEntries\n}\n\nfunction writeDynamicRenderResponseIntoCache(\n  now: number,\n  task: PrefetchTask,\n  fetchStrategy:\n    | FetchStrategy.LoadingBoundary\n    | FetchStrategy.PPRRuntime\n    | FetchStrategy.Full,\n  response: RSCResponse<NavigationFlightResponse>,\n  serverData: NavigationFlightResponse,\n  isResponsePartial: boolean,\n  route: FulfilledRouteCacheEntry,\n  spawnedEntries: Map<SegmentRequestKey, PendingSegmentCacheEntry> | null\n): Array<FulfilledSegmentCacheEntry> | null {\n  if (serverData.b !== getAppBuildId()) {\n    // The server build does not match the client. Treat as a 404. During\n    // an actual navigation, the router will trigger an MPA navigation.\n    // TODO: Consider moving the build ID to a response header so we can check\n    // it before decoding the response, and so there's one way of checking\n    // across all response types.\n    if (spawnedEntries !== null) {\n      rejectSegmentEntriesIfStillPending(spawnedEntries, now + 10 * 1000)\n    }\n    return null\n  }\n\n  const flightDatas = normalizeFlightData(serverData.f)\n  if (typeof flightDatas === 'string') {\n    // This means navigating to this route will result in an MPA navigation.\n    // TODO: We should cache this, too, so that the MPA navigation is immediate.\n    return null\n  }\n\n  // For runtime prefetches, stale time is in the payload at rp[1].\n  // For other responses, fall back to the header.\n  const staleTimeSeconds =\n    typeof serverData.rp?.[1] === 'number'\n      ? serverData.rp[1]\n      : parseInt(response.headers.get(NEXT_ROUTER_STALE_TIME_HEADER) ?? '', 10)\n  const staleTimeMs = !isNaN(staleTimeSeconds)\n    ? getStaleTimeMs(staleTimeSeconds)\n    : STATIC_STALETIME_MS\n  const staleAt = now + staleTimeMs\n\n  for (const flightData of flightDatas) {\n    const seedData = flightData.seedData\n    if (seedData !== null) {\n      // The data sent by the server represents only a subtree of the app. We\n      // need to find the part of the task tree that matches the response.\n      //\n      // segmentPath represents the parent path of subtree. It's a repeating\n      // pattern of parallel route key and segment:\n      //\n      //   [string, Segment, string, Segment, string, Segment, ...]\n      const segmentPath = flightData.segmentPath\n      let tree = route.tree\n      for (let i = 0; i < segmentPath.length; i += 2) {\n        const parallelRouteKey: string = segmentPath[i]\n        if (tree?.slots?.[parallelRouteKey] !== undefined) {\n          tree = tree.slots[parallelRouteKey]\n        } else {\n          if (spawnedEntries !== null) {\n            rejectSegmentEntriesIfStillPending(spawnedEntries, now + 10 * 1000)\n          }\n          return null\n        }\n      }\n\n      writeSeedDataIntoCache(\n        now,\n        task,\n        fetchStrategy,\n        route,\n        tree,\n        staleAt,\n        seedData,\n        isResponsePartial,\n        spawnedEntries\n      )\n    }\n\n    const head = flightData.head\n    if (head !== null) {\n      fulfillEntrySpawnedByRuntimePrefetch(\n        now,\n        fetchStrategy,\n        route,\n        head,\n        null,\n        flightData.isHeadPartial,\n        staleAt,\n        route.metadata,\n        spawnedEntries\n      )\n    }\n  }\n  // Any entry that's still pending was intentionally not rendered by the\n  // server, because it was inside the loading boundary. Mark them as rejected\n  // so we know not to fetch them again.\n  // TODO: If PPR is enabled on some routes but not others, then it's possible\n  // that a different page is able to do a per-segment prefetch of one of the\n  // segments we're marking as rejected here. We should mark on the segment\n  // somehow that the reason for the rejection is because of a non-PPR prefetch.\n  // That way a per-segment prefetch knows to disregard the rejection.\n  if (spawnedEntries !== null) {\n    const fulfilledEntries = rejectSegmentEntriesIfStillPending(\n      spawnedEntries,\n      now + 10 * 1000\n    )\n    return fulfilledEntries\n  }\n  return null\n}\n\nfunction writeSeedDataIntoCache(\n  now: number,\n  task: PrefetchTask,\n  fetchStrategy:\n    | FetchStrategy.LoadingBoundary\n    | FetchStrategy.PPRRuntime\n    | FetchStrategy.Full,\n  route: FulfilledRouteCacheEntry,\n  tree: RouteTree,\n  staleAt: number,\n  seedData: CacheNodeSeedData,\n  isResponsePartial: boolean,\n  entriesOwnedByCurrentTask: Map<\n    SegmentRequestKey,\n    PendingSegmentCacheEntry\n  > | null\n) {\n  // This function is used to write the result of a runtime server request\n  // (CacheNodeSeedData) into the prefetch cache.\n  const rsc = seedData[0]\n  const loading = seedData[2]\n  const isPartial = rsc === null || isResponsePartial\n  fulfillEntrySpawnedByRuntimePrefetch(\n    now,\n    fetchStrategy,\n    route,\n    rsc,\n    loading,\n    isPartial,\n    staleAt,\n    tree,\n    entriesOwnedByCurrentTask\n  )\n\n  // Recursively write the child data into the cache.\n  const slots = tree.slots\n  if (slots !== null) {\n    const seedDataChildren = seedData[1]\n    for (const parallelRouteKey in slots) {\n      const childTree = slots[parallelRouteKey]\n      const childSeedData: CacheNodeSeedData | null | void =\n        seedDataChildren[parallelRouteKey]\n      if (childSeedData !== null && childSeedData !== undefined) {\n        writeSeedDataIntoCache(\n          now,\n          task,\n          fetchStrategy,\n          route,\n          childTree,\n          staleAt,\n          childSeedData,\n          isResponsePartial,\n          entriesOwnedByCurrentTask\n        )\n      }\n    }\n  }\n}\n\nfunction fulfillEntrySpawnedByRuntimePrefetch(\n  now: number,\n  fetchStrategy:\n    | FetchStrategy.LoadingBoundary\n    | FetchStrategy.PPRRuntime\n    | FetchStrategy.Full,\n  route: FulfilledRouteCacheEntry,\n  rsc: React.ReactNode,\n  loading: LoadingModuleData | Promise<LoadingModuleData>,\n  isPartial: boolean,\n  staleAt: number,\n  tree: RouteTree,\n  entriesOwnedByCurrentTask: Map<\n    SegmentRequestKey,\n    PendingSegmentCacheEntry\n  > | null\n) {\n  // We should only write into cache entries that are owned by us. Or create\n  // a new one and write into that. We must never write over an entry that was\n  // created by a different task, because that causes data races.\n  const ownedEntry =\n    entriesOwnedByCurrentTask !== null\n      ? entriesOwnedByCurrentTask.get(tree.requestKey)\n      : undefined\n  if (ownedEntry !== undefined) {\n    fulfillSegmentCacheEntry(ownedEntry, rsc, loading, staleAt, isPartial)\n  } else {\n    // There's no matching entry. Attempt to create a new one.\n    const possiblyNewEntry = readOrCreateSegmentCacheEntry(\n      now,\n      fetchStrategy,\n      route,\n      tree\n    )\n    if (possiblyNewEntry.status === EntryStatus.Empty) {\n      // Confirmed this is a new entry. We can fulfill it.\n      const newEntry = possiblyNewEntry\n      fulfillSegmentCacheEntry(\n        upgradeToPendingSegment(newEntry, fetchStrategy),\n        rsc,\n        loading,\n        staleAt,\n        isPartial\n      )\n    } else {\n      // There was already an entry in the cache. But we may be able to\n      // replace it with the new one from the server.\n      const newEntry = fulfillSegmentCacheEntry(\n        upgradeToPendingSegment(\n          createDetachedSegmentCacheEntry(staleAt),\n          fetchStrategy\n        ),\n        rsc,\n        loading,\n        staleAt,\n        isPartial\n      )\n      upsertSegmentEntry(\n        now,\n        getSegmentVaryPathForRequest(fetchStrategy, tree),\n        newEntry\n      )\n    }\n  }\n}\n\nasync function fetchPrefetchResponse<T>(\n  url: URL,\n  headers: RequestHeaders\n): Promise<RSCResponse<T> | null> {\n  const fetchPriority = 'low'\n  // When issuing a prefetch request, don't immediately decode the response; we\n  // use the lower level `createFromResponse` API instead because we need to do\n  // some extra processing of the response stream. See\n  // `createPrefetchResponseStream` for more details.\n  const shouldImmediatelyDecode = false\n  const response = await createFetch<T>(\n    url,\n    headers,\n    fetchPriority,\n    shouldImmediatelyDecode\n  )\n  if (!response.ok) {\n    return null\n  }\n\n  // Check the content type\n  if (isOutputExportMode) {\n    // In output: \"export\" mode, we relaxed about the content type, since it's\n    // not Next.js that's serving the response. If the status is OK, assume the\n    // response is valid. If it's not a valid response, the Flight client won't\n    // be able to decode it, and we'll treat it as a miss.\n  } else {\n    const contentType = response.headers.get('content-type')\n    const isFlightResponse =\n      contentType && contentType.startsWith(RSC_CONTENT_TYPE_HEADER)\n    if (!isFlightResponse) {\n      return null\n    }\n  }\n  return response\n}\n\nfunction createPrefetchResponseStream(\n  originalFlightStream: ReadableStream<Uint8Array>,\n  onStreamClose: () => void,\n  onResponseSizeUpdate: (size: number) => void\n): ReadableStream<Uint8Array> {\n  // When PPR is enabled, prefetch streams may contain references that never\n  // resolve, because that's how we encode dynamic data access. In the decoded\n  // object returned by the Flight client, these are reified into hanging\n  // promises that suspend during render, which is effectively what we want.\n  // The UI resolves when it switches to the dynamic data stream\n  // (via useDeferredValue(dynamic, static)).\n  //\n  // However, the Flight implementation currently errors if the server closes\n  // the response before all the references are resolved. As a cheat to work\n  // around this, we wrap the original stream in a new stream that never closes,\n  // and therefore doesn't error.\n  //\n  // While processing the original stream, we also incrementally update the size\n  // of the cache entry in the LRU.\n  let totalByteLength = 0\n  const reader = originalFlightStream.getReader()\n  return new ReadableStream({\n    async pull(controller) {\n      while (true) {\n        const { done, value } = await reader.read()\n        if (!done) {\n          // Pass to the target stream and keep consuming the Flight response\n          // from the server.\n          controller.enqueue(value)\n\n          // Incrementally update the size of the cache entry in the LRU.\n          // NOTE: Since prefetch responses are delivered in a single chunk,\n          // it's not really necessary to do this streamingly, but I'm doing it\n          // anyway in case this changes in the future.\n          totalByteLength += value.byteLength\n          onResponseSizeUpdate(totalByteLength)\n          continue\n        }\n        // The server stream has closed. Exit, but intentionally do not close\n        // the target stream. We do notify the caller, though.\n        onStreamClose()\n        return\n      }\n    },\n  })\n}\n\nfunction addSegmentPathToUrlInOutputExportMode(\n  url: URL,\n  segmentPath: SegmentRequestKey\n): URL {\n  if (isOutputExportMode) {\n    // In output: \"export\" mode, we cannot use a header to encode the segment\n    // path. Instead, we append it to the end of the pathname.\n    const staticUrl = new URL(url)\n    const routeDir = staticUrl.pathname.endsWith('/')\n      ? staticUrl.pathname.slice(0, -1)\n      : staticUrl.pathname\n    const staticExportFilename =\n      convertSegmentPathToStaticExportFilename(segmentPath)\n    staticUrl.pathname = `${routeDir}/${staticExportFilename}`\n    return staticUrl\n  }\n  return url\n}\n\n/**\n * Checks whether the new fetch strategy is likely to provide more content than the old one.\n *\n * Generally, when an app uses dynamic data, a \"more specific\" fetch strategy is expected to provide more content:\n * - `LoadingBoundary` only provides static layouts\n * - `PPR` can provide shells for each segment (even for segments that use dynamic data)\n * - `PPRRuntime` can additionally include content that uses searchParams, params, or cookies\n * - `Full` includes all the content, even if it uses dynamic data\n *\n * However, it's possible that a more specific fetch strategy *won't* give us more content if:\n * - a segment is fully static\n *   (then, `PPR`/`PPRRuntime`/`Full` will all yield equivalent results)\n * - providing searchParams/params/cookies doesn't reveal any more content, e.g. because of an `await connection()`\n *   (then, `PPR` and `PPRRuntime` will yield equivalent results, only `Full` will give us more)\n * Because of this, when comparing two segments, we should also check if the existing segment is partial.\n * If it's not partial, then there's no need to prefetch it again, even using a \"more specific\" strategy.\n * There's currently no way to know if `PPRRuntime` will yield more data that `PPR`, so we have to assume it will.\n *\n * Also note that, in practice, we don't expect to be comparing `LoadingBoundary` to `PPR`/`PPRRuntime`,\n * because a non-PPR-enabled route wouldn't ever use the latter strategies. It might however use `Full`.\n */\nexport function canNewFetchStrategyProvideMoreContent(\n  currentStrategy: FetchStrategy,\n  newStrategy: FetchStrategy\n): boolean {\n  return currentStrategy < newStrategy\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    cancelPrefetchTask: null,\n    isPrefetchTaskDirty: null,\n    pingPrefetchTask: null,\n    reschedulePrefetchTask: null,\n    schedulePrefetchTask: null,\n    startRevalidationCooldown: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    cancelPrefetchTask: function() {\n        return cancelPrefetchTask;\n    },\n    isPrefetchTaskDirty: function() {\n        return isPrefetchTaskDirty;\n    },\n    pingPrefetchTask: function() {\n        return pingPrefetchTask;\n    },\n    reschedulePrefetchTask: function() {\n        return reschedulePrefetchTask;\n    },\n    schedulePrefetchTask: function() {\n        return schedulePrefetchTask;\n    },\n    startRevalidationCooldown: function() {\n        return startRevalidationCooldown;\n    }\n});\nconst _approutertypes = require(\"../../../shared/lib/app-router-types\");\nconst _matchsegments = require(\"../match-segments\");\nconst _cache = require(\"./cache\");\nconst _varypath = require(\"./vary-path\");\nconst _cachekey = require(\"./cache-key\");\nconst _types = require(\"./types\");\nconst _segment = require(\"../../../shared/lib/segment\");\nconst scheduleMicrotask = typeof queueMicrotask === 'function' ? queueMicrotask : (fn)=>Promise.resolve().then(fn).catch((error)=>setTimeout(()=>{\n            throw error;\n        }));\nconst taskHeap = [];\nlet inProgressRequests = 0;\nlet sortIdCounter = 0;\nlet didScheduleMicrotask = false;\n// The most recently hovered (or touched, etc) link, i.e. the most recent task\n// scheduled at Intent priority. There's only ever a single task at Intent\n// priority at a time. We reserve special network bandwidth for this task only.\nlet mostRecentlyHoveredLink = null;\n// CDN cache propagation delay after revalidation (in milliseconds)\nconst REVALIDATION_COOLDOWN_MS = 300;\n// Timeout handle for the revalidation cooldown. When non-null, prefetch\n// requests are blocked to allow CDN cache propagation.\nlet revalidationCooldownTimeoutHandle = null;\nfunction startRevalidationCooldown() {\n    // Clear any existing timeout in case multiple revalidations happen\n    // in quick succession.\n    if (revalidationCooldownTimeoutHandle !== null) {\n        clearTimeout(revalidationCooldownTimeoutHandle);\n    }\n    // Schedule the cooldown to expire after the delay.\n    revalidationCooldownTimeoutHandle = setTimeout(()=>{\n        revalidationCooldownTimeoutHandle = null;\n        // Retry the prefetch queue now that the cooldown has expired.\n        ensureWorkIsScheduled();\n    }, REVALIDATION_COOLDOWN_MS);\n}\nfunction schedulePrefetchTask(key, treeAtTimeOfPrefetch, fetchStrategy, priority, onInvalidate) {\n    // Spawn a new prefetch task\n    const task = {\n        key,\n        treeAtTimeOfPrefetch,\n        cacheVersion: (0, _cache.getCurrentCacheVersion)(),\n        priority,\n        phase: 1,\n        hasBackgroundWork: false,\n        spawnedRuntimePrefetches: null,\n        fetchStrategy,\n        sortId: sortIdCounter++,\n        isCanceled: false,\n        onInvalidate,\n        _heapIndex: -1\n    };\n    trackMostRecentlyHoveredLink(task);\n    heapPush(taskHeap, task);\n    // Schedule an async task to process the queue.\n    //\n    // The main reason we process the queue in an async task is for batching.\n    // It's common for a single JS task/event to trigger multiple prefetches.\n    // By deferring to a microtask, we only process the queue once per JS task.\n    // If they have different priorities, it also ensures they are processed in\n    // the optimal order.\n    ensureWorkIsScheduled();\n    return task;\n}\nfunction cancelPrefetchTask(task) {\n    // Remove the prefetch task from the queue. If the task already completed,\n    // then this is a no-op.\n    //\n    // We must also explicitly mark the task as canceled so that a blocked task\n    // does not get added back to the queue when it's pinged by the network.\n    task.isCanceled = true;\n    heapDelete(taskHeap, task);\n}\nfunction reschedulePrefetchTask(task, treeAtTimeOfPrefetch, fetchStrategy, priority) {\n    // Bump the prefetch task to the top of the queue, as if it were a fresh\n    // task. This is essentially the same as canceling the task and scheduling\n    // a new one, except it reuses the original object.\n    //\n    // The primary use case is to increase the priority of a Link-initated\n    // prefetch on hover.\n    // Un-cancel the task, in case it was previously canceled.\n    task.isCanceled = false;\n    task.phase = 1;\n    // Assign a new sort ID to move it ahead of all other tasks at the same\n    // priority level. (Higher sort IDs are processed first.)\n    task.sortId = sortIdCounter++;\n    task.priority = // If this task is the most recently hovered link, maintain its\n    // Intent priority, even if the rescheduled priority is lower.\n    task === mostRecentlyHoveredLink ? _types.PrefetchPriority.Intent : priority;\n    task.treeAtTimeOfPrefetch = treeAtTimeOfPrefetch;\n    task.fetchStrategy = fetchStrategy;\n    trackMostRecentlyHoveredLink(task);\n    if (task._heapIndex !== -1) {\n        // The task is already in the queue.\n        heapResift(taskHeap, task);\n    } else {\n        heapPush(taskHeap, task);\n    }\n    ensureWorkIsScheduled();\n}\nfunction isPrefetchTaskDirty(task, nextUrl, tree) {\n    // This is used to quickly bail out of a prefetch task if the result is\n    // guaranteed to not have changed since the task was initiated. This is\n    // strictly an optimization — theoretically, if it always returned true, no\n    // behavior should change because a full prefetch task will effectively\n    // perform the same checks.\n    const currentCacheVersion = (0, _cache.getCurrentCacheVersion)();\n    return task.cacheVersion !== currentCacheVersion || task.treeAtTimeOfPrefetch !== tree || task.key.nextUrl !== nextUrl;\n}\nfunction trackMostRecentlyHoveredLink(task) {\n    // Track the mostly recently hovered link, i.e. the most recently scheduled\n    // task at Intent priority. There must only be one such task at a time.\n    if (task.priority === _types.PrefetchPriority.Intent && task !== mostRecentlyHoveredLink) {\n        if (mostRecentlyHoveredLink !== null) {\n            // Bump the previously hovered link's priority down to Default.\n            if (mostRecentlyHoveredLink.priority !== _types.PrefetchPriority.Background) {\n                mostRecentlyHoveredLink.priority = _types.PrefetchPriority.Default;\n                heapResift(taskHeap, mostRecentlyHoveredLink);\n            }\n        }\n        mostRecentlyHoveredLink = task;\n    }\n}\nfunction ensureWorkIsScheduled() {\n    if (didScheduleMicrotask) {\n        // Already scheduled a task to process the queue\n        return;\n    }\n    didScheduleMicrotask = true;\n    scheduleMicrotask(processQueueInMicrotask);\n}\n/**\n * Checks if we've exceeded the maximum number of concurrent prefetch requests,\n * to avoid saturating the browser's internal network queue. This is a\n * cooperative limit — prefetch tasks should check this before issuing\n * new requests.\n *\n * Also checks if we're within the revalidation cooldown window, during which\n * prefetch requests are delayed to allow CDN cache propagation.\n */ function hasNetworkBandwidth(task) {\n    // Check if we're within the revalidation cooldown window\n    if (revalidationCooldownTimeoutHandle !== null) {\n        // We're within the cooldown window. Return false to prevent prefetching.\n        // When the cooldown expires, the timeout will call ensureWorkIsScheduled()\n        // to retry the queue.\n        return false;\n    }\n    // TODO: Also check if there's an in-progress navigation. We should never\n    // add prefetch requests to the network queue if an actual navigation is\n    // taking place, to ensure there's sufficient bandwidth for render-blocking\n    // data and resources.\n    // TODO: Consider reserving some amount of bandwidth for static prefetches.\n    if (task.priority === _types.PrefetchPriority.Intent) {\n        // The most recently hovered link is allowed to exceed the default limit.\n        //\n        // The goal is to always have enough bandwidth to start a new prefetch\n        // request when hovering over a link.\n        //\n        // However, because we don't abort in-progress requests, it's still possible\n        // we'll run out of bandwidth. When links are hovered in quick succession,\n        // there could be multiple hover requests running simultaneously.\n        return inProgressRequests < 12;\n    }\n    // The default limit is lower than the limit for a hovered link.\n    return inProgressRequests < 4;\n}\nfunction spawnPrefetchSubtask(prefetchSubtask) {\n    // When the scheduler spawns an async task, we don't await its result.\n    // Instead, the async task writes its result directly into the cache, then\n    // pings the scheduler to continue.\n    //\n    // We process server responses streamingly, so the prefetch subtask will\n    // likely resolve before we're finished receiving all the data. The subtask\n    // result includes a promise that resolves once the network connection is\n    // closed. The scheduler uses this to control network bandwidth by tracking\n    // and limiting the number of concurrent requests.\n    inProgressRequests++;\n    return prefetchSubtask.then((result)=>{\n        if (result === null) {\n            // The prefetch task errored before it could start processing the\n            // network stream. Assume the connection is closed.\n            onPrefetchConnectionClosed();\n            return null;\n        }\n        // Wait for the connection to close before freeing up more bandwidth.\n        result.closed.then(onPrefetchConnectionClosed);\n        return result.value;\n    });\n}\nfunction onPrefetchConnectionClosed() {\n    inProgressRequests--;\n    // Notify the scheduler that we have more bandwidth, and can continue\n    // processing tasks.\n    ensureWorkIsScheduled();\n}\nfunction pingPrefetchTask(task) {\n    // \"Ping\" a prefetch that's already in progress to notify it of new data.\n    if (// Check if prefetch was canceled.\n    task.isCanceled || // Check if prefetch is already queued.\n    task._heapIndex !== -1) {\n        return;\n    }\n    // Add the task back to the queue.\n    heapPush(taskHeap, task);\n    ensureWorkIsScheduled();\n}\nfunction processQueueInMicrotask() {\n    didScheduleMicrotask = false;\n    // We aim to minimize how often we read the current time. Since nearly all\n    // functions in the prefetch scheduler are synchronous, we can read the time\n    // once and pass it as an argument wherever it's needed.\n    const now = Date.now();\n    // Process the task queue until we run out of network bandwidth.\n    let task = heapPeek(taskHeap);\n    while(task !== null && hasNetworkBandwidth(task)){\n        task.cacheVersion = (0, _cache.getCurrentCacheVersion)();\n        const exitStatus = pingRoute(now, task);\n        // These fields are only valid for a single attempt. Reset them after each\n        // iteration of the task queue.\n        const hasBackgroundWork = task.hasBackgroundWork;\n        task.hasBackgroundWork = false;\n        task.spawnedRuntimePrefetches = null;\n        switch(exitStatus){\n            case 0:\n                // The task yielded because there are too many requests in progress.\n                // Stop processing tasks until we have more bandwidth.\n                return;\n            case 1:\n                // The task is blocked. It needs more data before it can proceed.\n                // Keep the task out of the queue until the server responds.\n                heapPop(taskHeap);\n                // Continue to the next task\n                task = heapPeek(taskHeap);\n                continue;\n            case 2:\n                if (task.phase === 1) {\n                    // Finished prefetching the route tree. Proceed to prefetching\n                    // the segments.\n                    task.phase = 0;\n                    heapResift(taskHeap, task);\n                } else if (hasBackgroundWork) {\n                    // The task spawned additional background work. Reschedule the task\n                    // at background priority.\n                    task.priority = _types.PrefetchPriority.Background;\n                    heapResift(taskHeap, task);\n                } else {\n                    // The prefetch is complete. Continue to the next task.\n                    heapPop(taskHeap);\n                }\n                task = heapPeek(taskHeap);\n                continue;\n            default:\n                exitStatus;\n        }\n    }\n}\n/**\n * Check this during a prefetch task to determine if background work can be\n * performed. If so, it evaluates to `true`. Otherwise, it returns `false`,\n * while also scheduling a background task to run later. Usage:\n *\n * @example\n * if (background(task)) {\n *   // Perform background-pri work\n * }\n */ function background(task) {\n    if (task.priority === _types.PrefetchPriority.Background) {\n        return true;\n    }\n    task.hasBackgroundWork = true;\n    return false;\n}\nfunction pingRoute(now, task) {\n    const key = task.key;\n    const route = (0, _cache.readOrCreateRouteCacheEntry)(now, task, key);\n    const exitStatus = pingRootRouteTree(now, task, route);\n    if (exitStatus !== 0 && key.search !== '') {\n        // If the URL has a non-empty search string, also prefetch the pathname\n        // without the search string. We use the searchless route tree as a base for\n        // optimistic routing; see requestOptimisticRouteCacheEntry for details.\n        //\n        // Note that we don't need to prefetch any of the segment data. Just the\n        // route tree.\n        //\n        // TODO: This is a temporary solution; the plan is to replace this by adding\n        // a wildcard lookup method to the TupleMap implementation. This is\n        // non-trivial to implement because it needs to account for things like\n        // fallback route entries, hence this temporary workaround.\n        const url = new URL(key.pathname, location.origin);\n        const keyWithoutSearch = (0, _cachekey.createCacheKey)(url.href, key.nextUrl);\n        const routeWithoutSearch = (0, _cache.readOrCreateRouteCacheEntry)(now, task, keyWithoutSearch);\n        switch(routeWithoutSearch.status){\n            case _cache.EntryStatus.Empty:\n                {\n                    if (background(task)) {\n                        routeWithoutSearch.status = _cache.EntryStatus.Pending;\n                        spawnPrefetchSubtask((0, _cache.fetchRouteOnCacheMiss)(routeWithoutSearch, task, keyWithoutSearch));\n                    }\n                    break;\n                }\n            case _cache.EntryStatus.Pending:\n            case _cache.EntryStatus.Fulfilled:\n            case _cache.EntryStatus.Rejected:\n                {\n                    break;\n                }\n            default:\n                routeWithoutSearch;\n        }\n    }\n    return exitStatus;\n}\nfunction pingRootRouteTree(now, task, route) {\n    switch(route.status){\n        case _cache.EntryStatus.Empty:\n            {\n                // Route is not yet cached, and there's no request already in progress.\n                // Spawn a task to request the route, load it into the cache, and ping\n                // the task to continue.\n                // TODO: There are multiple strategies in the <Link> API for prefetching\n                // a route. Currently we've only implemented the main one: per-segment,\n                // static-data only.\n                //\n                // There's also `<Link prefetch={true}>`\n                // which prefetch both static *and* dynamic data.\n                // Similarly, we need to fallback to the old, per-page\n                // behavior if PPR is disabled for a route (via the incremental opt-in).\n                //\n                // Those cases will be handled here.\n                spawnPrefetchSubtask((0, _cache.fetchRouteOnCacheMiss)(route, task, task.key));\n                // If the request takes longer than a minute, a subsequent request should\n                // retry instead of waiting for this one. When the response is received,\n                // this value will be replaced by a new value based on the stale time sent\n                // from the server.\n                // TODO: We should probably also manually abort the fetch task, to reclaim\n                // server bandwidth.\n                route.staleAt = now + 60 * 1000;\n                // Upgrade to Pending so we know there's already a request in progress\n                route.status = _cache.EntryStatus.Pending;\n            // Intentional fallthrough to the Pending branch\n            }\n        case _cache.EntryStatus.Pending:\n            {\n                // Still pending. We can't start prefetching the segments until the route\n                // tree has loaded. Add the task to the set of blocked tasks so that it\n                // is notified when the route tree is ready.\n                const blockedTasks = route.blockedTasks;\n                if (blockedTasks === null) {\n                    route.blockedTasks = new Set([\n                        task\n                    ]);\n                } else {\n                    blockedTasks.add(task);\n                }\n                return 1;\n            }\n        case _cache.EntryStatus.Rejected:\n            {\n                // Route tree failed to load. Treat as a 404.\n                return 2;\n            }\n        case _cache.EntryStatus.Fulfilled:\n            {\n                if (task.phase !== 0) {\n                    // Do not prefetch segment data until we've entered the segment phase.\n                    return 2;\n                }\n                // Recursively fill in the segment tree.\n                if (!hasNetworkBandwidth(task)) {\n                    // Stop prefetching segments until there's more bandwidth.\n                    return 0;\n                }\n                const tree = route.tree;\n                // A task's fetch strategy gets set to `PPR` for any \"auto\" prefetch.\n                // If it turned out that the route isn't PPR-enabled, we need to use `LoadingBoundary` instead.\n                // We don't need to do this for runtime prefetches, because those are only available in\n                // `cacheComponents`, where every route is PPR.\n                const fetchStrategy = task.fetchStrategy === _types.FetchStrategy.PPR ? route.isPPREnabled ? _types.FetchStrategy.PPR : _types.FetchStrategy.LoadingBoundary : task.fetchStrategy;\n                switch(fetchStrategy){\n                    case _types.FetchStrategy.PPR:\n                        {\n                            // For Cache Components pages, each segment may be prefetched\n                            // statically or using a runtime request, based on various\n                            // configurations and heuristics. We'll do this in two passes: first\n                            // traverse the tree and perform all the static prefetches.\n                            //\n                            // Then, if there are any segments that need a runtime request,\n                            // do another pass to perform a runtime prefetch.\n                            pingStaticHead(now, task, route);\n                            const exitStatus = pingSharedPartOfCacheComponentsTree(now, task, route, task.treeAtTimeOfPrefetch, tree);\n                            if (exitStatus === 0) {\n                                // Child yielded without finishing.\n                                return 0;\n                            }\n                            const spawnedRuntimePrefetches = task.spawnedRuntimePrefetches;\n                            if (spawnedRuntimePrefetches !== null) {\n                                // During the first pass, we discovered segments that require a\n                                // runtime prefetch. Do a second pass to construct a request tree.\n                                const spawnedEntries = new Map();\n                                pingRuntimeHead(now, task, route, spawnedEntries, _types.FetchStrategy.PPRRuntime);\n                                const requestTree = pingRuntimePrefetches(now, task, route, tree, spawnedRuntimePrefetches, spawnedEntries);\n                                let needsDynamicRequest = spawnedEntries.size > 0;\n                                if (needsDynamicRequest) {\n                                    // Perform a dynamic prefetch request and populate the cache with\n                                    // the result.\n                                    spawnPrefetchSubtask((0, _cache.fetchSegmentPrefetchesUsingDynamicRequest)(task, route, _types.FetchStrategy.PPRRuntime, requestTree, spawnedEntries));\n                                }\n                            }\n                            return 2;\n                        }\n                    case _types.FetchStrategy.Full:\n                    case _types.FetchStrategy.PPRRuntime:\n                    case _types.FetchStrategy.LoadingBoundary:\n                        {\n                            // Prefetch multiple segments using a single dynamic request.\n                            // TODO: We can consolidate this branch with previous one by modeling\n                            // it as if the first segment in the new tree has runtime prefetching\n                            // enabled. Will do this as a follow-up refactor. Might want to remove\n                            // the special metatdata case below first. In the meantime, it's not\n                            // really that much duplication, just would be nice to remove one of\n                            // these codepaths.\n                            const spawnedEntries = new Map();\n                            pingRuntimeHead(now, task, route, spawnedEntries, fetchStrategy);\n                            const dynamicRequestTree = diffRouteTreeAgainstCurrent(now, task, route, task.treeAtTimeOfPrefetch, tree, spawnedEntries, fetchStrategy);\n                            let needsDynamicRequest = spawnedEntries.size > 0;\n                            if (needsDynamicRequest) {\n                                spawnPrefetchSubtask((0, _cache.fetchSegmentPrefetchesUsingDynamicRequest)(task, route, fetchStrategy, dynamicRequestTree, spawnedEntries));\n                            }\n                            return 2;\n                        }\n                    default:\n                        fetchStrategy;\n                }\n                break;\n            }\n        default:\n            {\n                route;\n            }\n    }\n    return 2;\n}\nfunction pingStaticHead(now, task, route) {\n    // The Head data for a page (metadata, viewport) is not really a route\n    // segment, in the sense that it doesn't appear in the route tree. But we\n    // store it in the cache as if it were, using a special key.\n    pingStaticSegmentData(now, task, route, (0, _cache.readOrCreateSegmentCacheEntry)(now, _types.FetchStrategy.PPR, route, route.metadata), task.key, route.metadata);\n}\nfunction pingRuntimeHead(now, task, route, spawnedEntries, fetchStrategy) {\n    pingRouteTreeAndIncludeDynamicData(now, task, route, route.metadata, false, spawnedEntries, // When prefetching the head, there's no difference between Full\n    // and LoadingBoundary\n    fetchStrategy === _types.FetchStrategy.LoadingBoundary ? _types.FetchStrategy.Full : fetchStrategy);\n}\n// TODO: Rename dynamic -> runtime throughout this module\nfunction pingSharedPartOfCacheComponentsTree(now, task, route, oldTree, newTree) {\n    // When Cache Components is enabled (or PPR, or a fully static route when PPR\n    // is disabled; those cases are treated equivalently to Cache Components), we\n    // start by prefetching each segment individually. Once we reach the \"new\"\n    // part of the tree — the part that doesn't exist on the current page — we\n    // may choose to switch to a runtime prefetch instead, based on the\n    // information sent by the server in the route tree.\n    //\n    // The traversal starts in the \"shared\" part of the tree. Once we reach the\n    // \"new\" part of the tree, we switch to a different traversal,\n    // pingNewPartOfCacheComponentsTree.\n    // Prefetch this segment's static data.\n    const segment = (0, _cache.readOrCreateSegmentCacheEntry)(now, task.fetchStrategy, route, newTree);\n    pingStaticSegmentData(now, task, route, segment, task.key, newTree);\n    // Recursively ping the children.\n    const oldTreeChildren = oldTree[1];\n    const newTreeChildren = newTree.slots;\n    if (newTreeChildren !== null) {\n        for(const parallelRouteKey in newTreeChildren){\n            if (!hasNetworkBandwidth(task)) {\n                // Stop prefetching segments until there's more bandwidth.\n                return 0;\n            }\n            const newTreeChild = newTreeChildren[parallelRouteKey];\n            const newTreeChildSegment = newTreeChild.segment;\n            const oldTreeChild = oldTreeChildren[parallelRouteKey];\n            const oldTreeChildSegment = oldTreeChild?.[0];\n            let childExitStatus;\n            if (oldTreeChildSegment !== undefined && doesCurrentSegmentMatchCachedSegment(route, newTreeChildSegment, oldTreeChildSegment)) {\n                // We're still in the \"shared\" part of the tree.\n                childExitStatus = pingSharedPartOfCacheComponentsTree(now, task, route, oldTreeChild, newTreeChild);\n            } else {\n                // We've entered the \"new\" part of the tree. Switch\n                // traversal functions.\n                childExitStatus = pingNewPartOfCacheComponentsTree(now, task, route, newTreeChild);\n            }\n            if (childExitStatus === 0) {\n                // Child yielded without finishing.\n                return 0;\n            }\n        }\n    }\n    return 2;\n}\nfunction pingNewPartOfCacheComponentsTree(now, task, route, tree) {\n    // We're now prefetching in the \"new\" part of the tree, the part that doesn't\n    // exist on the current page. (In other words, we're deeper than the\n    // shared layouts.) Segments in here default to being prefetched statically.\n    // However, if the server instructs us to, we may switch to a runtime\n    // prefetch instead. Traverse the tree and check at each segment.\n    if (tree.hasRuntimePrefetch) {\n        // This route has a runtime prefetch response. Since we're below the shared\n        // layout, everything from this point should be prefetched using a single,\n        // combined runtime request, rather than using per-segment static requests.\n        // This is true even if some of the child segments are known to be fully\n        // static — once we've decided to perform a runtime prefetch, we might as\n        // well respond with the static segments in the same roundtrip. (That's how\n        // regular navigations work, too.) We'll still skip over segments that are\n        // already cached, though.\n        //\n        // It's the server's responsibility to set a reasonable value of\n        // `hasRuntimePrefetch`. Currently it's user-defined, but eventually, the\n        // server may send a value of `false` even if the user opts in, if it\n        // determines during build that the route is always fully static. There are\n        // more optimizations we can do once we implement fallback param\n        // tracking, too.\n        //\n        // Use the task object to collect the segments that need a runtime prefetch.\n        // This will signal to the outer task queue that a second traversal is\n        // required to construct a request tree.\n        if (task.spawnedRuntimePrefetches === null) {\n            task.spawnedRuntimePrefetches = new Set([\n                tree.requestKey\n            ]);\n        } else {\n            task.spawnedRuntimePrefetches.add(tree.requestKey);\n        }\n        // Then exit the traversal without prefetching anything further.\n        return 2;\n    }\n    // This segment should not be runtime prefetched. Prefetch its static data.\n    const segment = (0, _cache.readOrCreateSegmentCacheEntry)(now, task.fetchStrategy, route, tree);\n    pingStaticSegmentData(now, task, route, segment, task.key, tree);\n    if (tree.slots !== null) {\n        if (!hasNetworkBandwidth(task)) {\n            // Stop prefetching segments until there's more bandwidth.\n            return 0;\n        }\n        // Recursively ping the children.\n        for(const parallelRouteKey in tree.slots){\n            const childTree = tree.slots[parallelRouteKey];\n            const childExitStatus = pingNewPartOfCacheComponentsTree(now, task, route, childTree);\n            if (childExitStatus === 0) {\n                // Child yielded without finishing.\n                return 0;\n            }\n        }\n    }\n    // This segment and all its children have finished prefetching.\n    return 2;\n}\nfunction diffRouteTreeAgainstCurrent(now, task, route, oldTree, newTree, spawnedEntries, fetchStrategy) {\n    // This is a single recursive traversal that does multiple things:\n    // - Finds the parts of the target route (newTree) that are not part of\n    //   of the current page (oldTree) by diffing them, using the same algorithm\n    //   as a real navigation.\n    // - Constructs a request tree (FlightRouterState) that describes which\n    //   segments need to be prefetched and which ones are already cached.\n    // - Creates a set of pending cache entries for the segments that need to\n    //   be prefetched, so that a subsequent prefetch task does not request the\n    //   same segments again.\n    const oldTreeChildren = oldTree[1];\n    const newTreeChildren = newTree.slots;\n    let requestTreeChildren = {};\n    if (newTreeChildren !== null) {\n        for(const parallelRouteKey in newTreeChildren){\n            const newTreeChild = newTreeChildren[parallelRouteKey];\n            const newTreeChildSegment = newTreeChild.segment;\n            const oldTreeChild = oldTreeChildren[parallelRouteKey];\n            const oldTreeChildSegment = oldTreeChild?.[0];\n            if (oldTreeChildSegment !== undefined && doesCurrentSegmentMatchCachedSegment(route, newTreeChildSegment, oldTreeChildSegment)) {\n                // This segment is already part of the current route. Keep traversing.\n                const requestTreeChild = diffRouteTreeAgainstCurrent(now, task, route, oldTreeChild, newTreeChild, spawnedEntries, fetchStrategy);\n                requestTreeChildren[parallelRouteKey] = requestTreeChild;\n            } else {\n                // This segment is not part of the current route. We're entering a\n                // part of the tree that we need to prefetch (unless everything is\n                // already cached).\n                switch(fetchStrategy){\n                    case _types.FetchStrategy.LoadingBoundary:\n                        {\n                            // When PPR is disabled, we can't prefetch per segment. We must\n                            // fallback to the old prefetch behavior and send a dynamic request.\n                            // Only routes that include a loading boundary can be prefetched in\n                            // this way.\n                            //\n                            // This is simlar to a \"full\" prefetch, but we're much more\n                            // conservative about which segments to include in the request.\n                            //\n                            // The server will only render up to the first loading boundary\n                            // inside new part of the tree. If there's no loading boundary\n                            // anywhere in the tree, the server will never return any data, so\n                            // we can skip the request.\n                            const subtreeHasLoadingBoundary = newTreeChild.hasLoadingBoundary !== _approutertypes.HasLoadingBoundary.SubtreeHasNoLoadingBoundary;\n                            const requestTreeChild = subtreeHasLoadingBoundary ? pingPPRDisabledRouteTreeUpToLoadingBoundary(now, task, route, newTreeChild, null, spawnedEntries) : (0, _cache.convertRouteTreeToFlightRouterState)(newTreeChild);\n                            requestTreeChildren[parallelRouteKey] = requestTreeChild;\n                            break;\n                        }\n                    case _types.FetchStrategy.PPRRuntime:\n                        {\n                            // This is a runtime prefetch. Fetch all cacheable data in the tree,\n                            // not just the static PPR shell.\n                            const requestTreeChild = pingRouteTreeAndIncludeDynamicData(now, task, route, newTreeChild, false, spawnedEntries, fetchStrategy);\n                            requestTreeChildren[parallelRouteKey] = requestTreeChild;\n                            break;\n                        }\n                    case _types.FetchStrategy.Full:\n                        {\n                            // This is a \"full\" prefetch. Fetch all the data in the tree, both\n                            // static and dynamic. We issue roughly the same request that we\n                            // would during a real navigation. The goal is that once the\n                            // navigation occurs, the router should not have to fetch any\n                            // additional data.\n                            //\n                            // Although the response will include dynamic data, opting into a\n                            // Full prefetch — via <Link prefetch={true}> — implicitly\n                            // instructs the cache to treat the response as \"static\", or non-\n                            // dynamic, since the whole point is to cache it for\n                            // future navigations.\n                            //\n                            // Construct a tree (currently a FlightRouterState) that represents\n                            // which segments need to be prefetched and which ones are already\n                            // cached. If the tree is empty, then we can exit. Otherwise, we'll\n                            // send the request tree to the server and use the response to\n                            // populate the segment cache.\n                            const requestTreeChild = pingRouteTreeAndIncludeDynamicData(now, task, route, newTreeChild, false, spawnedEntries, fetchStrategy);\n                            requestTreeChildren[parallelRouteKey] = requestTreeChild;\n                            break;\n                        }\n                    default:\n                        fetchStrategy;\n                }\n            }\n        }\n    }\n    const requestTree = [\n        newTree.segment,\n        requestTreeChildren,\n        null,\n        null,\n        newTree.isRootLayout\n    ];\n    return requestTree;\n}\nfunction pingPPRDisabledRouteTreeUpToLoadingBoundary(now, task, route, tree, refetchMarkerContext, spawnedEntries) {\n    // This function is similar to pingRouteTreeAndIncludeDynamicData, except the\n    // server is only going to return a minimal loading state — it will stop\n    // rendering at the first loading boundary. Whereas a Full prefetch is\n    // intentionally aggressive and tries to pretfetch all the data that will be\n    // needed for a navigation, a LoadingBoundary prefetch is much more\n    // conservative. For example, it will omit from the request tree any segment\n    // that is already cached, regardles of whether it's partial or full. By\n    // contrast, a Full prefetch will refetch partial segments.\n    // \"inside-shared-layout\" tells the server where to start looking for a\n    // loading boundary.\n    let refetchMarker = refetchMarkerContext === null ? 'inside-shared-layout' : null;\n    const segment = (0, _cache.readOrCreateSegmentCacheEntry)(now, task.fetchStrategy, route, tree);\n    switch(segment.status){\n        case _cache.EntryStatus.Empty:\n            {\n                // This segment is not cached. Add a refetch marker so the server knows\n                // to start rendering here.\n                // TODO: Instead of a \"refetch\" marker, we could just omit this subtree's\n                // FlightRouterState from the request tree. I think this would probably\n                // already work even without any updates to the server. For consistency,\n                // though, I'll send the full tree and we'll look into this later as part\n                // of a larger redesign of the request protocol.\n                // Add the pending cache entry to the result map.\n                spawnedEntries.set(tree.requestKey, (0, _cache.upgradeToPendingSegment)(segment, // Set the fetch strategy to LoadingBoundary to indicate that the server\n                // might not include it in the pending response. If another route is able\n                // to issue a per-segment request, we'll do that in the background.\n                _types.FetchStrategy.LoadingBoundary));\n                if (refetchMarkerContext !== 'refetch') {\n                    refetchMarker = refetchMarkerContext = 'refetch';\n                } else {\n                // There's already a parent with a refetch marker, so we don't need\n                // to add another one.\n                }\n                break;\n            }\n        case _cache.EntryStatus.Fulfilled:\n            {\n                // The segment is already cached.\n                const segmentHasLoadingBoundary = tree.hasLoadingBoundary === _approutertypes.HasLoadingBoundary.SegmentHasLoadingBoundary;\n                if (segmentHasLoadingBoundary) {\n                    // This segment has a loading boundary, which means the server won't\n                    // render its children. So there's nothing left to prefetch along this\n                    // path. We can bail out.\n                    return (0, _cache.convertRouteTreeToFlightRouterState)(tree);\n                }\n                break;\n            }\n        case _cache.EntryStatus.Pending:\n            {\n                break;\n            }\n        case _cache.EntryStatus.Rejected:\n            {\n                break;\n            }\n        default:\n            segment;\n    }\n    const requestTreeChildren = {};\n    if (tree.slots !== null) {\n        for(const parallelRouteKey in tree.slots){\n            const childTree = tree.slots[parallelRouteKey];\n            requestTreeChildren[parallelRouteKey] = pingPPRDisabledRouteTreeUpToLoadingBoundary(now, task, route, childTree, refetchMarkerContext, spawnedEntries);\n        }\n    }\n    const requestTree = [\n        tree.segment,\n        requestTreeChildren,\n        null,\n        refetchMarker,\n        tree.isRootLayout\n    ];\n    return requestTree;\n}\nfunction pingRouteTreeAndIncludeDynamicData(now, task, route, tree, isInsideRefetchingParent, spawnedEntries, fetchStrategy) {\n    // The tree we're constructing is the same shape as the tree we're navigating\n    // to. But even though this is a \"new\" tree, some of the individual segments\n    // may be cached as a result of other route prefetches.\n    //\n    // So we need to find the first uncached segment along each path add an\n    // explicit \"refetch\" marker so the server knows where to start rendering.\n    // Once the server starts rendering along a path, it keeps rendering the\n    // entire subtree.\n    const segment = (0, _cache.readOrCreateSegmentCacheEntry)(now, // Note that `fetchStrategy` might be different from `task.fetchStrategy`,\n    // and we have to use the former here.\n    // We can have a task with `FetchStrategy.PPR` where some of its segments are configured to\n    // always use runtime prefetching (via `export const prefetch`), and those should check for\n    // entries that include search params.\n    fetchStrategy, route, tree);\n    let spawnedSegment = null;\n    switch(segment.status){\n        case _cache.EntryStatus.Empty:\n            {\n                // This segment is not cached. Include it in the request.\n                spawnedSegment = (0, _cache.upgradeToPendingSegment)(segment, fetchStrategy);\n                break;\n            }\n        case _cache.EntryStatus.Fulfilled:\n            {\n                // The segment is already cached.\n                if (segment.isPartial && (0, _cache.canNewFetchStrategyProvideMoreContent)(segment.fetchStrategy, fetchStrategy)) {\n                    // The cached segment contains dynamic holes, and was prefetched using a less specific strategy than the current one.\n                    // This means we're in one of these cases:\n                    //   - we have a static prefetch, and we're doing a runtime prefetch\n                    //   - we have a static or runtime prefetch, and we're doing a Full prefetch (or a navigation).\n                    // In either case, we need to include it in the request to get a more specific (or full) version.\n                    spawnedSegment = pingFullSegmentRevalidation(now, route, tree, fetchStrategy);\n                }\n                break;\n            }\n        case _cache.EntryStatus.Pending:\n        case _cache.EntryStatus.Rejected:\n            {\n                // There's either another prefetch currently in progress, or the previous\n                // attempt failed. If the new strategy can provide more content, fetch it again.\n                if ((0, _cache.canNewFetchStrategyProvideMoreContent)(segment.fetchStrategy, fetchStrategy)) {\n                    spawnedSegment = pingFullSegmentRevalidation(now, route, tree, fetchStrategy);\n                }\n                break;\n            }\n        default:\n            segment;\n    }\n    const requestTreeChildren = {};\n    if (tree.slots !== null) {\n        for(const parallelRouteKey in tree.slots){\n            const childTree = tree.slots[parallelRouteKey];\n            requestTreeChildren[parallelRouteKey] = pingRouteTreeAndIncludeDynamicData(now, task, route, childTree, isInsideRefetchingParent || spawnedSegment !== null, spawnedEntries, fetchStrategy);\n        }\n    }\n    if (spawnedSegment !== null) {\n        // Add the pending entry to the result map.\n        spawnedEntries.set(tree.requestKey, spawnedSegment);\n    }\n    // Don't bother to add a refetch marker if one is already present in a parent.\n    const refetchMarker = !isInsideRefetchingParent && spawnedSegment !== null ? 'refetch' : null;\n    const requestTree = [\n        tree.segment,\n        requestTreeChildren,\n        null,\n        refetchMarker,\n        tree.isRootLayout\n    ];\n    return requestTree;\n}\nfunction pingRuntimePrefetches(now, task, route, tree, spawnedRuntimePrefetches, spawnedEntries) {\n    // Construct a request tree (FlightRouterState) for a runtime prefetch. If\n    // a segment is part of the runtime prefetch, the tree is constructed by\n    // diffing against what's already in the prefetch cache. Otherwise, we send\n    // a regular FlightRouterState with no special markers.\n    //\n    // See pingRouteTreeAndIncludeDynamicData for details.\n    if (spawnedRuntimePrefetches.has(tree.requestKey)) {\n        // This segment needs a runtime prefetch.\n        return pingRouteTreeAndIncludeDynamicData(now, task, route, tree, false, spawnedEntries, _types.FetchStrategy.PPRRuntime);\n    }\n    let requestTreeChildren = {};\n    const slots = tree.slots;\n    if (slots !== null) {\n        for(const parallelRouteKey in slots){\n            const childTree = slots[parallelRouteKey];\n            requestTreeChildren[parallelRouteKey] = pingRuntimePrefetches(now, task, route, childTree, spawnedRuntimePrefetches, spawnedEntries);\n        }\n    }\n    // This segment is not part of the runtime prefetch. Clone the base tree.\n    const requestTree = [\n        tree.segment,\n        requestTreeChildren,\n        null,\n        null\n    ];\n    return requestTree;\n}\nfunction pingStaticSegmentData(now, task, route, segment, routeKey, tree) {\n    switch(segment.status){\n        case _cache.EntryStatus.Empty:\n            // Upgrade to Pending so we know there's already a request in progress\n            spawnPrefetchSubtask((0, _cache.fetchSegmentOnCacheMiss)(route, (0, _cache.upgradeToPendingSegment)(segment, _types.FetchStrategy.PPR), routeKey, tree));\n            break;\n        case _cache.EntryStatus.Pending:\n            {\n                // There's already a request in progress. Depending on what kind of\n                // request it is, we may want to revalidate it.\n                switch(segment.fetchStrategy){\n                    case _types.FetchStrategy.PPR:\n                    case _types.FetchStrategy.PPRRuntime:\n                    case _types.FetchStrategy.Full:\n                        break;\n                    case _types.FetchStrategy.LoadingBoundary:\n                        // There's a pending request, but because it's using the old\n                        // prefetching strategy, we can't be sure if it will be fulfilled by\n                        // the response — it might be inside the loading boundary. Perform\n                        // a revalidation, but because it's speculative, wait to do it at\n                        // background priority.\n                        if (background(task)) {\n                            // TODO: Instead of speculatively revalidating, consider including\n                            // `hasLoading` in the route tree prefetch response.\n                            pingPPRSegmentRevalidation(now, route, routeKey, tree);\n                        }\n                        break;\n                    default:\n                        segment.fetchStrategy;\n                }\n                break;\n            }\n        case _cache.EntryStatus.Rejected:\n            {\n                // The existing entry in the cache was rejected. Depending on how it\n                // was originally fetched, we may or may not want to revalidate it.\n                switch(segment.fetchStrategy){\n                    case _types.FetchStrategy.PPR:\n                    case _types.FetchStrategy.PPRRuntime:\n                    case _types.FetchStrategy.Full:\n                        break;\n                    case _types.FetchStrategy.LoadingBoundary:\n                        // There's a rejected entry, but it was fetched using the loading\n                        // boundary strategy. So the reason it wasn't returned by the server\n                        // might just be because it was inside a loading boundary. Or because\n                        // there was a dynamic rewrite. Revalidate it using the per-\n                        // segment strategy.\n                        //\n                        // Because a rejected segment will definitely prevent the segment (and\n                        // all of its children) from rendering, we perform this revalidation\n                        // immediately instead of deferring it to a background task.\n                        pingPPRSegmentRevalidation(now, route, routeKey, tree);\n                        break;\n                    default:\n                        segment.fetchStrategy;\n                }\n                break;\n            }\n        case _cache.EntryStatus.Fulfilled:\n            break;\n        default:\n            segment;\n    }\n// Segments do not have dependent tasks, so once the prefetch is initiated,\n// there's nothing else for us to do (except write the server data into the\n// entry, which is handled by `fetchSegmentOnCacheMiss`).\n}\nfunction pingPPRSegmentRevalidation(now, route, routeKey, tree) {\n    const revalidatingSegment = (0, _cache.readOrCreateRevalidatingSegmentEntry)(now, _types.FetchStrategy.PPR, route, tree);\n    switch(revalidatingSegment.status){\n        case _cache.EntryStatus.Empty:\n            // Spawn a prefetch request and upsert the segment into the cache\n            // upon completion.\n            upsertSegmentOnCompletion(spawnPrefetchSubtask((0, _cache.fetchSegmentOnCacheMiss)(route, (0, _cache.upgradeToPendingSegment)(revalidatingSegment, _types.FetchStrategy.PPR), routeKey, tree)), (0, _varypath.getSegmentVaryPathForRequest)(_types.FetchStrategy.PPR, tree));\n            break;\n        case _cache.EntryStatus.Pending:\n            break;\n        case _cache.EntryStatus.Fulfilled:\n        case _cache.EntryStatus.Rejected:\n            break;\n        default:\n            revalidatingSegment;\n    }\n}\nfunction pingFullSegmentRevalidation(now, route, tree, fetchStrategy) {\n    const revalidatingSegment = (0, _cache.readOrCreateRevalidatingSegmentEntry)(now, fetchStrategy, route, tree);\n    if (revalidatingSegment.status === _cache.EntryStatus.Empty) {\n        // During a Full/PPRRuntime prefetch, a single dynamic request is made for all the\n        // segments that we need. So we don't initiate a request here directly. By\n        // returning a pending entry from this function, it signals to the caller\n        // that this segment should be included in the request that's sent to\n        // the server.\n        const pendingSegment = (0, _cache.upgradeToPendingSegment)(revalidatingSegment, fetchStrategy);\n        upsertSegmentOnCompletion((0, _cache.waitForSegmentCacheEntry)(pendingSegment), (0, _varypath.getSegmentVaryPathForRequest)(fetchStrategy, tree));\n        return pendingSegment;\n    } else {\n        // There's already a revalidation in progress.\n        const nonEmptyRevalidatingSegment = revalidatingSegment;\n        if ((0, _cache.canNewFetchStrategyProvideMoreContent)(nonEmptyRevalidatingSegment.fetchStrategy, fetchStrategy)) {\n            // The existing revalidation was fetched using a less specific strategy.\n            // Reset it and start a new revalidation.\n            const emptySegment = (0, _cache.overwriteRevalidatingSegmentCacheEntry)(fetchStrategy, route, tree);\n            const pendingSegment = (0, _cache.upgradeToPendingSegment)(emptySegment, fetchStrategy);\n            upsertSegmentOnCompletion((0, _cache.waitForSegmentCacheEntry)(pendingSegment), (0, _varypath.getSegmentVaryPathForRequest)(fetchStrategy, tree));\n            return pendingSegment;\n        }\n        switch(nonEmptyRevalidatingSegment.status){\n            case _cache.EntryStatus.Pending:\n                // There's already an in-progress prefetch that includes this segment.\n                return null;\n            case _cache.EntryStatus.Fulfilled:\n            case _cache.EntryStatus.Rejected:\n                // A previous revalidation attempt finished, but we chose not to replace\n                // the existing entry in the cache. Don't try again until or unless the\n                // revalidation entry expires.\n                return null;\n            default:\n                nonEmptyRevalidatingSegment;\n                return null;\n        }\n    }\n}\nconst noop = ()=>{};\nfunction upsertSegmentOnCompletion(promise, varyPath) {\n    // Wait for a segment to finish loading, then upsert it into the cache\n    promise.then((fulfilled)=>{\n        if (fulfilled !== null) {\n            // Received new data. Attempt to replace the existing entry in the cache.\n            (0, _cache.upsertSegmentEntry)(Date.now(), varyPath, fulfilled);\n        }\n    }, noop);\n}\nfunction doesCurrentSegmentMatchCachedSegment(route, currentSegment, cachedSegment) {\n    if (cachedSegment === _segment.PAGE_SEGMENT_KEY) {\n        // In the FlightRouterState stored by the router, the page segment has the\n        // rendered search params appended to the name of the segment. In the\n        // prefetch cache, however, this is stored separately. So, when comparing\n        // the router's current FlightRouterState to the cached FlightRouterState,\n        // we need to make sure we compare both parts of the segment.\n        // TODO: This is not modeled clearly. We use the same type,\n        // FlightRouterState, for both the CacheNode tree _and_ the prefetch cache\n        // _and_ the server response format, when conceptually those are three\n        // different things and treated in different ways. We should encode more of\n        // this information into the type design so mistakes are less likely.\n        return currentSegment === (0, _segment.addSearchParamsIfPageSegment)(_segment.PAGE_SEGMENT_KEY, Object.fromEntries(new URLSearchParams(route.renderedSearch)));\n    }\n    // Non-page segments are compared using the same function as the server\n    return (0, _matchsegments.matchSegment)(cachedSegment, currentSegment);\n}\n// -----------------------------------------------------------------------------\n// The remainder of the module is a MinHeap implementation. Try not to put any\n// logic below here unless it's related to the heap algorithm. We can extract\n// this to a separate module if/when we need multiple kinds of heaps.\n// -----------------------------------------------------------------------------\nfunction compareQueuePriority(a, b) {\n    // Since the queue is a MinHeap, this should return a positive number if b is\n    // higher priority than a, and a negative number if a is higher priority\n    // than b.\n    // `priority` is an integer, where higher numbers are higher priority.\n    const priorityDiff = b.priority - a.priority;\n    if (priorityDiff !== 0) {\n        return priorityDiff;\n    }\n    // If the priority is the same, check which phase the prefetch is in — is it\n    // prefetching the route tree, or the segments? Route trees are prioritized.\n    const phaseDiff = b.phase - a.phase;\n    if (phaseDiff !== 0) {\n        return phaseDiff;\n    }\n    // Finally, check the insertion order. `sortId` is an incrementing counter\n    // assigned to prefetches. We want to process the newest prefetches first.\n    return b.sortId - a.sortId;\n}\nfunction heapPush(heap, node) {\n    const index = heap.length;\n    heap.push(node);\n    node._heapIndex = index;\n    heapSiftUp(heap, node, index);\n}\nfunction heapPeek(heap) {\n    return heap.length === 0 ? null : heap[0];\n}\nfunction heapPop(heap) {\n    if (heap.length === 0) {\n        return null;\n    }\n    const first = heap[0];\n    first._heapIndex = -1;\n    const last = heap.pop();\n    if (last !== first) {\n        heap[0] = last;\n        last._heapIndex = 0;\n        heapSiftDown(heap, last, 0);\n    }\n    return first;\n}\nfunction heapDelete(heap, node) {\n    const index = node._heapIndex;\n    if (index !== -1) {\n        node._heapIndex = -1;\n        if (heap.length !== 0) {\n            const last = heap.pop();\n            if (last !== node) {\n                heap[index] = last;\n                last._heapIndex = index;\n                heapSiftDown(heap, last, index);\n            }\n        }\n    }\n}\nfunction heapResift(heap, node) {\n    const index = node._heapIndex;\n    if (index !== -1) {\n        if (index === 0) {\n            heapSiftDown(heap, node, 0);\n        } else {\n            const parentIndex = index - 1 >>> 1;\n            const parent = heap[parentIndex];\n            if (compareQueuePriority(parent, node) > 0) {\n                // The parent is larger. Sift up.\n                heapSiftUp(heap, node, index);\n            } else {\n                // The parent is smaller (or equal). Sift down.\n                heapSiftDown(heap, node, index);\n            }\n        }\n    }\n}\nfunction heapSiftUp(heap, node, i) {\n    let index = i;\n    while(index > 0){\n        const parentIndex = index - 1 >>> 1;\n        const parent = heap[parentIndex];\n        if (compareQueuePriority(parent, node) > 0) {\n            // The parent is larger. Swap positions.\n            heap[parentIndex] = node;\n            node._heapIndex = parentIndex;\n            heap[index] = parent;\n            parent._heapIndex = index;\n            index = parentIndex;\n        } else {\n            // The parent is smaller. Exit.\n            return;\n        }\n    }\n}\nfunction heapSiftDown(heap, node, i) {\n    let index = i;\n    const length = heap.length;\n    const halfLength = length >>> 1;\n    while(index < halfLength){\n        const leftIndex = (index + 1) * 2 - 1;\n        const left = heap[leftIndex];\n        const rightIndex = leftIndex + 1;\n        const right = heap[rightIndex];\n        // If the left or right node is smaller, swap with the smaller of those.\n        if (compareQueuePriority(left, node) < 0) {\n            if (rightIndex < length && compareQueuePriority(right, left) < 0) {\n                heap[index] = right;\n                right._heapIndex = index;\n                heap[rightIndex] = node;\n                node._heapIndex = rightIndex;\n                index = rightIndex;\n            } else {\n                heap[index] = left;\n                left._heapIndex = index;\n                heap[leftIndex] = node;\n                node._heapIndex = leftIndex;\n                index = leftIndex;\n            }\n        } else if (rightIndex < length && compareQueuePriority(right, node) < 0) {\n            heap[index] = right;\n            right._heapIndex = index;\n            heap[rightIndex] = node;\n            node._heapIndex = rightIndex;\n            index = rightIndex;\n        } else {\n            // Neither child is smaller. Exit.\n            return;\n        }\n    }\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=scheduler.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    IDLE_LINK_STATUS: null,\n    PENDING_LINK_STATUS: null,\n    mountFormInstance: null,\n    mountLinkInstance: null,\n    onLinkVisibilityChanged: null,\n    onNavigationIntent: null,\n    pingVisibleLinks: null,\n    setLinkForCurrentNavigation: null,\n    unmountLinkForCurrentNavigation: null,\n    unmountPrefetchableInstance: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    IDLE_LINK_STATUS: function() {\n        return IDLE_LINK_STATUS;\n    },\n    PENDING_LINK_STATUS: function() {\n        return PENDING_LINK_STATUS;\n    },\n    mountFormInstance: function() {\n        return mountFormInstance;\n    },\n    mountLinkInstance: function() {\n        return mountLinkInstance;\n    },\n    onLinkVisibilityChanged: function() {\n        return onLinkVisibilityChanged;\n    },\n    onNavigationIntent: function() {\n        return onNavigationIntent;\n    },\n    pingVisibleLinks: function() {\n        return pingVisibleLinks;\n    },\n    setLinkForCurrentNavigation: function() {\n        return setLinkForCurrentNavigation;\n    },\n    unmountLinkForCurrentNavigation: function() {\n        return unmountLinkForCurrentNavigation;\n    },\n    unmountPrefetchableInstance: function() {\n        return unmountPrefetchableInstance;\n    }\n});\nconst _types = require(\"./segment-cache/types\");\nconst _cachekey = require(\"./segment-cache/cache-key\");\nconst _scheduler = require(\"./segment-cache/scheduler\");\nconst _react = require(\"react\");\n// Tracks the most recently navigated link instance. When null, indicates\n// the current navigation was not initiated by a link click.\nlet linkForMostRecentNavigation = null;\nconst PENDING_LINK_STATUS = {\n    pending: true\n};\nconst IDLE_LINK_STATUS = {\n    pending: false\n};\nfunction setLinkForCurrentNavigation(link) {\n    (0, _react.startTransition)(()=>{\n        linkForMostRecentNavigation?.setOptimisticLinkStatus(IDLE_LINK_STATUS);\n        link?.setOptimisticLinkStatus(PENDING_LINK_STATUS);\n        linkForMostRecentNavigation = link;\n    });\n}\nfunction unmountLinkForCurrentNavigation(link) {\n    if (linkForMostRecentNavigation === link) {\n        linkForMostRecentNavigation = null;\n    }\n}\n// Use a WeakMap to associate a Link instance with its DOM element. This is\n// used by the IntersectionObserver to track the link's visibility.\nconst prefetchable = typeof WeakMap === 'function' ? new WeakMap() : new Map();\n// A Set of the currently visible links. We re-prefetch visible links after a\n// cache invalidation, or when the current URL changes. It's a separate data\n// structure from the WeakMap above because only the visible links need to\n// be enumerated.\nconst prefetchableAndVisible = new Set();\n// A single IntersectionObserver instance shared by all <Link> components.\nconst observer = typeof IntersectionObserver === 'function' ? new IntersectionObserver(handleIntersect, {\n    rootMargin: '200px'\n}) : null;\nfunction observeVisibility(element, instance) {\n    const existingInstance = prefetchable.get(element);\n    if (existingInstance !== undefined) {\n        // This shouldn't happen because each <Link> component should have its own\n        // anchor tag instance, but it's defensive coding to avoid a memory leak in\n        // case there's a logical error somewhere else.\n        unmountPrefetchableInstance(element);\n    }\n    // Only track prefetchable links that have a valid prefetch URL\n    prefetchable.set(element, instance);\n    if (observer !== null) {\n        observer.observe(element);\n    }\n}\nfunction coercePrefetchableUrl(href) {\n    if (typeof window !== 'undefined') {\n        const { createPrefetchURL } = require('./app-router-utils');\n        try {\n            return createPrefetchURL(href);\n        } catch  {\n            // createPrefetchURL sometimes throws an error if an invalid URL is\n            // provided, though I'm not sure if it's actually necessary.\n            // TODO: Consider removing the throw from the inner function, or change it\n            // to reportError. Or maybe the error isn't even necessary for automatic\n            // prefetches, just navigations.\n            const reportErrorFn = typeof reportError === 'function' ? reportError : console.error;\n            reportErrorFn(`Cannot prefetch '${href}' because it cannot be converted to a URL.`);\n            return null;\n        }\n    } else {\n        return null;\n    }\n}\nfunction mountLinkInstance(element, href, router, fetchStrategy, prefetchEnabled, setOptimisticLinkStatus) {\n    if (prefetchEnabled) {\n        const prefetchURL = coercePrefetchableUrl(href);\n        if (prefetchURL !== null) {\n            const instance = {\n                router,\n                fetchStrategy,\n                isVisible: false,\n                prefetchTask: null,\n                prefetchHref: prefetchURL.href,\n                setOptimisticLinkStatus\n            };\n            // We only observe the link's visibility if it's prefetchable. For\n            // example, this excludes links to external URLs.\n            observeVisibility(element, instance);\n            return instance;\n        }\n    }\n    // If the link is not prefetchable, we still create an instance so we can\n    // track its optimistic state (i.e. useLinkStatus).\n    const instance = {\n        router,\n        fetchStrategy,\n        isVisible: false,\n        prefetchTask: null,\n        prefetchHref: null,\n        setOptimisticLinkStatus\n    };\n    return instance;\n}\nfunction mountFormInstance(element, href, router, fetchStrategy) {\n    const prefetchURL = coercePrefetchableUrl(href);\n    if (prefetchURL === null) {\n        // This href is not prefetchable, so we don't track it.\n        // TODO: We currently observe/unobserve a form every time its href changes.\n        // For Links, this isn't a big deal because the href doesn't usually change,\n        // but for forms it's extremely common. We should optimize this.\n        return;\n    }\n    const instance = {\n        router,\n        fetchStrategy,\n        isVisible: false,\n        prefetchTask: null,\n        prefetchHref: prefetchURL.href,\n        setOptimisticLinkStatus: null\n    };\n    observeVisibility(element, instance);\n}\nfunction unmountPrefetchableInstance(element) {\n    const instance = prefetchable.get(element);\n    if (instance !== undefined) {\n        prefetchable.delete(element);\n        prefetchableAndVisible.delete(instance);\n        const prefetchTask = instance.prefetchTask;\n        if (prefetchTask !== null) {\n            (0, _scheduler.cancelPrefetchTask)(prefetchTask);\n        }\n    }\n    if (observer !== null) {\n        observer.unobserve(element);\n    }\n}\nfunction handleIntersect(entries) {\n    for (const entry of entries){\n        // Some extremely old browsers or polyfills don't reliably support\n        // isIntersecting so we check intersectionRatio instead. (Do we care? Not\n        // really. But whatever this is fine.)\n        const isVisible = entry.intersectionRatio > 0;\n        onLinkVisibilityChanged(entry.target, isVisible);\n    }\n}\nfunction onLinkVisibilityChanged(element, isVisible) {\n    if (process.env.NODE_ENV !== 'production') {\n        // Prefetching on viewport is disabled in development for performance\n        // reasons, because it requires compiling the target page.\n        // TODO: Investigate re-enabling this.\n        return;\n    }\n    const instance = prefetchable.get(element);\n    if (instance === undefined) {\n        return;\n    }\n    instance.isVisible = isVisible;\n    if (isVisible) {\n        prefetchableAndVisible.add(instance);\n    } else {\n        prefetchableAndVisible.delete(instance);\n    }\n    rescheduleLinkPrefetch(instance, _types.PrefetchPriority.Default);\n}\nfunction onNavigationIntent(element, unstable_upgradeToDynamicPrefetch) {\n    const instance = prefetchable.get(element);\n    if (instance === undefined) {\n        return;\n    }\n    // Prefetch the link on hover/touchstart.\n    if (instance !== undefined) {\n        if (process.env.__NEXT_DYNAMIC_ON_HOVER && unstable_upgradeToDynamicPrefetch) {\n            // Switch to a full prefetch\n            instance.fetchStrategy = _types.FetchStrategy.Full;\n        }\n        rescheduleLinkPrefetch(instance, _types.PrefetchPriority.Intent);\n    }\n}\nfunction rescheduleLinkPrefetch(instance, priority) {\n    // Ensures that app-router-instance is not compiled in the server bundle\n    if (typeof window !== 'undefined') {\n        const existingPrefetchTask = instance.prefetchTask;\n        if (!instance.isVisible) {\n            // Cancel any in-progress prefetch task. (If it already finished then this\n            // is a no-op.)\n            if (existingPrefetchTask !== null) {\n                (0, _scheduler.cancelPrefetchTask)(existingPrefetchTask);\n            }\n            // We don't need to reset the prefetchTask to null upon cancellation; an\n            // old task object can be rescheduled with reschedulePrefetchTask. This is a\n            // micro-optimization but also makes the code simpler (don't need to\n            // worry about whether an old task object is stale).\n            return;\n        }\n        const { getCurrentAppRouterState } = require('./app-router-instance');\n        const appRouterState = getCurrentAppRouterState();\n        if (appRouterState !== null) {\n            const treeAtTimeOfPrefetch = appRouterState.tree;\n            if (existingPrefetchTask === null) {\n                // Initiate a prefetch task.\n                const nextUrl = appRouterState.nextUrl;\n                const cacheKey = (0, _cachekey.createCacheKey)(instance.prefetchHref, nextUrl);\n                instance.prefetchTask = (0, _scheduler.schedulePrefetchTask)(cacheKey, treeAtTimeOfPrefetch, instance.fetchStrategy, priority, null);\n            } else {\n                // We already have an old task object that we can reschedule. This is\n                // effectively the same as canceling the old task and creating a new one.\n                (0, _scheduler.reschedulePrefetchTask)(existingPrefetchTask, treeAtTimeOfPrefetch, instance.fetchStrategy, priority);\n            }\n        }\n    }\n}\nfunction pingVisibleLinks(nextUrl, tree) {\n    // For each currently visible link, cancel the existing prefetch task (if it\n    // exists) and schedule a new one. This is effectively the same as if all the\n    // visible links left and then re-entered the viewport.\n    //\n    // This is called when the Next-Url or the base tree changes, since those\n    // may affect the result of a prefetch task. It's also called after a\n    // cache invalidation.\n    for (const instance of prefetchableAndVisible){\n        const task = instance.prefetchTask;\n        if (task !== null && !(0, _scheduler.isPrefetchTaskDirty)(task, nextUrl, tree)) {\n            continue;\n        }\n        // Something changed. Cancel the existing prefetch task and schedule a\n        // new one.\n        if (task !== null) {\n            (0, _scheduler.cancelPrefetchTask)(task);\n        }\n        const cacheKey = (0, _cachekey.createCacheKey)(instance.prefetchHref, nextUrl);\n        instance.prefetchTask = (0, _scheduler.schedulePrefetchTask)(cacheKey, tree, instance.fetchStrategy, _types.PrefetchPriority.Default, null);\n    }\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=links.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"pathHasPrefix\", {\n    enumerable: true,\n    get: function() {\n        return pathHasPrefix;\n    }\n});\nconst _parsepath = require(\"./parse-path\");\nfunction pathHasPrefix(path, prefix) {\n    if (typeof path !== 'string') {\n        return false;\n    }\n    const { pathname } = (0, _parsepath.parsePath)(path);\n    return pathname === prefix || pathname.startsWith(prefix + '/');\n}\n\n//# sourceMappingURL=path-has-prefix.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"hasBasePath\", {\n    enumerable: true,\n    get: function() {\n        return hasBasePath;\n    }\n});\nconst _pathhasprefix = require(\"../shared/lib/router/utils/path-has-prefix\");\nconst basePath = process.env.__NEXT_ROUTER_BASEPATH || '';\nfunction hasBasePath(path) {\n    return (0, _pathhasprefix.pathHasPrefix)(path, basePath);\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=has-base-path.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"isLocalURL\", {\n    enumerable: true,\n    get: function() {\n        return isLocalURL;\n    }\n});\nconst _utils = require(\"../../utils\");\nconst _hasbasepath = require(\"../../../../client/has-base-path\");\nfunction isLocalURL(url) {\n    // prevent a hydration mismatch on href for url with anchor refs\n    if (!(0, _utils.isAbsoluteUrl)(url)) return true;\n    try {\n        // absolute urls can be local if they are on the same origin\n        const locationOrigin = (0, _utils.getLocationOrigin)();\n        const resolved = new URL(url, locationOrigin);\n        return resolved.origin === locationOrigin && (0, _hasbasepath.hasBasePath)(resolved.pathname);\n    } catch (_) {\n        return false;\n    }\n}\n\n//# sourceMappingURL=is-local-url.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"errorOnce\", {\n    enumerable: true,\n    get: function() {\n        return errorOnce;\n    }\n});\nlet errorOnce = (_)=>{};\nif (process.env.NODE_ENV !== 'production') {\n    const errors = new Set();\n    errorOnce = (msg)=>{\n        if (!errors.has(msg)) {\n            console.error(msg);\n        }\n        errors.add(msg);\n    };\n}\n\n//# sourceMappingURL=error-once.js.map","'use client';\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    default: null,\n    useLinkStatus: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    /**\n * A React component that extends the HTML `<a>` element to provide\n * [prefetching](https://nextjs.org/docs/app/building-your-application/routing/linking-and-navigating#2-prefetching)\n * and client-side navigation. This is the primary way to navigate between routes in Next.js.\n *\n * @remarks\n * - Prefetching is only enabled in production.\n *\n * @see https://nextjs.org/docs/app/api-reference/components/link\n */ default: function() {\n        return LinkComponent;\n    },\n    useLinkStatus: function() {\n        return useLinkStatus;\n    }\n});\nconst _interop_require_wildcard = require(\"@swc/helpers/_/_interop_require_wildcard\");\nconst _jsxruntime = require(\"react/jsx-runtime\");\nconst _react = /*#__PURE__*/ _interop_require_wildcard._(require(\"react\"));\nconst _formaturl = require(\"../../shared/lib/router/utils/format-url\");\nconst _approutercontextsharedruntime = require(\"../../shared/lib/app-router-context.shared-runtime\");\nconst _usemergedref = require(\"../use-merged-ref\");\nconst _utils = require(\"../../shared/lib/utils\");\nconst _addbasepath = require(\"../add-base-path\");\nconst _warnonce = require(\"../../shared/lib/utils/warn-once\");\nconst _links = require(\"../components/links\");\nconst _islocalurl = require(\"../../shared/lib/router/utils/is-local-url\");\nconst _types = require(\"../components/segment-cache/types\");\nconst _erroronce = require(\"../../shared/lib/utils/error-once\");\nfunction isModifiedEvent(event) {\n    const eventTarget = event.currentTarget;\n    const target = eventTarget.getAttribute('target');\n    return target && target !== '_self' || event.metaKey || event.ctrlKey || event.shiftKey || event.altKey || // triggers resource download\n    event.nativeEvent && event.nativeEvent.which === 2;\n}\nfunction linkClicked(e, href, as, linkInstanceRef, replace, scroll, onNavigate) {\n    if (typeof window !== 'undefined') {\n        const { nodeName } = e.currentTarget;\n        // anchors inside an svg have a lowercase nodeName\n        const isAnchorNodeName = nodeName.toUpperCase() === 'A';\n        if (isAnchorNodeName && isModifiedEvent(e) || e.currentTarget.hasAttribute('download')) {\n            // ignore click for browser’s default behavior\n            return;\n        }\n        if (!(0, _islocalurl.isLocalURL)(href)) {\n            if (replace) {\n                // browser default behavior does not replace the history state\n                // so we need to do it manually\n                e.preventDefault();\n                location.replace(href);\n            }\n            // ignore click for browser’s default behavior\n            return;\n        }\n        e.preventDefault();\n        if (onNavigate) {\n            let isDefaultPrevented = false;\n            onNavigate({\n                preventDefault: ()=>{\n                    isDefaultPrevented = true;\n                }\n            });\n            if (isDefaultPrevented) {\n                return;\n            }\n        }\n        const { dispatchNavigateAction } = require('../components/app-router-instance');\n        _react.default.startTransition(()=>{\n            dispatchNavigateAction(as || href, replace ? 'replace' : 'push', scroll ?? true, linkInstanceRef.current);\n        });\n    }\n}\nfunction formatStringOrUrl(urlObjOrString) {\n    if (typeof urlObjOrString === 'string') {\n        return urlObjOrString;\n    }\n    return (0, _formaturl.formatUrl)(urlObjOrString);\n}\nfunction LinkComponent(props) {\n    const [linkStatus, setOptimisticLinkStatus] = (0, _react.useOptimistic)(_links.IDLE_LINK_STATUS);\n    let children;\n    const linkInstanceRef = (0, _react.useRef)(null);\n    const { href: hrefProp, as: asProp, children: childrenProp, prefetch: prefetchProp = null, passHref, replace, shallow, scroll, onClick, onMouseEnter: onMouseEnterProp, onTouchStart: onTouchStartProp, legacyBehavior = false, onNavigate, ref: forwardedRef, unstable_dynamicOnHover, ...restProps } = props;\n    children = childrenProp;\n    if (legacyBehavior && (typeof children === 'string' || typeof children === 'number')) {\n        children = /*#__PURE__*/ (0, _jsxruntime.jsx)(\"a\", {\n            children: children\n        });\n    }\n    const router = _react.default.useContext(_approutercontextsharedruntime.AppRouterContext);\n    const prefetchEnabled = prefetchProp !== false;\n    const fetchStrategy = prefetchProp !== false ? getFetchStrategyFromPrefetchProp(prefetchProp) : _types.FetchStrategy.PPR;\n    if (process.env.NODE_ENV !== 'production') {\n        function createPropError(args) {\n            return Object.defineProperty(new Error(`Failed prop type: The prop \\`${args.key}\\` expects a ${args.expected} in \\`<Link>\\`, but got \\`${args.actual}\\` instead.` + (typeof window !== 'undefined' ? \"\\nOpen your browser's console to view the Component stack trace.\" : '')), \"__NEXT_ERROR_CODE\", {\n                value: \"E319\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        // TypeScript trick for type-guarding:\n        const requiredPropsGuard = {\n            href: true\n        };\n        const requiredProps = Object.keys(requiredPropsGuard);\n        requiredProps.forEach((key)=>{\n            if (key === 'href') {\n                if (props[key] == null || typeof props[key] !== 'string' && typeof props[key] !== 'object') {\n                    throw createPropError({\n                        key,\n                        expected: '`string` or `object`',\n                        actual: props[key] === null ? 'null' : typeof props[key]\n                    });\n                }\n            } else {\n                // TypeScript trick for type-guarding:\n                const _ = key;\n            }\n        });\n        // TypeScript trick for type-guarding:\n        const optionalPropsGuard = {\n            as: true,\n            replace: true,\n            scroll: true,\n            shallow: true,\n            passHref: true,\n            prefetch: true,\n            unstable_dynamicOnHover: true,\n            onClick: true,\n            onMouseEnter: true,\n            onTouchStart: true,\n            legacyBehavior: true,\n            onNavigate: true\n        };\n        const optionalProps = Object.keys(optionalPropsGuard);\n        optionalProps.forEach((key)=>{\n            const valType = typeof props[key];\n            if (key === 'as') {\n                if (props[key] && valType !== 'string' && valType !== 'object') {\n                    throw createPropError({\n                        key,\n                        expected: '`string` or `object`',\n                        actual: valType\n                    });\n                }\n            } else if (key === 'onClick' || key === 'onMouseEnter' || key === 'onTouchStart' || key === 'onNavigate') {\n                if (props[key] && valType !== 'function') {\n                    throw createPropError({\n                        key,\n                        expected: '`function`',\n                        actual: valType\n                    });\n                }\n            } else if (key === 'replace' || key === 'scroll' || key === 'shallow' || key === 'passHref' || key === 'legacyBehavior' || key === 'unstable_dynamicOnHover') {\n                if (props[key] != null && valType !== 'boolean') {\n                    throw createPropError({\n                        key,\n                        expected: '`boolean`',\n                        actual: valType\n                    });\n                }\n            } else if (key === 'prefetch') {\n                if (props[key] != null && valType !== 'boolean' && props[key] !== 'auto') {\n                    throw createPropError({\n                        key,\n                        expected: '`boolean | \"auto\"`',\n                        actual: valType\n                    });\n                }\n            } else {\n                // TypeScript trick for type-guarding:\n                const _ = key;\n            }\n        });\n    }\n    if (process.env.NODE_ENV !== 'production') {\n        if (props.locale) {\n            (0, _warnonce.warnOnce)('The `locale` prop is not supported in `next/link` while using the `app` router. Read more about app router internalization: https://nextjs.org/docs/app/building-your-application/routing/internationalization');\n        }\n        if (!asProp) {\n            let href;\n            if (typeof hrefProp === 'string') {\n                href = hrefProp;\n            } else if (typeof hrefProp === 'object' && typeof hrefProp.pathname === 'string') {\n                href = hrefProp.pathname;\n            }\n            if (href) {\n                const hasDynamicSegment = href.split('/').some((segment)=>segment.startsWith('[') && segment.endsWith(']'));\n                if (hasDynamicSegment) {\n                    throw Object.defineProperty(new Error(`Dynamic href \\`${href}\\` found in <Link> while using the \\`/app\\` router, this is not supported. Read more: https://nextjs.org/docs/messages/app-dir-dynamic-href`), \"__NEXT_ERROR_CODE\", {\n                        value: \"E267\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                }\n            }\n        }\n    }\n    const { href, as } = _react.default.useMemo(()=>{\n        const resolvedHref = formatStringOrUrl(hrefProp);\n        return {\n            href: resolvedHref,\n            as: asProp ? formatStringOrUrl(asProp) : resolvedHref\n        };\n    }, [\n        hrefProp,\n        asProp\n    ]);\n    // This will return the first child, if multiple are provided it will throw an error\n    let child;\n    if (legacyBehavior) {\n        if (children?.$$typeof === Symbol.for('react.lazy')) {\n            throw Object.defineProperty(new Error(`\\`<Link legacyBehavior>\\` received a direct child that is either a Server Component, or JSX that was loaded with React.lazy(). This is not supported. Either remove legacyBehavior, or make the direct child a Client Component that renders the Link's \\`<a>\\` tag.`), \"__NEXT_ERROR_CODE\", {\n                value: \"E863\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        if (process.env.NODE_ENV === 'development') {\n            if (onClick) {\n                console.warn(`\"onClick\" was passed to <Link> with \\`href\\` of \\`${hrefProp}\\` but \"legacyBehavior\" was set. The legacy behavior requires onClick be set on the child of next/link`);\n            }\n            if (onMouseEnterProp) {\n                console.warn(`\"onMouseEnter\" was passed to <Link> with \\`href\\` of \\`${hrefProp}\\` but \"legacyBehavior\" was set. The legacy behavior requires onMouseEnter be set on the child of next/link`);\n            }\n            try {\n                child = _react.default.Children.only(children);\n            } catch (err) {\n                if (!children) {\n                    throw Object.defineProperty(new Error(`No children were passed to <Link> with \\`href\\` of \\`${hrefProp}\\` but one child is required https://nextjs.org/docs/messages/link-no-children`), \"__NEXT_ERROR_CODE\", {\n                        value: \"E320\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                }\n                throw Object.defineProperty(new Error(`Multiple children were passed to <Link> with \\`href\\` of \\`${hrefProp}\\` but only one child is supported https://nextjs.org/docs/messages/link-multiple-children` + (typeof window !== 'undefined' ? \" \\nOpen your browser's console to view the Component stack trace.\" : '')), \"__NEXT_ERROR_CODE\", {\n                    value: \"E266\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n        } else {\n            child = _react.default.Children.only(children);\n        }\n    } else {\n        if (process.env.NODE_ENV === 'development') {\n            if (children?.type === 'a') {\n                throw Object.defineProperty(new Error('Invalid <Link> with <a> child. Please remove <a> or use <Link legacyBehavior>.\\nLearn more: https://nextjs.org/docs/messages/invalid-new-link-with-extra-anchor'), \"__NEXT_ERROR_CODE\", {\n                    value: \"E209\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n        }\n    }\n    const childRef = legacyBehavior ? child && typeof child === 'object' && child.ref : forwardedRef;\n    // Use a callback ref to attach an IntersectionObserver to the anchor tag on\n    // mount. In the future we will also use this to keep track of all the\n    // currently mounted <Link> instances, e.g. so we can re-prefetch them after\n    // a revalidation or refresh.\n    const observeLinkVisibilityOnMount = _react.default.useCallback((element)=>{\n        if (router !== null) {\n            linkInstanceRef.current = (0, _links.mountLinkInstance)(element, href, router, fetchStrategy, prefetchEnabled, setOptimisticLinkStatus);\n        }\n        return ()=>{\n            if (linkInstanceRef.current) {\n                (0, _links.unmountLinkForCurrentNavigation)(linkInstanceRef.current);\n                linkInstanceRef.current = null;\n            }\n            (0, _links.unmountPrefetchableInstance)(element);\n        };\n    }, [\n        prefetchEnabled,\n        href,\n        router,\n        fetchStrategy,\n        setOptimisticLinkStatus\n    ]);\n    const mergedRef = (0, _usemergedref.useMergedRef)(observeLinkVisibilityOnMount, childRef);\n    const childProps = {\n        ref: mergedRef,\n        onClick (e) {\n            if (process.env.NODE_ENV !== 'production') {\n                if (!e) {\n                    throw Object.defineProperty(new Error(`Component rendered inside next/link has to pass click event to \"onClick\" prop.`), \"__NEXT_ERROR_CODE\", {\n                        value: \"E312\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                }\n            }\n            if (!legacyBehavior && typeof onClick === 'function') {\n                onClick(e);\n            }\n            if (legacyBehavior && child.props && typeof child.props.onClick === 'function') {\n                child.props.onClick(e);\n            }\n            if (!router) {\n                return;\n            }\n            if (e.defaultPrevented) {\n                return;\n            }\n            linkClicked(e, href, as, linkInstanceRef, replace, scroll, onNavigate);\n        },\n        onMouseEnter (e) {\n            if (!legacyBehavior && typeof onMouseEnterProp === 'function') {\n                onMouseEnterProp(e);\n            }\n            if (legacyBehavior && child.props && typeof child.props.onMouseEnter === 'function') {\n                child.props.onMouseEnter(e);\n            }\n            if (!router) {\n                return;\n            }\n            if (!prefetchEnabled || process.env.NODE_ENV === 'development') {\n                return;\n            }\n            const upgradeToDynamicPrefetch = unstable_dynamicOnHover === true;\n            (0, _links.onNavigationIntent)(e.currentTarget, upgradeToDynamicPrefetch);\n        },\n        onTouchStart: process.env.__NEXT_LINK_NO_TOUCH_START ? undefined : function onTouchStart(e) {\n            if (!legacyBehavior && typeof onTouchStartProp === 'function') {\n                onTouchStartProp(e);\n            }\n            if (legacyBehavior && child.props && typeof child.props.onTouchStart === 'function') {\n                child.props.onTouchStart(e);\n            }\n            if (!router) {\n                return;\n            }\n            if (!prefetchEnabled) {\n                return;\n            }\n            const upgradeToDynamicPrefetch = unstable_dynamicOnHover === true;\n            (0, _links.onNavigationIntent)(e.currentTarget, upgradeToDynamicPrefetch);\n        }\n    };\n    // If the url is absolute, we can bypass the logic to prepend the basePath.\n    if ((0, _utils.isAbsoluteUrl)(as)) {\n        childProps.href = as;\n    } else if (!legacyBehavior || passHref || child.type === 'a' && !('href' in child.props)) {\n        childProps.href = (0, _addbasepath.addBasePath)(as);\n    }\n    let link;\n    if (legacyBehavior) {\n        if (process.env.NODE_ENV === 'development') {\n            (0, _erroronce.errorOnce)('`legacyBehavior` is deprecated and will be removed in a future ' + 'release. A codemod is available to upgrade your components:\\n\\n' + 'npx @next/codemod@latest new-link .\\n\\n' + 'Learn more: https://nextjs.org/docs/app/building-your-application/upgrading/codemods#remove-a-tags-from-link-components');\n        }\n        link = /*#__PURE__*/ _react.default.cloneElement(child, childProps);\n    } else {\n        link = /*#__PURE__*/ (0, _jsxruntime.jsx)(\"a\", {\n            ...restProps,\n            ...childProps,\n            children: children\n        });\n    }\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(LinkStatusContext.Provider, {\n        value: linkStatus,\n        children: link\n    });\n}\nconst LinkStatusContext = /*#__PURE__*/ (0, _react.createContext)(_links.IDLE_LINK_STATUS);\nconst useLinkStatus = ()=>{\n    return (0, _react.useContext)(LinkStatusContext);\n};\nfunction getFetchStrategyFromPrefetchProp(prefetchProp) {\n    if (process.env.__NEXT_CACHE_COMPONENTS) {\n        if (prefetchProp === true) {\n            return _types.FetchStrategy.Full;\n        }\n        // `null` or `\"auto\"`: this is the default \"auto\" mode, where we will prefetch partially if the link is in the viewport.\n        // This will also include invalid prop values that don't match the types specified here.\n        // (although those should've been filtered out by prop validation in dev)\n        prefetchProp;\n        return _types.FetchStrategy.PPR;\n    } else {\n        return prefetchProp === null || prefetchProp === 'auto' ? _types.FetchStrategy.PPR : // To preserve backwards-compatibility, anything other than `false`, `null`, or `\"auto\"` results in a full prefetch.\n        // (although invalid values should've been filtered out by prop validation in dev)\n        _types.FetchStrategy.Full;\n    }\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=link.js.map","'use client';\r\n\r\nimport React, { useState, useEffect } from 'react';\r\nimport Link from 'next/link';\r\nimport { usePathname, useRouter } from 'next/navigation';\r\nimport {\r\n    LayoutDashboard,\r\n    MessageSquare,\r\n    Settings,\r\n    LogOut,\r\n    ChevronLeft,\r\n    ChevronRight,\r\n    Command,\r\n    User,\r\n    Rocket,\r\n    BarChart3,\r\n    History\r\n} from 'lucide-react';\r\nimport { cn } from '@/lib/utils';\r\nimport { supabase } from '@/lib/supabase';\r\nimport { Avatar } from '@/components/Avatar';\r\nimport { motion, AnimatePresence } from 'framer-motion';\r\nimport { toast } from 'sonner';\r\nimport { useVisualConfig } from '@/contexts/VisualConfigContext';\r\n\r\nconst menuItems = [\r\n    { name: 'Overview', href: '/admin/dashboard', icon: LayoutDashboard },\r\n    { name: 'Deployments', href: '/admin/projects', icon: Rocket },\r\n    { name: 'Analytics', href: '/admin/experiences', icon: BarChart3 },\r\n    { name: 'Logs', href: '/admin/skills', icon: History },\r\n    { name: 'Messages', href: '/admin/messages', icon: MessageSquare },\r\n    { name: 'Settings', href: '/admin/settings', icon: Settings },\r\n];\r\n\r\nexport function AdminSidebar({ onClose }: { onClose?: () => void }) {\r\n    const [isCollapsed, setIsCollapsed] = useState(false);\r\n    const pathname = usePathname();\r\n    const router = useRouter();\r\n    const [user, setUser] = useState<any>(null);\r\n    const { config } = useVisualConfig();\r\n\r\n    useEffect(() => {\r\n        const fetchUser = async () => {\r\n            const { data: { user } } = await supabase.auth.getUser();\r\n            setUser(user);\r\n        };\r\n        fetchUser();\r\n    }, []);\r\n\r\n    const handleLogout = async () => {\r\n        try {\r\n            await supabase.auth.signOut();\r\n            toast.success('Successfully logged out');\r\n            router.push('/admin');\r\n        } catch (error) {\r\n            toast.error('Logout failed');\r\n        }\r\n    };\r\n\r\n    return (\r\n        <motion.aside\r\n            initial={false}\r\n            animate={{ width: isCollapsed ? 80 : 260 }}\r\n            className=\"h-screen bg-surface border-r border-white/5 flex flex-col sticky top-0 z-50 overflow-hidden shadow-2xl\"\r\n        >\r\n            {/* Header */}\r\n            <Link href=\"/admin/dashboard\" className=\"h-16 flex items-center gap-3 px-6 border-b border-white/5 shrink-0 hover:bg-white/[0.03] transition-all cursor-pointer group\">\r\n                <div className=\"size-8 rounded-lg bg-gradient-to-br from-primary to-purple-600 flex items-center justify-center text-white shadow-lg shadow-primary/30 group-hover:shadow-primary/40 transition-all\">\r\n                    <Command size={18} className=\"group-hover:scale-110 transition-transform\" />\r\n                </div>\r\n                {!isCollapsed && (\r\n                    <motion.div \r\n                        initial={{ opacity: 0, x: -10 }}\r\n                        animate={{ opacity: 1, x: 0 }}\r\n                        className=\"flex flex-col\"\r\n                    >\r\n                        <span className=\"font-black text-lg tracking-tight text-white\">{config.brandText || 'Welcome Buddy'}</span>\r\n                        <span className=\"text-[10px] text-foreground/40 font-bold uppercase tracking-widest\">ADMIN PANEL</span>\r\n                    </motion.div>\r\n                )}\r\n            </Link>\r\n\r\n            {/* User Profile Card */}\r\n            <div className=\"p-4 border-b border-white/[0.03]\">\r\n                <div className={cn(\r\n                    \"flex items-center gap-3 p-3 rounded-2xl hover:bg-white/[0.03] transition-all cursor-pointer group overflow-hidden border border-white/5 hover:border-white/10\",\r\n                    isCollapsed && \"justify-center p-2\"\r\n                )}>\r\n                    <Avatar\r\n                        src={user?.user_metadata?.avatar_url}\r\n                        size={40}\r\n                        gradientRing={true}\r\n                        glow={true}\r\n                        dynamicColors={true}\r\n                        className=\"ring-2 ring-white/20\"\r\n                    />\r\n                    {!isCollapsed && (\r\n                        <div className=\"flex flex-col min-w-0 flex-1\">\r\n                            <span className=\"text-sm font-bold text-white truncate group-hover:text-primary transition-colors\">\r\n                                {user?.user_metadata?.display_name || 'Administrator'}\r\n                            </span>\r\n                            <span className=\"text-[10px] text-foreground/50 font-bold uppercase tracking-widest truncate mt-0.5\">\r\n                                SYSTEM ADMIN\r\n                            </span>\r\n                            {/* Status Indicator */}\r\n                            <div className=\"flex items-center gap-2 mt-2\">\r\n                                <div className=\"size-2 rounded-full bg-green-500 animate-pulse\"></div>\r\n                                <span className=\"text-[10px] text-foreground/40 font-medium hidden xl:block\">ONLINE</span>\r\n                            </div>\r\n                        </div>\r\n                    )}\r\n                </div>\r\n            </div>\r\n\r\n            {/* Navigation */}\r\n            <nav className=\"flex-1 px-3 py-6 space-y-1 overflow-y-auto\">\r\n                {menuItems.map((item) => {\r\n                    const isActive = pathname === item.href;\r\n                    return (\r\n                        <Link \r\n                            key={item.href} \r\n                            href={item.href}\r\n                            onClick={() => {\r\n                                if (window.innerWidth < 1024 && onClose) {\r\n                                    onClose();\r\n                                }\r\n                            }}\r\n                        >\r\n                            <div className={cn(\r\n                                \"flex items-center gap-3 px-3 py-3 rounded-xl transition-all relative group cursor-pointer mb-1 tap-target\",\r\n                                isActive\r\n                                    ? \"text-primary bg-primary/15 border-l-4 border-primary shadow-sm\"\r\n                                    : \"text-foreground/50 hover:text-white hover:bg-white/[0.03] border-l-4 border-transparent\",\r\n                                isCollapsed && \"justify-center px-0 py-4\"\r\n                            )}>\r\n                                <item.icon size={20} className={cn(isActive ? \"text-primary\" : \"text-foreground/40 group-hover:text-foreground/70\")} />\r\n                                {!isCollapsed && (\r\n                                    <span className=\"text-sm font-semibold tracking-tight\">{item.name}</span>\r\n                                )}\r\n                                {isActive && !isCollapsed && (\r\n                                    <motion.div\r\n                                        layoutId=\"nav-pill\"\r\n                                        className=\"absolute left-0 w-1 h-6 bg-primary rounded-r-full\"\r\n                                        initial={false}\r\n                                        animate={{ height: '1.5rem' }}\r\n                                    />\r\n                                )}\r\n                            </div>\r\n                        </Link>\r\n                    );\r\n                })}\r\n            </nav>\r\n\r\n            {/* Storage Metric */}\r\n            {!isCollapsed && (\r\n                <div className=\"p-4\">\r\n                    <div className=\"rounded-2xl bg-white/[0.02] p-4 border border-white/5\">\r\n                        <h4 className=\"mb-2 text-[10px] font-bold uppercase tracking-[0.2em] text-foreground/30\">Storage Capacity</h4>\r\n                        <div className=\"flex items-end gap-1 mb-2\">\r\n                            <span className=\"text-lg font-bold text-white\">85%</span>\r\n                            <span className=\"text-[10px] text-foreground/20 font-medium mb-1\">consumed</span>\r\n                        </div>\r\n                        <div className=\"h-1.5 w-full rounded-full bg-white/5 overflow-hidden\">\r\n                            <motion.div \r\n                                initial={{ width: 0 }}\r\n                                animate={{ width: '85%' }}\r\n                                className=\"h-full rounded-full bg-primary shadow-[0_0_10px_rgba(124,59,237,0.5)]\" \r\n                            />\r\n                        </div>\r\n                    </div>\r\n                </div>\r\n            )}\r\n\r\n            {/* Footer Actions */}\r\n            <div className=\"p-3 border-t border-white/5 space-y-1\">\r\n                <button\r\n                    onClick={() => setIsCollapsed(!isCollapsed)}\r\n                    className={cn(\r\n                        \"w-full flex items-center gap-3 px-3 py-2.5 rounded-xl text-foreground/40 hover:text-white hover:bg-white/[0.02] transition-all\",\r\n                        isCollapsed && \"justify-center\"\r\n                    )}\r\n                >\r\n                    {isCollapsed ? <ChevronRight size={20} /> : <ChevronLeft size={20} />}\r\n                    {!isCollapsed && <span className=\"text-sm font-medium\">Collapse Sidebar</span>}\r\n                </button>\r\n                <button\r\n                    onClick={() => {\r\n                        handleLogout();\r\n                        if (window.innerWidth < 1024 && onClose) {\r\n                            onClose();\r\n                        }\r\n                    }}\r\n                    className={cn(\r\n                        \"w-full flex items-center gap-3 px-3 py-2.5 rounded-xl text-red-400/50 hover:text-red-400 hover:bg-red-400/5 transition-all\",\r\n                        isCollapsed && \"justify-center\"\r\n                    )}\r\n                >\r\n                    <LogOut size={20} />\r\n                    {!isCollapsed && <span className=\"text-sm font-medium\">Terminate Session</span>}\r\n                </button>\r\n            </div>\r\n        </motion.aside>\r\n    );\r\n}\r\n","'use client';\r\n\r\nimport React, { useState, useEffect } from 'react';\r\nimport { usePathname } from 'next/navigation';\r\nimport { AdminSidebar } from '@/components/admin/sidebar';\r\nimport { AdminTopbar } from '@/components/admin/topbar';\r\nimport { motion, AnimatePresence } from 'framer-motion';\r\nimport { Menu, X } from 'lucide-react';\r\n\r\nexport default function AdminLayout({ children }: { children: React.ReactNode }) {\r\n    const pathname = usePathname();\r\n    const [mobileMenuOpen, setMobileMenuOpen] = useState(false);\r\n\r\n    // Prevent body scroll when mobile menu is open\r\n    useEffect(() => {\r\n        if (mobileMenuOpen) {\r\n            document.body.style.overflow = 'hidden';\r\n        } else {\r\n            document.body.style.overflow = '';\r\n        }\r\n        \r\n        return () => {\r\n            document.body.style.overflow = '';\r\n        };\r\n    }, [mobileMenuOpen]);\r\n\r\n    if (pathname === '/admin') return (\r\n        <>\r\n            {children}\r\n        </>\r\n    );\r\n\r\n    return (\r\n        <div className=\"flex bg-background min-h-screen text-foreground selection:bg-primary/30\">\r\n            {/* Desktop Sidebar - Always visible on lg+ */}\r\n            <div className=\"hidden lg:block w-64 flex-shrink-0\">\r\n                <AdminSidebar />\r\n            </div>\r\n            \r\n            {/* Mobile Overlay */}\r\n            <AnimatePresence>\r\n                {mobileMenuOpen && (\r\n                    <motion.div\r\n                        initial={{ opacity: 0 }}\r\n                        animate={{ opacity: 1 }}\r\n                        exit={{ opacity: 0 }}\r\n                        transition={{ duration: 0.2 }}\r\n                        className=\"fixed inset-0 bg-black/70 z-40 lg:hidden backdrop-blur-sm\"\r\n                        onClick={() => setMobileMenuOpen(false)}\r\n                        aria-hidden=\"true\"\r\n                    />\r\n                )}\r\n            </AnimatePresence>\r\n            \r\n            {/* Mobile Sidebar - Slides in from left with enhanced header */}\r\n            <motion.div \r\n                initial={false}\r\n                animate={{ \r\n                    x: mobileMenuOpen ? 0 : '-100%'\r\n                }}\r\n                transition={{ type: \"spring\", damping: 25, stiffness: 300 }}\r\n                className=\"lg:hidden fixed inset-y-0 left-0 z-50 w-64 bg-surface border-r border-white/10 shadow-2xl\"\r\n            >\r\n                {/* Mobile Menu Header with Profile DP */}\r\n                <div className=\"h-16 flex items-center justify-between px-4 border-b border-white/10 bg-surface/80 backdrop-blur-xl sticky top-0 z-10\">\r\n                    <div className=\"flex items-center gap-3\">\r\n                        <div className=\"size-7 rounded-full overflow-hidden border-2 border-primary\">\r\n                            <img \r\n                                src=\"/rao-shab-new.jpg\" \r\n                                alt=\"Profile\" \r\n                                className=\"w-full h-full object-cover\"\r\n                                onError={(e) => {\r\n                                    const target = e.target as HTMLImageElement;\r\n                                    target.style.display = 'none';\r\n                                    target.parentElement!.innerHTML = '<div class=\"w-full h-full bg-primary/20 flex items-center justify-center\"><span class=\"text-primary text-xs font-bold\">DP</span></div>';\r\n                                }}\r\n                            />\r\n                        </div>\r\n                        <span className=\"text-lg font-black text-white tracking-tighter\">Rao Sahab</span>\r\n                    </div>\r\n                    <button\r\n                        onClick={() => setMobileMenuOpen(false)}\r\n                        className=\"p-2 rounded-lg text-foreground/60 hover:text-white hover:bg-white/10 transition-all duration-200 focus:outline-none focus:ring-2 focus:ring-primary/50\"\r\n                        aria-label=\"Close menu\"\r\n                    >\r\n                        <X size={24} />\r\n                    </button>\r\n                </div>\r\n                \r\n                {/* Sidebar Content */}\r\n                <div className=\"h-[calc(100vh-4rem)] overflow-y-auto\">\r\n                    <AdminSidebar onClose={() => setMobileMenuOpen(false)} />\r\n                </div>\r\n            </motion.div>\r\n            \r\n            <div className=\"flex-grow flex flex-col min-h-screen overflow-hidden\">\r\n                {/* Topbar - Visible on all screens */}\r\n                <div className=\"sticky top-0 z-30 bg-surface border-b border-white/5\">\r\n                    <div className=\"h-16 flex items-center justify-between px-4 lg:px-6\">\r\n                        <div className=\"flex items-center gap-3\">\r\n                            <div className=\"text-lg font-bold text-white hidden sm:block\">Control Panel</div>\r\n                            <div className=\"text-sm font-medium text-foreground/60 hidden lg:block\">/ {pathname.replace('/admin/', '').charAt(0).toUpperCase() + pathname.replace('/admin/', '').slice(1) || 'Dashboard'}</div>\r\n                        </div>\r\n                        <div className=\"flex items-center gap-3\">\r\n                            <button \r\n                                onClick={() => setMobileMenuOpen(true)}\r\n                                className=\"lg:hidden p-2 rounded-lg text-foreground/60 hover:text-white hover:bg-white/10 transition-all duration-200 focus:outline-none focus:ring-2 focus:ring-primary/50\"\r\n                                aria-label=\"Open menu\"\r\n                            >\r\n                                <Menu size={24} />\r\n                            </button>\r\n                            <div className=\"hidden sm:flex items-center gap-2 text-sm text-foreground/50\">\r\n                                <div className=\"w-2 h-2 rounded-full bg-green-500\"></div>\r\n                                <span>Online</span>\r\n                            </div>\r\n                        </div>\r\n                    </div>\r\n                </div>\r\n                \r\n                {/* <AdminTopbar /> - Removed as per user request */}\r\n                \r\n                {/* Second Navbar - Functional Bottom Navigation */}\r\n                <nav className=\"border-t border-white/5 bg-surface/50 backdrop-blur-lg\">\r\n                    <div className=\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8\">\r\n                        <div className=\"flex items-center justify-between h-16\">\r\n                            <div className=\"flex items-center space-x-8\">\r\n                                <a href=\"/admin/dashboard\" className=\"text-foreground/60 hover:text-white transition-colors font-medium text-sm\">\r\n                                    Dashboard\r\n                                </a>\r\n                                <a href=\"/admin/projects\" className=\"text-foreground/60 hover:text-white transition-colors font-medium text-sm\">\r\n                                    Projects\r\n                                </a>\r\n                                <a href=\"/admin/messages\" className=\"text-foreground/60 hover:text-white transition-colors font-medium text-sm\">\r\n                                    Messages\r\n                                </a>\r\n                            </div>\r\n                            <div className=\"flex items-center space-x-6\">\r\n                                <button className=\"text-foreground/60 hover:text-white transition-colors text-sm font-medium\">\r\n                                    Help\r\n                                </button>\r\n                                <button className=\"text-foreground/60 hover:text-white transition-colors text-sm font-medium\">\r\n                                    Support\r\n                                </button>\r\n                            </div>\r\n                        </div>\r\n                    </div>\r\n                </nav>\r\n                \r\n                <main className=\"flex-grow overflow-y-auto custom-scrollbar p-4 sm:p-6 md:p-8 lg:p-12 bg-[#05060A]\">\r\n                    <AnimatePresence mode=\"wait\">\r\n                        <motion.div\r\n                            key={pathname}\r\n                            initial={{ opacity: 0, y: 10 }}\r\n                            animate={{ opacity: 1, y: 0 }}\r\n                            exit={{ opacity: 0, y: -10 }}\r\n                            transition={{ duration: 0.3, ease: 'easeOut' }}\r\n                        >\r\n                            {children}\r\n                        </motion.div>\r\n                    </AnimatePresence>\r\n                </main>\r\n            </div>\r\n        </div>\r\n    );\r\n}","import createLucideIcon from '../createLucideIcon';\nimport { IconNode } from '../types';\n\nexport const __iconNode: IconNode = [['path', { d: 'm15 18-6-6 6-6', key: '1wnfg3' }]];\n\n/**\n * @component @name ChevronLeft\n * @description Lucide SVG icon component, renders SVG Element with children.\n *\n * @preview ![img](data:image/svg+xml;base64,PHN2ZyAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogIHdpZHRoPSIyNCIKICBoZWlnaHQ9IjI0IgogIHZpZXdCb3g9IjAgMCAyNCAyNCIKICBmaWxsPSJub25lIgogIHN0cm9rZT0iIzAwMCIgc3R5bGU9ImJhY2tncm91bmQtY29sb3I6ICNmZmY7IGJvcmRlci1yYWRpdXM6IDJweCIKICBzdHJva2Utd2lkdGg9IjIiCiAgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIgogIHN0cm9rZS1saW5lam9pbj0icm91bmQiCj4KICA8cGF0aCBkPSJtMTUgMTgtNi02IDYtNiIgLz4KPC9zdmc+Cg==) - https://lucide.dev/icons/chevron-left\n * @see https://lucide.dev/guide/packages/lucide-react - Documentation\n *\n * @param {Object} props - Lucide icons props and any valid SVG attribute\n * @returns {JSX.Element} JSX Element\n *\n */\nconst ChevronLeft = createLucideIcon('chevron-left', __iconNode);\n\nexport default ChevronLeft;\n","import createLucideIcon from '../createLucideIcon';\nimport { IconNode } from '../types';\n\nexport const __iconNode: IconNode = [['path', { d: 'm9 18 6-6-6-6', key: 'mthhwq' }]];\n\n/**\n * @component @name ChevronRight\n * @description Lucide SVG icon component, renders SVG Element with children.\n *\n * @preview ![img](data:image/svg+xml;base64,PHN2ZyAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogIHdpZHRoPSIyNCIKICBoZWlnaHQ9IjI0IgogIHZpZXdCb3g9IjAgMCAyNCAyNCIKICBmaWxsPSJub25lIgogIHN0cm9rZT0iIzAwMCIgc3R5bGU9ImJhY2tncm91bmQtY29sb3I6ICNmZmY7IGJvcmRlci1yYWRpdXM6IDJweCIKICBzdHJva2Utd2lkdGg9IjIiCiAgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIgogIHN0cm9rZS1saW5lam9pbj0icm91bmQiCj4KICA8cGF0aCBkPSJtOSAxOCA2LTYtNi02IiAvPgo8L3N2Zz4K) - https://lucide.dev/icons/chevron-right\n * @see https://lucide.dev/guide/packages/lucide-react - Documentation\n *\n * @param {Object} props - Lucide icons props and any valid SVG attribute\n * @returns {JSX.Element} JSX Element\n *\n */\nconst ChevronRight = createLucideIcon('chevron-right', __iconNode);\n\nexport default ChevronRight;\n","import createLucideIcon from '../createLucideIcon';\nimport { IconNode } from '../types';\n\nexport const __iconNode: IconNode = [\n  ['path', { d: 'M3 3v16a2 2 0 0 0 2 2h16', key: 'c24i48' }],\n  ['path', { d: 'M18 17V9', key: '2bz60n' }],\n  ['path', { d: 'M13 17V5', key: '1frdt8' }],\n  ['path', { d: 'M8 17v-3', key: '17ska0' }],\n];\n\n/**\n * @component @name ChartColumn\n * @description Lucide SVG icon component, renders SVG Element with children.\n *\n * @preview ![img](data:image/svg+xml;base64,PHN2ZyAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogIHdpZHRoPSIyNCIKICBoZWlnaHQ9IjI0IgogIHZpZXdCb3g9IjAgMCAyNCAyNCIKICBmaWxsPSJub25lIgogIHN0cm9rZT0iIzAwMCIgc3R5bGU9ImJhY2tncm91bmQtY29sb3I6ICNmZmY7IGJvcmRlci1yYWRpdXM6IDJweCIKICBzdHJva2Utd2lkdGg9IjIiCiAgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIgogIHN0cm9rZS1saW5lam9pbj0icm91bmQiCj4KICA8cGF0aCBkPSJNMyAzdjE2YTIgMiAwIDAgMCAyIDJoMTYiIC8+CiAgPHBhdGggZD0iTTE4IDE3VjkiIC8+CiAgPHBhdGggZD0iTTEzIDE3VjUiIC8+CiAgPHBhdGggZD0iTTggMTd2LTMiIC8+Cjwvc3ZnPgo=) - https://lucide.dev/icons/chart-column\n * @see https://lucide.dev/guide/packages/lucide-react - Documentation\n *\n * @param {Object} props - Lucide icons props and any valid SVG attribute\n * @returns {JSX.Element} JSX Element\n *\n */\nconst ChartColumn = createLucideIcon('chart-column', __iconNode);\n\nexport default ChartColumn;\n","import createLucideIcon from '../createLucideIcon';\nimport { IconNode } from '../types';\n\nexport const __iconNode: IconNode = [\n  ['rect', { width: '7', height: '9', x: '3', y: '3', rx: '1', key: '10lvy0' }],\n  ['rect', { width: '7', height: '5', x: '14', y: '3', rx: '1', key: '16une8' }],\n  ['rect', { width: '7', height: '9', x: '14', y: '12', rx: '1', key: '1hutg5' }],\n  ['rect', { width: '7', height: '5', x: '3', y: '16', rx: '1', key: 'ldoo1y' }],\n];\n\n/**\n * @component @name LayoutDashboard\n * @description Lucide SVG icon component, renders SVG Element with children.\n *\n * @preview ![img](data:image/svg+xml;base64,PHN2ZyAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogIHdpZHRoPSIyNCIKICBoZWlnaHQ9IjI0IgogIHZpZXdCb3g9IjAgMCAyNCAyNCIKICBmaWxsPSJub25lIgogIHN0cm9rZT0iIzAwMCIgc3R5bGU9ImJhY2tncm91bmQtY29sb3I6ICNmZmY7IGJvcmRlci1yYWRpdXM6IDJweCIKICBzdHJva2Utd2lkdGg9IjIiCiAgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIgogIHN0cm9rZS1saW5lam9pbj0icm91bmQiCj4KICA8cmVjdCB3aWR0aD0iNyIgaGVpZ2h0PSI5IiB4PSIzIiB5PSIzIiByeD0iMSIgLz4KICA8cmVjdCB3aWR0aD0iNyIgaGVpZ2h0PSI1IiB4PSIxNCIgeT0iMyIgcng9IjEiIC8+CiAgPHJlY3Qgd2lkdGg9IjciIGhlaWdodD0iOSIgeD0iMTQiIHk9IjEyIiByeD0iMSIgLz4KICA8cmVjdCB3aWR0aD0iNyIgaGVpZ2h0PSI1IiB4PSIzIiB5PSIxNiIgcng9IjEiIC8+Cjwvc3ZnPgo=) - https://lucide.dev/icons/layout-dashboard\n * @see https://lucide.dev/guide/packages/lucide-react - Documentation\n *\n * @param {Object} props - Lucide icons props and any valid SVG attribute\n * @returns {JSX.Element} JSX Element\n *\n */\nconst LayoutDashboard = createLucideIcon('layout-dashboard', __iconNode);\n\nexport default LayoutDashboard;\n","import createLucideIcon from '../createLucideIcon';\nimport { IconNode } from '../types';\n\nexport const __iconNode: IconNode = [\n  ['path', { d: 'm16 17 5-5-5-5', key: '1bji2h' }],\n  ['path', { d: 'M21 12H9', key: 'dn1m92' }],\n  ['path', { d: 'M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4', key: '1uf3rs' }],\n];\n\n/**\n * @component @name LogOut\n * @description Lucide SVG icon component, renders SVG Element with children.\n *\n * @preview ![img](data:image/svg+xml;base64,PHN2ZyAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogIHdpZHRoPSIyNCIKICBoZWlnaHQ9IjI0IgogIHZpZXdCb3g9IjAgMCAyNCAyNCIKICBmaWxsPSJub25lIgogIHN0cm9rZT0iIzAwMCIgc3R5bGU9ImJhY2tncm91bmQtY29sb3I6ICNmZmY7IGJvcmRlci1yYWRpdXM6IDJweCIKICBzdHJva2Utd2lkdGg9IjIiCiAgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIgogIHN0cm9rZS1saW5lam9pbj0icm91bmQiCj4KICA8cGF0aCBkPSJtMTYgMTcgNS01LTUtNSIgLz4KICA8cGF0aCBkPSJNMjEgMTJIOSIgLz4KICA8cGF0aCBkPSJNOSAyMUg1YTIgMiAwIDAgMS0yLTJWNWEyIDIgMCAwIDEgMi0yaDQiIC8+Cjwvc3ZnPgo=) - https://lucide.dev/icons/log-out\n * @see https://lucide.dev/guide/packages/lucide-react - Documentation\n *\n * @param {Object} props - Lucide icons props and any valid SVG attribute\n * @returns {JSX.Element} JSX Element\n *\n */\nconst LogOut = createLucideIcon('log-out', __iconNode);\n\nexport default LogOut;\n","import createLucideIcon from '../createLucideIcon';\nimport { IconNode } from '../types';\n\nexport const __iconNode: IconNode = [\n  [\n    'path',\n    { d: 'M15 6v12a3 3 0 1 0 3-3H6a3 3 0 1 0 3 3V6a3 3 0 1 0-3 3h12a3 3 0 1 0-3-3', key: '11bfej' },\n  ],\n];\n\n/**\n * @component @name Command\n * @description Lucide SVG icon component, renders SVG Element with children.\n *\n * @preview ![img](data:image/svg+xml;base64,PHN2ZyAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogIHdpZHRoPSIyNCIKICBoZWlnaHQ9IjI0IgogIHZpZXdCb3g9IjAgMCAyNCAyNCIKICBmaWxsPSJub25lIgogIHN0cm9rZT0iIzAwMCIgc3R5bGU9ImJhY2tncm91bmQtY29sb3I6ICNmZmY7IGJvcmRlci1yYWRpdXM6IDJweCIKICBzdHJva2Utd2lkdGg9IjIiCiAgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIgogIHN0cm9rZS1saW5lam9pbj0icm91bmQiCj4KICA8cGF0aCBkPSJNMTUgNnYxMmEzIDMgMCAxIDAgMy0zSDZhMyAzIDAgMSAwIDMgM1Y2YTMgMyAwIDEgMC0zIDNoMTJhMyAzIDAgMSAwLTMtMyIgLz4KPC9zdmc+Cg==) - https://lucide.dev/icons/command\n * @see https://lucide.dev/guide/packages/lucide-react - Documentation\n *\n * @param {Object} props - Lucide icons props and any valid SVG attribute\n * @returns {JSX.Element} JSX Element\n *\n */\nconst Command = createLucideIcon('command', __iconNode);\n\nexport default Command;\n","import createLucideIcon from '../createLucideIcon';\nimport { IconNode } from '../types';\n\nexport const __iconNode: IconNode = [\n  [\n    'path',\n    {\n      d: 'M22 17a2 2 0 0 1-2 2H6.828a2 2 0 0 0-1.414.586l-2.202 2.202A.71.71 0 0 1 2 21.286V5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2z',\n      key: '18887p',\n    },\n  ],\n];\n\n/**\n * @component @name MessageSquare\n * @description Lucide SVG icon component, renders SVG Element with children.\n *\n * @preview ![img](data:image/svg+xml;base64,PHN2ZyAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogIHdpZHRoPSIyNCIKICBoZWlnaHQ9IjI0IgogIHZpZXdCb3g9IjAgMCAyNCAyNCIKICBmaWxsPSJub25lIgogIHN0cm9rZT0iIzAwMCIgc3R5bGU9ImJhY2tncm91bmQtY29sb3I6ICNmZmY7IGJvcmRlci1yYWRpdXM6IDJweCIKICBzdHJva2Utd2lkdGg9IjIiCiAgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIgogIHN0cm9rZS1saW5lam9pbj0icm91bmQiCj4KICA8cGF0aCBkPSJNMjIgMTdhMiAyIDAgMCAxLTIgMkg2LjgyOGEyIDIgMCAwIDAtMS40MTQuNTg2bC0yLjIwMiAyLjIwMkEuNzEuNzEgMCAwIDEgMiAyMS4yODZWNWEyIDIgMCAwIDEgMi0yaDE2YTIgMiAwIDAgMSAyIDJ6IiAvPgo8L3N2Zz4K) - https://lucide.dev/icons/message-square\n * @see https://lucide.dev/guide/packages/lucide-react - Documentation\n *\n * @param {Object} props - Lucide icons props and any valid SVG attribute\n * @returns {JSX.Element} JSX Element\n *\n */\nconst MessageSquare = createLucideIcon('message-square', __iconNode);\n\nexport default MessageSquare;\n"],"names":["addPathPrefix","path","prefix","startsWith","pathname","query","hash","parsePath","addBasePath","basePath","process","env","__NEXT_ROUTER_BASEPATH","required","normalizePathTrailingSlash","__NEXT_MANUAL_CLIENT_BASE_PATH","createCacheKey","originalHref","nextUrl","originalUrl","URL","cacheKey","search","HasLoadingBoundary","ACTION_HEADER","FLIGHT_HEADERS","NEXT_ACTION_NOT_FOUND_HEADER","NEXT_ACTION_REVALIDATED_HEADER","NEXT_DID_POSTPONE_HEADER","NEXT_HMR_REFRESH_HASH_COOKIE","NEXT_HMR_REFRESH_HEADER","NEXT_HTML_REQUEST_ID_HEADER","NEXT_IS_PRERENDER_HEADER","NEXT_REQUEST_ID_HEADER","NEXT_REWRITTEN_PATH_HEADER","NEXT_REWRITTEN_QUERY_HEADER","NEXT_ROUTER_PREFETCH_HEADER","NEXT_ROUTER_SEGMENT_PREFETCH_HEADER","NEXT_ROUTER_STALE_TIME_HEADER","NEXT_ROUTER_STATE_TREE_HEADER","NEXT_RSC_UNION_QUERY","NEXT_URL","RSC_CONTENT_TYPE_HEADER","RSC_HEADER","callServer","actionId","actionArgs","Promise","resolve","reject","startTransition","dispatchAppRouterAction","type","ACTION_SERVER_ACTION","findSourceMapURL","NODE_ENV","filename","document","location","origin","includes","url","searchParams","set","href","undefined","createHrefFromUrl","includeHash","getAppBuildId","setAppBuildId","globalBuildId","buildId","computeCacheBustingSearchParam","prefetchHeader","segmentPrefetchHeader","stateTreeHeader","nextUrlHeader","hexHash","join","Fallback","createCacheMap","deleteFromCacheMap","deleteMapEntry","getFromCacheMap","isValueExpired","setInCacheMap","setSizeInCacheMap","Revalidation","cacheMap","parent","key","value","map","prev","next","size","getOrInitialize","keys","isRevalidation","entry","remainingKeys","previousKey","existingEntry","get","Map","newEntry","now","currentCacheVersion","rootEntry","getEntryWithFallbackImpl","lruPut","staleAt","version","lazilyEvictIfNeeded","result","fallbackEntry","setMapEntryValue","updateLruSize","dropRef","oldEntry","ref","deleteFromLru","parentMap","delete","revalidatingEntry","normalizeAppPath","normalizeRscURL","route","ensureLeadingSlash","split","reduce","segment","index","segments","isGroupSegment","length","replace","computeChangedPath","extractPathFromFlightRouterState","getSelectedParams","removeLeadingSlash","slice","segmentToPathname","normalizeSegments","acc","flightRouterState","Array","isArray","DEFAULT_SEGMENT_KEY","INTERCEPTION_ROUTE_MARKERS","some","m","PAGE_SEGMENT_KEY","parallelRoutes","childrenPath","children","push","Object","entries","childPath","computeChangedPathImpl","treeA","treeB","segmentA","parallelRoutesA","segmentB","parallelRoutesB","normalizedSegmentA","normalizedSegmentB","matchSegment","parallelRouterKey","changedPath","currentTree","params","parallelRoute","values","isDynamicParameter","segmentValue","isCatchAll","createRouterCacheKey","withoutSearchParameters","EntryStatus","canNewFetchStrategyProvideMoreContent","convertRouteTreeToFlightRouterState","createDetachedSegmentCacheEntry","fetchRouteOnCacheMiss","fetchSegmentOnCacheMiss","fetchSegmentPrefetchesUsingDynamicRequest","getCurrentCacheVersion","getStaleTimeMs","overwriteRevalidatingSegmentCacheEntry","pingInvalidationListeners","readOrCreateRevalidatingSegmentEntry","readOrCreateRouteCacheEntry","readOrCreateSegmentCacheEntry","readRouteCacheEntry","readSegmentCacheEntry","requestOptimisticRouteCacheEntry","revalidateEntireCache","upgradeToPendingSegment","upsertSegmentEntry","waitForSegmentCacheEntry","staleTimeSeconds","Math","max","isOutputExportMode","__NEXT_CONFIG_OUTPUT","MetadataOnlyRequestTree","routeCacheMap","segmentCacheMap","invalidationListeners","tree","startRevalidationCooldown","pingVisibleLinks","attachInvalidationListener","task","onInvalidate","Set","add","notifyInvalidationListener","error","reportError","console","tasks","isPrefetchTaskDirty","varyPath","getRouteVaryPath","readRevalidatingSegmentCacheEntry","pendingEntry","promiseWithResolvers","promise","createPromiseWithResolvers","canonicalUrl","status","blockedTasks","metadata","couldBeIntercepted","isPPREnabled","renderedSearch","Infinity","requestedUrl","requestedSearch","urlWithoutSearchParams","routeWithNoSearchParams","createPrefetchRequestKey","canonicalUrlForRouteWithNoSearchParams","optimisticCanonicalSearch","optimisticRenderedSearch","optimisticUrl","optimisticCanonicalUrl","optimisticRouteTree","createOptimisticRouteTree","optimisticMetadataTree","optimisticEntry","newRenderedSearch","clonedSlots","originalSlots","slots","parallelRouteKey","childTree","isPage","requestKey","clonePageVaryPathWithNewSearchParams","isRootLayout","hasLoadingBoundary","hasRuntimePrefetch","fetchStrategy","varyPathForRequest","getSegmentVaryPathForRequest","candidateEntry","isPartial","rejectedEntry","loading","rsc","emptyEntry","FetchStrategy","PPR","Full","pingBlockedTasks","pingPrefetchTask","fulfillRouteCacheEntry","metadataVaryPath","HEAD_REQUEST_KEY","SubtreeHasNoLoadingBoundary","fulfilledEntry","fulfillSegmentCacheEntry","segmentCacheEntry","rejectRouteCacheEntry","rejectSegmentCacheEntry","convertRootTreePrefetchToRouteTree","rootTree","renderedPathname","pathnameParts","filter","p","rootSegment","ROOT_SEGMENT_REQUEST_KEY","convertTreePrefetchToRouteTree","prefetch","partialVaryPath","pathnamePartsIndex","prefetchSlots","finalizeLayoutVaryPath","childPrefetch","childParamName","name","childParamType","paramType","childServerSentParamKey","paramKey","childDoesAppearInURL","childSegment","childPartialVaryPath","childParamValue","parseDynamicParamFromURLPart","childParamKey","getCacheKeyForDynamicParam","appendLayoutVaryPath","doesStaticSegmentAppearInURL","childPathnamePartsIndex","childRequestKeyPart","createSegmentRequestKeyPart","childRequestKey","appendSegmentRequestKeyPart","endsWith","finalizePageVaryPath","finalizeMetadataVaryPath","SegmentHasLoadingBoundary","convertRootFlightRouterStateToRouteTree","convertFlightRouterStateToRouteTree","parentPartialVaryPath","originalSegment","paramCacheKey","childRouterState","routeTree","segmentPath","headers","response","urlAfterRedirects","headResponse","fetch","method","Date","redirected","fetchPrefetchResponse","addSegmentPathToUrlInOutputExportMode","ok","body","varyHeader","closed","routeIsPPREnabled","prefetchStream","createPrefetchResponseStream","onResponseSizeUpdate","serverData","createFromNextReadableStream","getRenderedPathname","getRenderedSearch","staleTimeMs","staleTime","b","writeDynamicTreeResponseIntoCache","LoadingBoundary","fulfilledVaryPath","getFulfilledRouteVaryPath","routeKey","normalizedRequestKey","requestUrl","dynamicRequestTree","spawnedEntries","has","prepareFlightRouterStateForRequest","PPRRuntime","rejectSegmentEntriesIfStillPending","fulfilledEntries","totalBytesReceivedSoFar","averageSize","isResponsePartial","rp","writeDynamicRenderResponseIntoCache","normalizedFlightDataResult","normalizeFlightData","f","flightData","isRootRender","parseInt","isNaN","STATIC_STALETIME_MS","flightDatas","seedData","i","writeSeedDataIntoCache","head","fulfillEntrySpawnedByRuntimePrefetch","isHeadPartial","entriesOwnedByCurrentTask","seedDataChildren","childSeedData","ownedEntry","possiblyNewEntry","fetchPriority","shouldImmediatelyDecode","createFetch","contentType","isFlightResponse","originalFlightStream","onStreamClose","totalByteLength","reader","getReader","ReadableStream","pull","controller","done","read","enqueue","byteLength","staticUrl","routeDir","staticExportFilename","convertSegmentPathToStaticExportFilename","currentStrategy","newStrategy"],"mappings":"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","ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,51,52,53,54,55,56,57]}